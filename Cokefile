{spawn, exec} = require \child_process

# ANSI Terminal Colors.
bold  = '\33[0;1m'
red   = '\33[0;31m'
green = '\33[0;32m'
reset = '\33[0m'

tint = (text, color = green) -> color + text + reset

# Run our node/coco interpreter.
run = (args) ->
  proc = spawn \bin/coco, args
  proc.stderr.on \data, say
  proc       .on \exit, -> process.exit it if it

option \prefix, 'set the installation prefix for `coke install`', \DIR

task \install, 'install Coco into /usr/local (or --prefix)', (options) ->
  base = options.prefix or \/usr/local
  lib  = "#{base}/lib/coco"
  bin  = "#{base}/bin"
  node = "~/.node_libraries/coco"
  exec [
    "echo Installing Coco to #{lib}"
    "mkdir -p #{lib} #{bin}"
    "cp -rf bin lib LICENSE README.md package.json src #{lib}"
    "ln -sfv #{lib}/bin/coco #{bin}/coco"
    "ln -sfv #{lib}/bin/coke #{bin}/coke"
    "mkdir -p ~/.node_libraries"
    "ln -sfnv #{lib}/lib #{node}"
  ].join(' && '), (err, stdout, stderr) ->
    say stdout.trim() if stdout
    say if err then stderr.trim() else tint \done


sources = ->
  ext = /\.co$/i
  \src/ + file if ext.test file for file of dir \src

coreSources = ->
  "src/#{src}.co" for src of <[ coco grammar lexer nodes rewriter ]>

docs = <[ src/doc.co src/lang-co.co ]>

task \build, 'build the Coco language from source', ->
  run [\-bco \lib; ...sources().filter -> it not of docs]

task \build:doc, 'build doc tools', -> run <[ -co doc ]>.concat docs

task \build:full, 'rebuild the source twice, and run the tests', ->
  exec 'bin/coke build && bin/coke build && bin/coke test'
  , (err, stdout, stderr) ->
    say stdout.trim() if stdout
    say stderr.trim() if stderr
    throw err         if err

task \build:parser, 'rebuild the Jison parser (run "build" first)', ->
  src = require(\./lib/grammar).parser.generate()
        .replace /^[^]+?var (?=parser = {)/, \exports.
        .replace /return parser;[^]+/, ''
        .replace /\ncase \d+:this\.\$ = 0;\nbreak;/g, ''
  spit \lib/parser.js, src

task \build:browser \
'rebuild the merged script for browser or other environments' ->
  co = ''
  for name of <[ rewriter lexer parser nodes coco ]>
    src = slurp "lib/#{name}.js"
    co += "!function(exports){\n#{src}\n}(require['./#{name}'] = {});"
  spit \extras/coco.raw.js co = """
    (function(){
    function require(path){ return require[path] }
    #{co}
    var Coco = this.Coco = require['./coco']
    this.window && function(){\n#{ slurp \lib/browser.js }\n}()
    this.WSH    && function(){\n#{ slurp \lib/wsh.js     }\n}()
    return Coco
    }.call(this))
  """
  {parser, uglify} = require \uglify-js
  ast = parser.parse co
  ast = uglify.ast_mangle  ast
  ast = uglify.ast_squeeze ast, {+extra}
  spit \extras/coco.js, """
    // Coco #{Coco.VERSION}
    // Copyright 2010, Jeremy Ashkenas + Satoshi Murakami
    // Released under the MIT License
    http://satyr.github.com/coco
    #{ uglify.gen_code ast };

  """
  invoke \test:browser


task \bench, 'quick benchmark of compilation time', ->
  Lexer    = require \./lib/lexer
  Rewriter = require \./lib/rewriter
  Coco     = require \./lib/coco
  co     = coreSources().map(-> slurp it).join \\n
  fmt    = -> "#{bold}#{ "   #{it}".slice -4 }#{reset} ms"
  total  = nc = 0
  now    = Date.now()
  time   = -> total += ms = -(now - now := Date.now()); fmt ms
  tokens = Lexer.lex co, {-rewrite}
  msg    = "Lex     #{time()} (#{tokens.length} tokens)\n"
  Rewriter.rewrite tokens
  msg   += "Rewrite #{time()} (#{tokens.length} tokens)\n"
  nodes  = Coco.nodes tokens
  msg   += "Parse   #{time()} (%s nodes)\n"
  js     = nodes.compileRoot {+bare}
  msg   += "Compile #{time()} (#{js.length} chars)\n" +
           "TOTAL   #{ fmt total }"
  nodes.traverseChildren (-> ++nc; void), true
  console.log msg, nc

task \loc, 'count the lines of source code in the Coco compiler', ->
  exec """
    cat #{ coreSources().join ' ' } | \\
    grep -v '^\\( *#\\|\\s*$\\)' | wc -l | tr -s ' '
  """, (err, out) -> say out.trim()


task \test 'run the Coco language test suite' ->
  runTests require \./lib/coco

task \test:browser
, 'run the test suite against the merged browser script' ->
  runTests new -> eval slurp \extras/coco.js \utf8

function runTests (Coco) ->
  startTime = Date.now()
  passedTests = failedTests = 0
  for name, func in require \assert then do ->
    global[name] = -> func ...; ++passedTests
  global import {
    Coco, eq: strictEqual, throws: (msg, fun) ->
      try do fun catch e then return eq e.message, msg
      ok false 'should throw: ' + msg
  }
  process.on \exit ->
    time = ((Date.now() - startTime) / 1e3).toFixed 2
    message = "passed #{passedTests} tests in #{time} seconds"
    say if failedTests
    then tint "failed #{failedTests} and #{message}", red
    else tint message
  dir(\test).forEach (file) ->
    return unless /\.co$/i.test file
    code = slurp filename = path.join \test file
    try Coco.run code, {filename}
    catch e
      ++failedTests
      return say e unless stk = e?.stack
      msg = '' + /^.+/.exec stk
      if m = /^(AssertionError:) "(.+)" (===) "(.+)"$/.exec msg
        m[i] = tint m[i].replace(/\\n/g \\n), bold for i of [2 4]
        msg  = m.slice(1).join \\n
      {1: row, 2: col} = ///#{filename}:(\d+):(\d+)\)?$///m.exec(stk) or ''
      say tint "failed #{filename}:#{row--}:#{col--}", red
      if row >= 0
        code = Coco.compile code
      else if /\bon line (\d+)\b/.test msg
        row = RegExp.$1 - 1
        col = 0
      else
        return say stk
      say msg
      {(row): line} = lines = code.split \\n
      say lines.slice(row-8, row+0).join \\n
      say line .slice(0 col) + tint line.slice(col), bold
      say lines.slice(row+1, row+9).join \\n
