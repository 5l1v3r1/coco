# Contains all of the node classes for the syntax tree. Most
# nodes are created as the result of actions in the [grammar](#grammar),
# but some are created by other nodes as a method of code generation. To convert
# the syntax tree into a string of JavaScript code, call `compileRoot`.

### Node
# The abstract base class for all nodes in the syntax tree.
# Each subclass implements the `compileNode` method, which performs the
# code generation for that node. To compile a node to JavaScript,
# call `compile` on it, which wraps `compileNode` in some generic extra smarts.
# An options hash is passed and cloned throughout, containing information about
# the environment from higher in the tree (such as if a returned value is
# being requested by the surrounding function), information about the current
# scope, and indentation level.
(Node = -> ...):: =
  compile: (options, level) ->
    o = {}; continue for key, o[key] in options
    o <<< {level} if level?
    node = @unfoldSoak o or this
    # If a statement appears within an expression, wrap it in a closure.
    return node.compileClosure o if o.level and node.isStatement()
    code = (node import tab: o.indent)compileNode o
    o.scope.free tmp for tmp of that if node.temps
    code

  compileClosure: (o) ->
    # A statement that _jumps_ out of current context (like `return`) can't be
    # an expression via closure-wrapping, as its meaning will change.
    that.carp 'inconvertible statement' if @jumps()
    fun = Fun [] Block this; call = Call(); hasThis = hasArgs = false
    @traverseChildren ->
      switch it.value
      case \this      then hasThis := true
      case \arguments then hasArgs := it.value = \_args
      void
    if hasThis
      call.args.push Literal \this
      call.method = \.call
    if hasArgs
      call.args.push Literal \arguments
      fun.params.push Var \_args
    # Flag the function as `wrapper` so that it shares a scope
    # with its parent to preserve the expected lexical scope.
    Parens(Chain fun<<<{+wrapper} [call]; true)compile o

  # Compiles a child node as a block statement.
  compileBlock: (o, node) ->
    if node?compile o, LEVEL_TOP then "{\n#{that}\n#{@tab}}" else '{}'

  # If the code generation wishes to use the result of a complex expression
  # in multiple places, ensure that the expression is only ever evaluated once,
  # by assigning it to a temporary variable.
  cache: (o, once, level) ->
    unless @isComplex()
      return [ref = if level? then @compile o, level else this, ref]
    sub = Assign ref = Var(o.scope.temporary \ref), this
    # Pass a `level` to precompile.
    if level?
      sub.=compile o, level
      o.scope.free ref.value if once
      return [sub, ref.value]
    # If flagged as `once`, the tempvar will be auto-freed.
    if once then [sub, ref <<< {+temp}] else [sub, ref, [ref.value]]

  # Compiles to a variable/source pair suitable for looping.
  compileLoopReference: (o, name, ret) ->
    if this instanceof Var and o.scope.check @value or
       this instanceof Literal or @op is \- and -1/0 < +@first.value < 1/0
      return [@compile o] * 2
    asn = Assign Var(tmp = o.scope.temporary name), this
    ret or asn.void = true
    [tmp; asn.compile o, if ret then LEVEL_CALL else LEVEL_PAREN]

  # Passes each child to a function, returning its return value if exists.
  eachChild: (fn) ->
    for name of @children then if child = @[name]
      if \length in child
      then return that if fn(node )? for node of child
      else return that if fn(child)?
    void

  # Performs `eachChild` on every descendant.
  # Overridden by __Fun__ not to cross scope by default.
  traverseChildren: (fn, xscope) ->
    @eachChild -> if fn(it)? then that else it.traverseChildren fn, xscope

  # Performs anaphoric conversion if a `that` is found within `@[@aTarget]`.
  anaphorize: ->
    @children = [@aTarget]
    if @eachChild hasThat
      if (base = this)[name = @aSource] instanceof Existence
        base.=[name]; name = \it
      unless base[name]value is \that
        base[name] = Assign Var(\that), base[name]
    function hasThat ->
      it.value is \that or if it.aSource
      then hasThat that if it[that]
      else it.eachChild hasThat
    delete @children
    void

  # Throw a syntax error, appending `@line` number to the message.
  carp: ->
    throw SyntaxError "#{it} on line #{ @line or @traverseChildren -> it.line }"

  # Default implementations of the common node properties and methods. Nodes
  # will override these with custom logic, if needed.
  children: []

  terminator: \;

  isComplex: YES

  isStatement  : NO
  isAssignable : NO
  isCallable   : NO
  isEmpty      : NO
  isString     : NO

  # Do I contain a statement that jumps out of me?
  jumps: NO
  # Do I assign a certain variable?
  assigns: NO
  # Do I hold a default value in an assignment context?
  hasDefault: NO

  unfoldSoak   : NO
  unfoldAssign : NO
  unwrap       : THIS
  maybeKey     : THIS
  varName      : String
  selections   : NO
  getCall      : NO

  invert: -> Op \! this

  # Constructs a node that returns the current node's result.
  makeReturn: (arref) ->
    if arref then Call.make JS(arref + \.push), [this] else Return this

  # Extra info for `toString`.
  show: String

  # String representation of the node for inspecting the parse tree.
  # This is what `coco --ast` prints out.
  toString: (idt or '') ->
    tree = \\n + idt + @..displayName
    tree += ' ' + that if @show()
    @eachChild -> tree += it.toString idt + TAB; void
    tree

  # JSON serialization
  stringify : (space) -> JSON.stringify this, null space
  toJSON    : -> {type: @..displayName, ...this}

# JSON deserialization
exports.parse    = (json) -> exports.fromJSON JSON.parse json
exports.fromJSON = function ->
  return it unless it and typeof it is \object
  if it.type
    node = exports[that]::{}
    node[key] = fromJSON val for key, val in it
    return node
  if it.length? then fromJSON v for v of it else it

#### Modules

Negatable =
  show   : -> @negated and \!
  invert : -> @negated ^= 1; this

#### Block
# A list of expressions that forms the body of an indented block of code.
class exports.Block extends Node
  (node) ~>
    return node if node instanceof Block
    @lines = []
    @add node if node

  children: [\lines]

  add: ->
    if @back
      that.add it
    else if it.lines
      @lines.push ...that
    else
      @lines.push it
      @back = that if it.back
    this

  unwrap: -> if @lines.length is 1 then @lines.0 else this

  isComplex: -> @lines.length > 1 or @lines.0?isComplex()

  isCallable: -> that.isCallable() if lastNonComment(@lines)0

  jumps: -> return that if node.jumps it for node of @lines

  # **Block** does not return its entire body, rather it
  # ensures that the final line is returned.
  makeReturn: ->
    [node, i] = lastNonComment @lines
    if node
      @lines[i] = node.=makeReturn it
      @lines.splice i, 1 if node instanceof Return and not node.it
    this

  compile: (o, level ? o.level) ->
    unless level then o.block = this; tab = o.indent
    codes = for node of @lines
      if level
        continue if node.comment
        code = node.compile o, LEVEL_LIST
      else
        node = node.unfoldSoak o or node
        code = tab + (node <<< {+front})compile o, level
        code += node.terminator unless node.isStatement()
      code
    return codes.join \\n unless level
    code = codes.join ', ' or 'void 8'
    if codes.length > 1 and level >= LEVEL_LIST then "(#{code})" else code

  # **Block** is the only node that can serve as the root.
  compileRoot: (options) ->
    o = {level: LEVEL_TOP, scope: @scope = Scope.root = new Scope, ...options}
    delete o.filename
    o.indent = if bare = delete o.bare then '' else TAB
    prefix = @lines.shift()code if /^(?:#!|javascript:)/test @lines.0?code
    if delete o.repl
      if bare
        [node, i] = lastNonComment @lines
        @lines[i] = Parens node if node
      else
        @makeReturn()
    code = @compileWithDeclarations o
    # Wrap everything in a safety closure unless requested not to.
    bare or code = "(function(){\n#{code}\n}).call(this);\n"
    if prefix then prefix + \\n + code else code

  # Compile the expressions body for the contents of a function, with
  # declarations of all inner variables pushed up to the top.
  compileWithDeclarations: (o) ->
    o.level = LEVEL_TOP
    code = ''
    break unless node.comment or node instanceof Literal for node, i of @lines
    if i
      rest   = @lines.splice i, 9e9
      code   = @compile o
      @lines = rest
    code &&+= \\n if post = @compile o
    code += o.indent + that + \;\n if @scope?vars o
    code + post

#### Atom
# An abstract node for simple values.
class Atom extends Node
  show      : -> @value
  isComplex : NO

#### Literal
# `this`, `debugger`, and primitives.
class exports.Literal extends Atom
  (@value) ~> return JS "#{value}" true if value.js

  isEmpty    : -> switch @value case <[ void null ]> then true
  isCallable : -> switch @value case <[ this eval ]> then true
  isString   : -> 0 <= '\'"'indexOf "#{@value}"charAt()

  varName: -> if /^\w+$/test @value then \$ + @value else ''

  compile: (o, level ? o.level) ->
    switch val = "#{@value}"
    case \this     then return o.scope.fun?bound or val
    case \void     then val += ' 8'; fallthrough
    case \null     then @carp 'invalid use of ' + @value if level is LEVEL_CALL
    case \*        then return \0
    case \debugger then if level
      return "(function(){\n#{ o.indent + TAB }debugger;\n#{o.indent}}())"
    val

#### Var
# Variables.
class exports.Var extends Atom
  (@value) ~>

  isAssignable : YES
  isCallable   : YES

  assigns: -> it is @value

  maybeKey: -> Key(@value) <<< {@line}

  varName: ::show

  compile: (o) -> if @temp then o.scope.free @value else @value

#### Key
# The name of a property, in the form of `{key: _}` or `_.key`.
class exports.Key extends Atom
  (name, @reserved or name.reserved) ~> @name = '' + name

  isAssignable: -> not @reserved

  assigns: -> it is @name

  varName: ->
    {name} = this
    (if @reserved or name of <[ arguments eval ]> then \$ else '') + name

  compile: ::show = -> if @reserved then "'#{@name}'" else @name

#### Index
# Dots and brackets to access an object's property.
class exports.Index extends Node
  (@key, symbol or \.) ~>
    switch key.length
    case 0 then @key = Key \__proto__
    case 1 then @key = key.0
    if \? is symbol.charAt 0
      @soak = \?
      symbol.=slice 1
    switch symbol.slice -1
    case \= then @assign = symbol.slice 1
    case \! then @vivify = Obj
    case \@ then @vivify = Arr
    @<<<{symbol}

  children: [\key]

  show: -> (@soak or '') + @symbol

  isComplex: -> @key.isComplex()

  compile: (o) ->
    code = @key.compile o, LEVEL_PAREN
    if @key instanceof Key and \' is not code.charAt 0
    then ".#{code}" else "[#{code}]"

#### Chain
# Acts as a container for property-access/function-call chains, by holding
# __Index__ or __Call__ instances as `@tails`.
class exports.Chain extends Node
  (head, tails) ~>
    return head if not tails and head instanceof Chain
    @<<<{head, tails or []}

  children: <[ head tails ]>

  add: ->
    @tails.push it
    if delete it.vivify
      @head  = Assign Chain(@head, @tails), that(), \= \||
      @tails = []
    this

  # __Chain__ can be unwrapped as its inner node, if there are no subnodes.
  unwrap: -> if @tails.length then this else @head

  jumps        : -> not @tails.length and @head.jumps it
  assigns      : -> not @tails.length and @head.assigns it
  isStatement  : -> not @tails.length and @head.isStatement()
  isComplex    : -> @tails.length or do @head.isComplex
  isCallable   : -> @tails.length or do @head.isCallable
  isAssignable : ->
    if @tails[*-1]
    then that instanceof Index
    else @head.isAssignable

  makeReturn: -> if @tails.length then super ... else @head.makeReturn it

  getCall: -> (tail = @tails[*-1]) instanceof Call and tail

  varName: -> @tails[*-1]?key?varName()

  # A reference has base part (`this` value) and name part.
  # We cache them separately for compiling complex expressions, so that e.g.
  #
  #     a()[b()] ||= c
  #
  # compiles to
  #
  #     (_ref = a())[_key = b()] || (_ref[_key] = c);
  #
  cacheReference: (o) ->
    name = @tails[*-1]
    # `a.b()`
    return @cache o, true if name instanceof Call
    # `a` `a.b`
    if @tails.length < 2 and not @head.isComplex() and not name?isComplex()
      return [this] * 2
    base = Chain @head, @tails.slice 0 -1
    # `a().b`
    if base.isComplex()
      ref  = o.scope.temporary \ref
      base = Chain Assign Var(ref), base
      bref = Var(ref) <<< {+temp}
    # `a{}`
    return [base, bref] unless name
    # `a[b()]`
    if name.isComplex()
      ref  = o.scope.temporary \key
      name = Index Assign Var(ref), name.key
      nref = Index Var(ref) <<< {+temp}
    [base.add name; Chain bref || base.head, [nref or name]]

  compileNode: (o) ->
    @head <<< {@front, @newed}
    return @head.compile o unless @tails.length
    return that .compile o if @unfoldAssign o
    if @tails.0 instanceof Call and not @head.isCallable()
      @carp 'invalid callee'
    @expandArray o; @expandBind o; @expandSplat o; @expandStar o
    base = @head.compile o, LEVEL_CALL; rest = ''
    for t of @tails
      base = 'new ' + base if t.new
      rest += t.compile o
    base += ' ' if \. is rest.charAt 0 and SIMPLENUM.test base
    base + rest

  # Unfolds a soak into an __If__: `a?.b` => `a.b if a?`
  unfoldSoak: (o) ->
    if @head.unfoldSoak o
      that.then.tails.push ...@tails
      return that
    for node, i of @tails then if node.soak
      node.soak = ''
      return if node instanceof Call
        [test, @head] = Chain(@head, @tails.splice 0 i)cacheReference o
        If do
          JS "typeof #{ test.compile o, LEVEL_OP } == 'function'"
          this, {+soak}
      else
        [test, @head] = Chain(@head, @tails.splice 0 i)unwrap()cache o, true
        If Existence(test), this, {+soak}
    void

  unfoldAssign: (o) ->
    if @head.unfoldAssign o
      that.right.tails.push ...@tails
      return that
    for index, i of @tails then if index.assign
      index.assign = ''
      [left, @head] = Chain(@head, @tails.splice 0 i)cacheReference o
      return Assign(left, this, that) <<< {+access}
    void

  expandSplat: (o) ->
    {tails} = this; i = -1; while call = tails[++i]
      {thisplat, args} = call
      continue unless thisplat or args &&= Splat.compileArray o, args, true
      @carp 'splatting "new"' if call.new
      call.method = \.apply
      if thisplat
        delete call.thisplat
        continue
      if tails[i-1] instanceof Index
        [@head, ref] = Chain(@head, tails.splice 0 i-1)cache o, true
        i = 0
      call.args = [ref or Literal(\null), JS args]
    void

  expandBind: (o) ->
    {tails} = this; i = -1; while tails[++i]
      continue unless that.symbol is \.~
      that.symbol = ''
      args   = Chain(@head, tails.splice 0 i)unwrap()cache o, true
      args.1 = Chain args.1, [tails.shift()]
      call   = Call.make Util(\bind), args
      @head  = if @newed then Parens call, true else call
      i = -1
    void

  expandStar: (o) ->
    {tails} = this; i = -1; while tails[++i]
      continue if that.args or that.stars or that.key instanceof Key
      stars = that.stars = []
      that.eachChild seek
      continue unless stars.length
      [sub, ref, temps] = Chain(@head, tails.splice 0 i)unwrap()cache o
      ref += ' ' if SIMPLENUM.test ref.=compile o
      star.value = ref + \.length for star of stars
      @head = JS sub.compile(o, LEVEL_CALL) + tails.shift()compile o
      o.scope.free temps.0 if temps
      i = -1
    function seek ->
      if it.value is \*               then stars.push it
      else unless it instanceof Index then it.eachChild seek
      void
    void

  expandArray: (o) ->
    {tails} = this; i = -1; while tails[++i] then if that.key?length
      [sub, ref, temps] = Chain(@head, tails.splice 0 i)unwrap()cache o
      items = for key, j of tails.shift()key
        Chain if j then ref else sub, [Index key]
      @head = JS Arr(items)compile o
      o.scope.free temps.0 if temps
      i = -1
    void

#### Call
# `x(y)`
class exports.Call extends Node
  (args or [], sym) ~>
    if args.length is 1 and args.0 instanceof Splat and args.0.it.isEmpty()
      @thisplat = true; args = [Literal \this; Literal \arguments]
    @<<<{args, soak: sym is \?( and \?}

  children: [\args]

  show: -> (@new or '') + (@soak or '') + (@thisplat or '')

  compile: (o) ->
    code  = (@method or '') + \(
    code += (if i then ', ' else '')+ a.compile o, LEVEL_LIST for a, i of @args
    code + \)

  @make = (callee, args) -> Chain(callee)add Call args

  @block = (fun, args, method) ->
    Parens(Chain fun, [Call(args) <<< {method}]) <<< {+calling}

  @back = (params, arrow, node) ->
    (call = node.getCall()) or node = Chain(node)add call = Call()
    {args} = call
    break if a instanceof Splat and a.it.isEmpty() for a, i of args
    node import back: (args[i] = Fun params, null, arrow.charAt(1) + \>)body

  @let = (fun) ->
    args = fun.params; ps = fun.params = []
    for a, i of args then ps.push do
      if a.op is \= and not a.logic
      then args[i] = a.right; a.left
      else if a.varName()
      then Var that
      else a.carp 'invalid "let" argument'
    @block fun, args, delete fun.bound && (args.unshift Literal \this; \.call)

#### Clone
# An operation that creates a new object with its `__proto__`
# set to the operand, attaching specified properties.
class exports.Clone extends Node
  (@base, @mixins) ~>

  children: <[ base mixins ]>

  unfoldSoak: -> If.unfoldSoak it, this, \base

  compileNode: (o) ->
    Import(Call.make(Util \clone; [@base]), Obj @mixins)compile o

#### List
# An abstract node for a list of comma-separated items.
class List extends Node
  children : [\items]
  isEmpty  : -> not @items.length
  assigns  : -> return true if node.assigns it for node of @items

  @compile = (o, items) ->
    switch items.length
    case 0 then return ''
    case 1 then return items.0.compile o, LEVEL_LIST
    {indent, level} = o
    o <<< indent: indent + TAB, level: LEVEL_LIST
    code  = items[i = 0]compile o
    code += ', ' + that.compile o while items[++i]
    code  = "\n#{o.indent}#{code}\n#{indent}" if ~code.indexOf \\n
    o <<< {indent, level}
    code

#### Obj
# `{x: y}`
class exports.Obj extends List
  (@items or []) ~>

  asObj: THIS

  compileNode: (o) ->
    {items} = this
    return (if @front then '({})' else '{}') unless items.length
    code = ''; idt = \\n + o.indent += TAB; dic = {}
    for node, i of items
      if node.comment
        code += idt + node.compile o
        continue
      node.=first if logic = node.hasDefault()
      if node instanceof Splat or (node.key or node) instanceof Parens
        rest = items.slice i
        break
      if multi then code += \, else multi = true
      code += idt + if node instanceof Prop
        {key, val} = node
        if node.accessor
          key = "#{ if val.params.length then \set else \get } \
                 #{ key.compile o }"
          key + val.compile(o, LEVEL_LIST)slice 8
        else
          val.name = key.varName() if val instanceof [Fun, Class]
          "#{ key.=compile o }: #{ val.compile o, LEVEL_LIST }"
      else
        "#{ key = node.compile o }: #{key}"
      dic[0+key] = 0+key in dic and
        node.carp "duplicate property name \"#{key}\""
      logic and code += """ #{
        if logic.op is \? then "!= null ? #{key} :" else logic.op
      } """ + logic.second.compile o, LEVEL_OP
    code = "{#{ code and code + \\n + @tab }}"
    if rest
    then Import(JS code; Obj rest)compile o <<< indent: @tab
    else if @front then "(#{code})" else code

#### Prop
# `x: y`
class exports.Prop extends Node
  (@key, @val) ~>
    if val.op is \~ and val.first.params?length < 2
      @<<<{\accessor val: val.first}

  children: <[ key val ]>

  show: -> @accessor

  assigns: -> @val.assigns it

#### Arr
# `[x, y]`
class exports.Arr extends List
  (@items or []) ~>

  selections: -> @items.length > 1 and @items

  asObj: -> Obj(Prop Literal(i), item for item, i of @items)

  compile: (o) ->
    {items} = this
    return '[]' unless items.length
    if code = Splat.compileArray o, items
      return if @newed then "(#{code})" else code
    "[#{ List.compile o, items }]"

  @maybe = (nodes) ->
    return nodes.0 if nodes.length is 1 and nodes.0 not instanceof Splat
    this nodes

#### Op
# Simple arithmetic and logical operations, with some special conversions.
class exports.Op extends Node
  (op, first, second, post) ~>
    switch op
    case \of then return new Of first, second
    case \do
      return if first instanceof Fun
      then Call.block first
      else Parens Call.make first
    case \new
      first.newed = true
      if (chain = first.base or first) instanceof Chain
        chain.=head.base while chain.head.base instanceof Chain
        for node of chain.tails then if node instanceof Call
          node <<< {\new}
          return first
    @<<<{op, first, second, post}

  children: <[ first second ]>

  show: -> @op

  isCallable: -> switch @op case <[ && || ? new delete ]>
    @first.isCallable() or @second?isCallable()

  EQUALITY = /^[!=]==?$/
  COMPARER = /^(?:[!=]=|[<>])=?$/

  invert: ->
    if EQUALITY.test op = @op and not COMPARER.test @second.op
      @op = '!='charAt(op.indexOf \=) + op.slice 1
      return this
    return Op \! Parens this if @second
    return @first if op is \! and @first.op of <[ ! in instanceof < > <= >= ]>
    Op \! this

  unfoldSoak: (o) ->
    @op of <[ ++ -- delete ]> and If.unfoldSoak o, this, \first

  hasDefault: -> switch @op case <[ ? || && ]> then this

  compileNode: (o) ->
    return @compileUnary o unless @second
    switch @op
    case \?          then return @compileExistence o
    case \instanceof then return @compileIOS o, that if @second.selections()
    case \*
      return @compileRepeat o if @first.isString() or @first instanceof Arr
    default
      return @compileChain  o if COMPARER.test @op and COMPARER.test @second.op
    @first <<< {@front}
    code = "#{ @first .compile o, level = LEVEL_OP + PREC[@op] } #{@op} \
            #{ @second.compile o, level }"
    if o.level <= level then code else "(#{code})"

  # Mimic Python's chained comparisons when multiple comparison operators are
  # used sequentially. e.g.:
  #
  #     $ coco -e '50 < 65 === 9r72 > 10'
  #     true
  #
  # See <http://docs.python.org/reference/expressions.html#notin>.
  compileChain: (o) ->
    code = @first.compile o, level = LEVEL_OP + PREC[@op]
    [sub, @second.first] = @second.first.cache o, true
    code += " #{@op} #{ sub    .compile o, level    } && \
                     #{ @second.compile o, LEVEL_OP }"
    if o.level <= LEVEL_OP then code else "(#{code})"

  compileExistence: (o) ->
    if o.level
      fsts = @first.cache o, true
      return If(Existence fsts.0; fsts.1)addElse(@second)compileExpression o
    Op(\&& Existence(@first)invert(), @second)compileNode o

  compileUnary: (o) ->
    {op, first} = this
    switch op
    case \delete
      @carp 'invalid deletion' if first instanceof Var or !first.isAssignable()
      return @compileDelete o if o.level
    case <[ ++ -- ]>
      if first instanceof Var and not o.scope.check first.value, true
        @carp "modification of undeclared variable \"#{first.value}\""
      first{front} = this if @post
    case \classof
      return "#{ utility \toString }.call(
              #{ first.compile o, LEVEL_LIST }).slice(8, -1)"
    first.carp 'invalid constructor' if op is \new and not first.isCallable()
    code = first.compile o, LEVEL_OP + PREC.unary
    if @post
      code += op
    else
      op += ' ' if op of <[ new typeof delete ]> or
                   op of <[ + - ]> and first.op is op
      code = op + code
    if o.level < LEVEL_CALL then code else "(#{code})"

  # `x instanceof [A, B]`
  compileIOS: (o, items) ->
    code = ''; [sub, ref] = @first.cache o, false level = LEVEL_OP + PREC\<
    for item, i of items
      code += "#{ if i then ' || ' + ref else sub } instanceof \
               #{ item.compile o, level }"
    sub is ref or o.scope.free ref
    if o.level <= LEVEL_OP then code else "(#{code})"

  # `v = delete o.k`
  compileDelete: (o) ->
    [get, del] = Chain(@first)cacheReference o
    code = if @assigned then '' else "#{ ref = o.scope.temporary \ref } = "
    code += "#{ get.compile o, LEVEL_LIST }
    , delete #{ del.compile o, LEVEL_LIST }"
    return code if @assigned
    code += ", #{ o.scope.free ref }"
    if o.level < LEVEL_LIST then code else "(#{code})"

  compileRepeat: (o) ->
    {first: x, second: n} = this; {items} = x
    if (x = JS that if items and Splat.compileArray o, items) or
       not (n instanceof Literal and n.value < 0x20)
      x = Call.make Util(\repeat + if items then \Array else \String), [x, n]
      return x.compile o
    n = +n.value
    return x.compile o if 1 <= n < 2
    # `[x] * 2` => `[x, x]`
    if items
      if n < 1 then return Block::{lines: items}add(JS '[]')compile o
      refs = []
      [items[i], refs.*] = item.cache o, 1x for item, i of items
      items.push JS() <<<
        compile: -> (", #{ List.compile o, refs }" * (n-1))slice 2
      x.compile o
    # `'x' * 2` => `'xx'`
    else if x instanceof Literal
      (q = (x.=compile o)charAt()) + "#{ x.slice 1 -1 }" * n + q
    # `"#{x}" * 2` => `(_ref = "" + x) + _ref`
    else
      if n < 1 then return Block(x.it)add(JS "''")compile o
      x = (refs = x.cache o, 1, LEVEL_OP)0 + " + #{refs.1}" * (n-1)
      if o.level < LEVEL_OP + PREC\+ then x else "(#{x})"

#### Assign
# Assignment to a variable/property.
class exports.Assign extends Node
  (@left, @right, @op or \=, @logic or @op.logic) ~> @op += ''

  children: <[ left right ]>

  show: -> (@logic or '') + @op

  assigns: -> @left.assigns it

  isCallable: -> switch @op case <[ = := ]> then @right.isCallable()

  unfoldSoak: (o) -> If.unfoldSoak o, this, \left

  unfoldAssign: -> @access and this

  compileNode: (o) ->
    {right} = this; left = @transleft(o)unwrap()
    return (Parens(right) <<< {@front, @newed})compile o if left.isEmpty()
    return @compileDestructuring o, left if left.items
    return @compileConditional   o, left if @logic
    if left.hasDefault()
      right = Op left.op, right, left.second
      left.=first
    left.isAssignable() or left.carp \
      "#{ left.compile o, LEVEL_LIST } // invalid assignee"
    right.=it if right instanceof Parens and not right.keep
    # Peek names for `class` and/or `super`.
    if right instanceof [Fun, Class]
      {head, tails} = left
      # `clas::name = ->` or `name = ->`
      right.name ||= if tails then tails[*-1]?key.compile o else left.value
      right.clas ||= head instanceof Var and tails.length is 2 and
                     tails.0.key?name is \prototype and head.value
    decl = left instanceof Var
    sign = @op.replace \: ''
    name = (left <<< {+front})compile o, LEVEL_LIST
    code = if decl and not o.level and right instanceof While
      # Optimize `a = while ...`.
      """#{ res = o.scope.temporary \_results } = [];
         #{@tab}#{ right.makeReturn(res)compile o }
         #{@tab}#{name} #{sign} #{ o.scope.free res }"""
    else
      "#{name} #{sign} " + (right <<< {+assigned})compile o, LEVEL_LIST
    if decl
      del = right.op is \delete
      if @op is \=
        o.scope.declare name
      else unless o.scope.check name, true
        left.carp "assignment to undeclared variable \"#{name}\""
    if o.level
      code += ", #{name}" if del
      code  = "(#{code})" if that > (if del then LEVEL_PAREN else LEVEL_LIST)
    code

  compileConditional: (o, left) ->
    lefts = Chain(left)cacheReference o
    Op(@logic, lefts.0, @<<<{left: lefts.1, -logic})compileNode o

  # Implementation of recursive destructuring,
  # when assigning to an array or object literal.
  # See <http://wiki.ecmascript.org/doku.php?id=harmony:destructuring>.
  compileDestructuring: (o, left) ->
    {items} = left; len = items.length; ret = o.level and not @void
    rite = @right.compile o, if len is 1 then LEVEL_CALL else LEVEL_LIST
    if (ret or len > 1) and (not ID.test rite or left.assigns rite)
      cache = "#{ rref = o.scope.temporary \ref } = #{rite}"
      rite  = rref
    list = @"rend#{ left..displayName }" o, items, rite
    o.scope.free rref  if rref
    list.unshift cache if cache
    list.push rite     if ret or not list.length
    code = list.join ', '
    if list.length < 2 or o.level < LEVEL_LIST then code else "(#{code})"

  rendArr: (o, nodes, rite) ->
    for node, i of nodes
      continue if node.isEmpty()
      if node instanceof Splat
        node.carp 'multiple splat in an assignment' if ivar
        len = nodes.length; empty = (node.=it)isEmpty()
        if i is len - 1
          break if empty
          val = utility(\slice) + \.call( + rite + if i then ", #{i})" else \)
        else
          val = "#{rite}.length - #{ len - i - 1 }"
          # Optimize `[..., a] = b`.
          if empty and i is len - 2
            ivar = val
            continue
          start = i + 1; @temps = [ivar = o.scope.temporary \i]
          if empty then node = Var ivar else val = "
            #{len} <= #{rite}.length \
            ? #{ utility \slice }.call(#{rite}, #{i}, #{ivar} = #{val}) \
            : (#{ivar} = #{i}, [])"
        val = Var val
      else
        if (inc = ivar) and start < i then inc += " + #{ i - start }"
        val = Chain rcache||=Literal(rite), [Index JS inc || i]
      @{left: node, right: val, +\void}compile o, LEVEL_PAREN

  rendObj: (o, nodes, rite) ->
    for node of nodes
      node.=it if splat = node instanceof Splat
      # `{a or b} = c` => `a = c.a or b`
      node.=first if logic = node.hasDefault()
      if node instanceof Parens
        [node, key] = Chain(node.it)cacheReference o
      else if node instanceof Prop
      then node = ({key} = node)val
      else key  = node
      node = Var node.name if node instanceof Key
      node = logic <<< {first: node} if logic
      val  = Chain lr ||= Var(rite), [Index key.maybeKey()]
      val  = Import Obj(), val if splat
      @{left: node, right: val, +\void}compile o, LEVEL_PAREN

  # Resolves subdestructuring.
  transleft: (o) ->
    {left} = this
    # `x{k} = o` => `{k: x.k} = o`
    if left instanceof Clone
      {base, mixins: items} = left
      if items.length > 1
      then [sub, ref, @temps] = base.cache o
      else sub = ref = base
      for node, i of items
        base = if i then ref else sub
        if node instanceof Prop
          node.val = rechain base, node.val
        else
          # `o{k or v} = ..` => `{k: a.k or v} = ..`
          node.=first if logic = node.hasDefault()
          if node instanceof Parens
          # `a{(++i)} = b` => `{(_ref): a[_ref = ++i]} = b`
          then [node, key] = node.cache o, true; key = Parens key
          else key = node
          val = Chain base, [Index node.maybeKey()]
          val = logic <<< {first: val} if logic
          items[i] = Prop key, val
      return Obj items
    # `x[k] = a` => `[x[k]] = a`
    if left instanceof Chain and
       (tail = left.tails[*-1]) instanceof Index and tail.key.length
      items = left.tails.pop()key; [sub, ref, @temps] = left.cache o
      for item, i of items
        item.=it if splat = item instanceof Splat
        item = rechain if i then ref else sub, item
        items[i] = if splat then Splat item else item
      return Arr items
    left

  # `o` + `{x}` => `o{x}`
  function rechain(head, tail) ->
    return tail if tail.isEmpty()
    if tail instanceof Obj
    then Clone head, tail.items
    else Chain head, [Index::{key: tail.items || tail.maybeKey()}]

#### Import
# Copies properties from right to left.
class exports.Import extends Node
  (@left, @right, @all and \All) ~>
    if not all and left instanceof Obj and right.items
      return Obj left.items.concat right.asObj()items

  children: <[ left right ]>

  show: -> @all

  isCallable: -> @left.isCallable()

  compileNode: (o) ->
    if @all or not @right.items
      return Call.make Util("import#{ @all or '' }"), [@left, @right]
             .compileNode o
    {items} = @right.asObj()
    return @left.compile o unless items.length
    top = not o.level
    if items.length < 2 and (top or items.0 instanceof Splat)
    then sub = lref = @left
    else [sub, lref, @temps] = @left.cache o
    [delim, space] = if top then [\; \\n + @tab] else [\, ' ']
    delim += space
    code = ''
    for node of items
      code += if com then space else delim
      if com = node.comment
        code += node.compile o
        continue
      if node instanceof Splat
        code += Import(lref, node.it)compile o
        continue
      node.=first if logic = node.hasDefault()
      if dyna = node instanceof Parens
        [key, val] = node.it.cache o, true
      else if node instanceof Prop
        {key, val} = node
        if node.accessor
          key = if key instanceof Key
          then "'#{key.name}'"
          else key.compile o, LEVEL_LIST
          code += "#{ lref.compile o }
            .__define#{ if val.params.length then \S else \G }etter__
            (#{key}, #{ val.compile o, LEVEL_LIST })"
          continue
      else
        key = val = node
      dyna or key.=maybeKey()
      val = logic <<< {first: val} if logic
      code += Assign(Chain lref, [Index key]; val)compile o, LEVEL_PAREN
    if sub is lref
    then code.=slice delim.length
    else code = sub.compile(o, LEVEL_PAREN) + code
    return code if top
    node instanceof Splat or
      code += (if com then ' ' else ', ') + lref.compile o, LEVEL_LIST
    if o.level < LEVEL_LIST then code else "(#{code})"

#### Of
# Handles `of` operation that tests if the left operand is included within
# the right operand, arraywise.
class exports.Of extends Node
  (@item, @array) ->

  children: <[ item array ]>

  ::<<<< Negatable

  compileNode: (o) ->
    items = @array.selections()
    level = if items then LEVEL_OP + PREC\== else LEVEL_LIST
    [sub, ref] = @item.cache o, false level
    if items
      code = ''
      [cmp, cnj] = if @negated then [' !== ' ' && '] else [' === ' ' || ']
      for item, i of items
        code += (if i then cnj + ref else sub) + cmp + item.compile o, level
      level = LEVEL_OP + PREC\||
    else
      code = "#{ utility \indexOf }.call(#{ @array.compile o, level }, #{ref}
            ) #{ if @negated then \< else \>= } 0"
      return code if sub is ref
      code = sub + ', ' + code
    o.scope.free ref unless sub is ref
    if o.level < level then code else "(#{code})"

#### Existence
# Checks a value for existence--not `undefined` nor `null`.
class exports.Existence extends Node
  (@it) ~>

  children: [\it]

  ::<<<< Negatable

  compileNode: (o) ->
    node = @it.unwrap()
    code = node.compile o, LEVEL_OP + PREC\==
    if node instanceof Var and not o.scope.check code, true
      [op, eq] = if @negated then <[ || = ]> else <[ && ! ]>
      code = "typeof #{code} #{eq}= 'undefined' #{op} #{code} #{eq}== null"
    else
      code += " #{ op = if @negated then \== else \!= } null"
    if o.level < LEVEL_OP + PREC[op] then code else "(#{code})"

#### Fun
# A function definition. This is the only node that creates a `new Scope`.
class exports.Fun extends Node
  (@params or [], @body or Block(), arrow) ~> @bound = \_this if arrow is \~>

  children: <[ params body ]>

  show: -> @bound

  named: -> @<<<{name: it, +statement}

  isCallable: YES

  isStatement: -> !!@statement

  # Short-circuit `traverseChildren` method to prevent it
  # from crossing scope boundaries by default.
  traverseChildren: ([] xscope) -> super ... if xscope

  makeReturn: -> if @statement then @<<<{+returns} else super ...

  compileNode: (o) ->
    pscope = o.scope
    sscope = pscope.shared or pscope
    scope  = o.scope = @body.scope =
      new Scope (if @wrapper then pscope else sscope), @wrapper && sscope
    scope.fun = this
    delete o.globals
    scope.assign \prototype @proto.compile(o) + \.prototype if @proto
    o.indent = @tab = '' if @plucked
    o.indent += TAB
    {params, body, name, tab} = this
    code = \function
    if @bound is \_this
      if @ctor
        scope.assign \_this 'new _ctor'
        code += """
           _ctor(){} _ctor.prototype = prototype;
          #{tab}function
        """
        body.add Return Literal \_this
      else if sscope.fun?bound
      then @bound = that
      else sscope.assign \_this \this
    {lines} = body; wasEmpty = not lines.length; args = []; asns = []
    for p, i of params
      if p instanceof Splat then splat = p
      # `(a = x) ->` => `(a ? x) ->`
      else if p.op is \= and not p.logic
        params[i] = Op \? p.left, p.right
    if splat
      # `(a, ...b) ->` => `-> [a, ...b] = @@`
      if params.1 or not splat.it.isEmpty()
        asns.push Assign Arr(params), Literal \arguments
    else
      unless params.length or @wrapper
        params.0 = Var \it if body.traverseChildren(-> it.value is \it or null)
      dic = {}
      for p of params
        arg = p
        arg.=first if dfv = arg.hasDefault()
        if arg.isEmpty()
          arg = Var scope.temporary \arg
        else if arg not instanceof Var
          ref = Var arg.varName() || scope.temporary \arg
          asns.push Assign arg, if dfv then Op p.op, ref, p.second else ref
          arg = ref
        else if dfv
          asns.push Assign arg, p.second, \=, p.op
        args.push a = scope.add arg.value, \arg
        arg.carp "duplicate formal argument \"#{a}\"" if dic[0+a] = 0+a in dic
    lines.unshift ...asns if asns.length
    body.makeReturn() unless wasEmpty or @ctor or @void
    if @statement
      name                    or @carp  'nameless function declaration'
      pscope is o.block.scope or @carp 'misplaced function declaration'
      scope .add name, \function
      pscope.add name, \function unless @returns
      code += ' ' + name
    code += "(#{ args.join ', ' }){"
    code += "\n#{ body.compileWithDeclarations o }\n#{tab}" if lines.length
    code += \}
    return sscope.assign sscope.temporary(\fn), code if @plucked
    if @ctor and \_ is not name.charAt 0
      code += " #{name}.displayName = '#{name}';"
    code += "\n#{tab}return #{name};" if @returns
    if @front and not @statement then "(#{code})" else code

#### Class
class exports.Class extends Node
  (@title, @sup, body) -> @fun = Fun [] body

  children: <[ title sup fun ]>

  isCallable: YES

  compile: (o, level) ->
    {fun, title} = this; {lines} = fun.body
    decl  = title?varName()
    name  = decl or @name
    name  = \_Class unless name and ID.test name
    vname = Var fun.bound = name
    proto = null
    fun.body.traverseChildren ->
      if   it.value is \prototype then proto  := vname
      else it instanceof Fun      then it.clas = name
      void
    for node, i of lines
      if node instanceof Obj
        lines[i] = Import Var(\prototype), node
        proto = vname
      else if node instanceof Fun and not node.statement
        ctor and node.carp 'redundant constructor'
        (ctor = node)bound and proto = vname
    ctor or lines.unshift ctor = Fun()
    ctor <<< {name, +ctor, +statement, -clas}
    lines.push vname
    if @sup
      args  = [@sup]
      proto = Util.Extends vname, fun.params.* = Var \_super
    clas = Parens Call.make(fun<<<{proto} args), true
    clas = Assign vname, clas if decl and title.isComplex()
    clas = Assign title, clas if title
    clas.compile o, level

#### Super
# Reference to the parent method or constructor.
class exports.Super extends Node
  isAssignable : YES
  isCallable   : YES

  compile: (o) ->
    {fun or @carp 'stray "super"'} = o.scope.shared or o.scope
    if name = fun.name
      if fun.clas
        return that + \.superclass.prototype +
               if ID.test name then \. + name else \[ + name + \]
      else if fun.ctor or fun.statement
        return name + \.superclass
    return \_super if o.scope.check \_super
    @carp '"super" in a nameless function'

#### Parens
# An extra set of parentheses,
# specifying evaluation order and/or forcing expression.
class exports.Parens extends Node
  (@it, @keep, @string) ~>

  children: [\it]

  show: -> @string and '""'

  isComplex  : -> @it.isComplex  ()
  isCallable : -> @it.isCallable ()
  isString   : -> @string

  compile: (o, level ? o.level) ->
    {it} = this
    unless @keep or @newed
      if it instanceof [Atom, Chain, Fun, Parens, List] or
         it instanceof Op and level < LEVEL_OP + (PREC[it.op] or PREC.unary)
        it.head.void = true if not level and @calling
        return (it <<< {@front})compile o, Math.max level, LEVEL_PAREN
    if it.isStatement()
    then it.compileClosure o
    else "(#{ it.compile o, LEVEL_PAREN })"

#### Splat
# A splat, either as an argument to a call
# or as part of a destructuring assignment.
class exports.Splat extends Node
  (@it) ~>

  ::{children, isComplex} = Parens::

  isAssignable: YES

  assigns: -> @it.assigns it

  compile: -> @carp 'invalid splat'

  # Compiles a list of nodes mixed with splats to a proper array.
  @compileArray = (o, list, apply) ->
    break if node instanceof Splat for node, index of list
    return '' if index >= list.length
    unless list.1
      return (if apply then Object else ensureArray) list.0.it
             .compile o, LEVEL_LIST
    args = []; atoms = []
    for node of list.splice index, 9e9
      if node instanceof Splat
        atoms.length &&= !args.push Arr atoms
        args.push ensureArray node.it
      else atoms.push node
    args.push Arr atoms if atoms.length
    (if index then Arr list else args.shift())compile(o, LEVEL_CALL) +
    ".concat(#{ List.compile o, args })"

  function ensureArray(node) ->
    node.=it while node instanceof Parens
    node.=unwrap()
    return node if node instanceof [Arr, While] or
                   node instanceof Chain and node.tails[*-1]key?length or
                   node.op is \* and node.first instanceof Arr
    Call.make JS(utility(\slice) + \.call), [node]

#### Jump
# `break` `continue`
class exports.Jump extends Node
  (@verb, @label) ->

  show: -> (@verb or '') + if @label then ' ' + that else ''

  isStatement : YES
  makeReturn  : THIS

  jumps: ->
    not (it and (it.loop or it.block and @verb is not \continue)) and this

  compileNode: -> @show() + \;

#### Throw
class exports.Throw extends Jump
  (@it) ~>

  children: [\it]

  jumps: NO

  compileNode: (o) ->
    "throw #{ (@it or Literal \null)compile o, LEVEL_PAREN };"

  Jump.throw = this

#### Return
class exports.Return extends Throw
  ~> @<<<{it} if it and it.value is not \void

  jumps: THIS

  compileNode: (o) ->
    "return#{ if @it then ' ' + @it.compile o, LEVEL_PAREN else '' };"

  Jump.return = this

#### While
# The traditional `while` loop.
# Returns an array of values collected from the last expression when requested.
class exports.While extends Node
  (@test, @negated) ->

  children: <[ test body ]>

  aSource: \test, aTarget: \body

  ::{show} = Negatable

  isStatement: YES

  jumps: ->
    {lines} = @body
    return unless lines.length
    context = {+loop}
    return node if node.jumps context for node of lines

  addBody: (@body) ->
    [top] = body.lines
    body.lines.length = 0 if top?verb is \continue and not top.label
    this

  makeReturn: ->
    if it
      @body.makeReturn it
    else unless @jumps()
      @returns = true
    this

  compileNode: (o) ->
    @pluckDirectCalls o
    code = unless @test then \true else
      @anaphorize()
      (if @negated then @test.invert() else @test)compile o, LEVEL_PAREN
    code = if code is \true then 'for (;;' else 'while (' + code
    o.indent += TAB
    code + ') {' + @compileBody o

  compileBody: (o) ->
    {lines} = @body; end = \}
    if @returns
      [last, i] = lastNonComment lines
      if last and last not instanceof Throw
        lines[i] = last.makeReturn res = o.scope.assign \_results '[]'
      end = "}\n#{@tab}return #{ res or '[]' };"
    return end unless lines.length
    "\n#{ @body.compile o, LEVEL_TOP }\n" + @tab + end

  pluckDirectCalls: (o) ->
    @body.eachChild dig = ~>
      unless it.calling
        return if it instanceof [Fun, While] then null else it.eachChild dig
      {head: fun, tails: [call]} = it.=it
      return if fun.statement
      if this instanceof For
        return if fun.params.length ^ call.args.length - !!call.method
        @index and fun.params.push call.args.* = Var @index
        if name = @name
          call.args.push if name.isComplex()
          then Var @nref ||= @temps.* = o.scope.temporary \ref
          else name
          fun.params.push name
      fun.plucked = true
      void

#### For
# Coco's replacements for the `for` loop are array, object or range iterators.
class exports.For extends While
  -> this import all it

  children: <[ name source from to step body ]>

  aSource: null

  show: -> @index

  compileNode: (o) ->
    temps = @temps = []
    if idx = @index
    then o.scope.declare idx
    else temps.push idx = o.scope.temporary \i
    unless @object
      [pvar, step] = (@step || Literal 1)compileLoopReference o, \step
      pvar is step or temps.push pvar
    if @from
      eq = if @op is \til then '' else \=
      [tvar, tail] = @to.compileLoopReference o, \to
      vars = idx + ' = ' + @from.compile o
      unless tail is tvar
        vars += ', ' + tail
        temps.push tvar
      cond = if +pvar
      then "#{idx} #{ if pvar < 0 then \> else \< }#{eq} #{tvar}"
      else "#{pvar} < 0 ? #{idx} >#{eq} #{tvar} : #{idx} <#{eq} #{tvar}"
    else
      if @name or @object and @own
        [svar, srcPart] = @source.compileLoopReference o, \ref, not @object
        svar is srcPart or temps.push svar
      else
        svar = srcPart = @source.compile o, LEVEL_PAREN
      unless @object
        if 0 > pvar and (pvar | 0) is +pvar  # negative int
          vars = "#{idx} = #{srcPart}.length - 1"
          cond = "#{idx} >= 0"
        else
          temps.push lvar = o.scope.temporary \len
          vars = "#{idx} = 0, #{lvar} = #{srcPart}.length"
          cond = "#{idx} < #{lvar}"
    head = 'for (' + if @object then "#{idx} in #{srcPart}" else
      step is pvar or vars += ', ' + step
      "#{vars}; #{cond}; " + if 1 == Math.abs pvar
      then (if pvar < 0 then \-- else \++) + idx
      else idx + if pvar < 0 then ' -= ' + pvar.slice 1 else ' += ' + pvar
    @own and head += ") if (#{ o.scope.assign \_own '{}.hasOwnProperty' }
                            .call(#{svar}, #{idx})"
    head += ') {'
    @pluckDirectCalls o
    o.indent += TAB
    if @name
      head += \\n + o.indent
      item  = svar + "[#{idx}]"
      if @nref
        head += that + ' = ' + item + ', '
        item  = that
      head += Assign(@name, Literal item)compile(o, LEVEL_TOP) + \;
    body  = @compileBody o
    head += \\n + @tab if @name and \} is body.charAt 0
    head + body

#### Try
# Classic `try`-`catch`-`finally` block with optional `catch`.
class exports.Try extends Node
  (@attempt, @thrown ? \_e, @recovery, @ensure) ->

  children: <[ attempt recovery ensure ]>

  show: -> @thrown

  isStatement: YES

  isCallable: -> @attempt.isCallable() or @recovery?isCallable()

  jumps: -> @attempt.jumps it or @recovery?jumps it

  makeReturn: ->
    @attempt .=makeReturn it
    @recovery.=makeReturn it if @recovery
    this

  compileNode: (o) ->
    o.indent += TAB
    code = "try #{@compileBlock o, @attempt}"
    if @recovery or not @ensure
      o.scope.check v = @thrown || \e or o.scope.add v, \catch
      code += " catch (#{v}) #{ @compileBlock o, @recovery }"
    if @ensure
      code += " finally #{ @compileBlock o, @ensure }"
    code

#### Switch
# Compiles to the regular JS `switch`-`case`-`default`,
# but with forced `break` after each cases.
class exports.Switch extends Node
  (@topic, @cases, @default) ->

  children: <[ topic cases default ]>

  aSource: \topic, aTarget: \cases

  isStatement: YES

  isCallable: ->
    return true if c.isCallable() for c of @cases
    @default?isCallable()

  jumps: (x or {+block}) ->
    return that if c.body.jumps x for c of @cases
    @default?jumps x

  makeReturn: ->
    c.makeReturn it for c of @cases
    @default?makeReturn it
    this

  compileNode: (o) ->
    {tab} = this
    topic = !!@topic and (@anaphorize(); @topic.compile o, LEVEL_PAREN)
    code  = "switch (#{topic}) {\n"
    stop  = @default or @cases.length - 1
    code += c.compileCase o, tab, i is stop, !topic for c, i of @cases
    if @default
      o.indent = tab + TAB
      code += tab + "default:\n#{that}\n" if @default.compile o, LEVEL_TOP
    code + tab + \}

#### Case
class exports.Case extends Node
  (@test, @body) ->

  children: <[ test body ]>

  isCallable: -> @body.isCallable()

  makeReturn: ->
    lastNonComment(@body.lines)0.value is \fallthrough or @body.makeReturn it
    this

  compileCase: (o, tab, nobr, bool) ->
    tests = if @test instanceof Arr then @test.items else [@test]
    tests.length or tests.push Literal \void
    if bool
      [t] = tests; i = 0; t = Op \|| t, that while tests[++i]
      (@<<<{t, aSource: \t, aTarget: \body})anaphorize()
      tests = [@t.invert()]
    code = ''
    code += tab + "case #{ t.compile o, LEVEL_PAREN }:\n" for t of tests
    [last, i] = lastNonComment @body.lines
    @body.lines[i] = JS '// fallthrough' if ft = last.value is \fallthrough
    o.indent = tab += TAB
    code += that + \\n        if @body.compile o, LEVEL_TOP
    code += tab  + 'break;\n' unless nobr or ft or last instanceof Jump
    code

#### If
# The `if`/`else` structure that acts as both statement and expression.
class exports.If extends Node
  (@if, @then, {@soak, name} or {}) ~> @negated = name is \unless

  children: <[ if then else ]>

  aSource: \if, aTarget: \then

  ::{show} = Negatable

  terminator: ''

  # Rewrites a chain of **If**s to add a default case as the final `else`.
  addElse: ->
    if @chain
    then @else.addElse it
    else @chain = (@else = it) instanceof If
    this

  isCallable: -> @then.isCallable() or @else?isCallable()

  jumps: -> @then.jumps it or @else?jumps it

  makeReturn: ->
    @then.=makeReturn it
    @else.=makeReturn it if @else
    this

  compileNode: (o) ->
    @anaphorize()
    @negated and @if.=invert()
    if o.level then @compileExpression o else @compileStatement o

  compileStatement: (o) ->
    code = 'if (' + @if.compile o, LEVEL_PAREN
    o.indent += TAB
    code += ') ' + @compileBlock o, Block @then
    return code unless @else
    code + ' else ' + if @chain
    then @else.compile o <<< indent: @tab, LEVEL_TOP
    else @compileBlock o, @else

  compileExpression: (o) ->
    code = @if.compile o, LEVEL_COND
    pad  = if @else?isComplex() and @then.isComplex()
    then \\n + o.indent += TAB else ' '
    code += pad + '? ' +  @then.compile(o, LEVEL_LIST) +
            pad + ': ' + (@else?compile(o, LEVEL_LIST) or 'void 8')
    if o.level < LEVEL_COND then code else "(#{code})"

  unfoldSoak: -> @soak and this

  # Unfolds a node's child if soak, then tuck the node under the created **If**.
  @unfoldSoak = (o, parent, name) ->
    if parent[name]unfoldSoak o
      parent[name] = that.then
      that import then: Chain parent

#### Label
# A labeled block or statement.
class exports.Label extends Node
  (@label, @it) ->

  ::{children, isCallable} = Parens::

  show: -> @label

  isStatement : YES
  jumps       : -> @it.jumps it
  makeReturn  : -> @it.=makeReturn it; this

  compileNode: (o) ->
    {it} = this
    it.isStatement() or it = Block it
    "#{ @label or \$ }: " + if it instanceof Block
    then o.indent += TAB; @compileBlock o, it
    else it.compile o

#### JS
# Embedded JavaScript snippets.
class exports.JS extends Node
  (@code, @literal, @comment) ~>

  show: -> if @comment then @code else "`#{@code}`"

  terminator: ''
  isCallable: -> not @comment

  compile: -> if @literal then entab @code, it.indent else @code

#### Util
# A wrapper node for utility functions.
class exports.Util extends Node
  (@verb) ~>

  {::show} = Jump::

  isCallable: YES

  compile: -> utility @verb

  ##### Util.Extends
  # An operator that sets up class-ical inheritance between two constructors,
  # returning the left one.
  @Extends = -> Call.make Util(\extends), @@[0 1]

#### Parser Utils
# Helpers for modifying nodes in [parser](../lib/parser.js).

exports.L = (yylineno, node) -> node import line: yylineno + 1

##### Scope
# Regulates lexical scoping within Coco. As you
# generate code, you create a tree of scopes in the same shape as the nested
# functions. Each scope knows about the function parameters and the variables
# declared within it, and has references to its parent/shared enclosing scopes.
function Scope(@parent, @shared) ->
  @variables = []
  @positions = {}
  void
Scope::<<<
  # Adds a new variable or overrides an existing one.
  add: (name, type) ->
    if @variables[@positions[name]]
    then that <<< {type}
    else @positions[name] = ~-@variables.push {name, type}
    name

  # Declares a variable unless declared already.
  declare: (name) ->
    if @shared
      return if @check name
      scope = that
    else
      scope = this
    unless (type = scope.type name) and (type of <[ var arg ]> or type.value)
      scope.add name, \var

  # Ensures that an assignment is made at the top of this scope.
  assign: (name, value) -> @add name, {value}

  # If we need to store an intermediate result, find an available name for a
  # compiler-generated variable. `_var`, `_var2`, and so on...
  temporary: (name) ->
    i = 0
    for ever
      temp = \_ + if name.length > 1
      then name + (if i++ then i else '')
      else (i++ + parseInt name, 36)toString 36
      break if @type(temp) of [\reuse void]
    @add temp, \var

  # Allows a variable to be reused.
  free: -> @add it, \reuse

  # Checks to see if a variable has already been declared.
  # Walks up the scope if `above` flag is specified.
  check: (name, above) ->
    return found if (found = @positions[name] in @variables) or not above
    @parent?check name, above

  # Gets the type of a variable from name.
  type: -> @variables[@positions[it]]?type

  # Returns the list of variables declared in this scope.
  vars: (o) ->
    usr = []; tmp = []; asn = []
    for {name, type} of @variables
      if type of <[ var reuse ]>
        (if \_ is name.charAt 0 then tmp else usr)push name
      else if type.value
        asn.push entab name + ' = ' + type.value, o.indent
    return asn.join ', ' if o.globals
    'var ' + that if usr.concat(tmp, asn)join ', '

##### Constants

function YES  -> true
function NO   -> false
function THIS -> this

UTILITIES =
  # Creates an object's prototypal child, ensuring `__proto__`.
  clone: '''
    function(it){
      function fn(){ if (this.__proto__ !== it) this.__proto__ = it }
      return fn.prototype = it, new fn;
    }
  '''
  # Sets up `.prototype` between a pair of constructors
  # as well as `.constructor` and `.superclass` references.
  extends: '''
    function(sub, sup){
      function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
      return (sub.prototype = new ctor).constructor = sub;
    }
  '''

  # Wraps a function to fixate its `this` value.
  bind: '''
    function(me, fn){ return function(){ return fn.apply(me, arguments) } }
  '''

  # Copies properties from right to left.
  import: '''
    function(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
  '''
  importAll: '''
    function(obj, src){ for (var key in src) obj[key] = src[key]; return obj }
  '''

  repeatString: '''
    function(str, n){
      for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
      return r;
    }
  '''
  repeatArray: '''
    function(arr, n){
      for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
        if (n & 1) r.push.apply(r, arr);
      return r;
    }
  '''

  # Shortcuts to speed up the lookup time for native functions.
  slice    : '[].slice'
  toString : '{}.toString'
  indexOf  : '''
    [].indexOf || function(x){
      for (var i = this.length; i-- && this[i] !== x;); return i;
    }
  '''

# Each level indicates a node's position in the AST.
LEVEL_TOP    = 0  # ...;
LEVEL_PAREN  = 1  # (...)
LEVEL_LIST   = 2  # [...]
LEVEL_COND   = 3  # ... ? x : y
LEVEL_OP     = 4  # !...
LEVEL_CALL   = 5  # ...()

# Operator precedances.
PREC = \? : .1, unary : .9
PREC\&& = PREC\||                                                  = .2
PREC\&  = PREC\^  = PREC\|                                         = .3
PREC\== = PREC\!= = PREC\=== = PREC\!==                            = .4
PREC\<  = PREC\>  = PREC\<=  = PREC\>= = PREC\in = PREC\instanceof = .5
PREC\<< = PREC\>> = PREC\>>>                                       = .6
PREC\+  = PREC\-                                                   = .7
PREC\*  = PREC\/  = PREC\%                                         = .8

TAB = ' ' * 2

ID = /^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*$/

SIMPLENUM = /^\d+$/

##### Helpers

# Declares a utility function at the top level.
function utility -> Scope.root.assign \__ + it, UTILITIES[it]

function lastNonComment(nodes) ->
  break unless node.comment for node, i of nodes by -1
  [i >= 0 and node, i]

function entab(code, tab) -> code.replace /\n/g \\n + tab
