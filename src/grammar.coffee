# The Coco parser is generated by [Jison](http://github.com/zaach/jison)
# from this grammar file. Jison is a bottom-up parser generator, similar in
# style to [Bison](http://www.gnu.org/software/bison), implemented in JavaScript.
# It can recognize [LALR(1), LR(0), SLR(1), and LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
# type grammars. To create the Jison parser, we list the pattern to match
# on the left-hand side, and the action to take (usually the creation of syntax
# tree nodes) on the right. As the parser runs, it
# shifts tokens from our token stream, from left to right, and
# [attempts to match](http://en.wikipedia.org/wiki/Bottom-up_parsing)
# the token sequence against the rules below. When a match can be made, it
# reduces into the [nonterminal](http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)
# (the enclosing name at the top), and we proceed from there.
#
# If you run the `coke build:parser` command, Jison constructs a parse table
# from our rules and saves it into [lib/parser.js](../lib/parser.js).

# Jison DSL
# ---------

# Since we're going to be wrapped in a function by Jison in any case, if our
# action immediately returns a value, we can optimize by removing the function
# wrapper and just returning the value directly.
unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/

# Our handy DSL for Jison grammar generation, thanks to
# [Tim Caswell](http://github.com/creationix). For every rule in the grammar,
# we pass the pattern-defining string, the action to run, and extra options,
# optionally. If no action is specified, we simply pass the value of the
# previous nonterminal.
o = (patterns, action, options) ->
  patterns.=trim().split /\s+/
  return [patterns, '$1', options] unless action
  action = if match = unwrap.exec action then match.1 else "(#{action}())"
  action.=replace /\b(?:[A-Z]|mix\b)/g, 'yy.$&'
  [patterns, action, options]

# Grammatical Rules
# -----------------

# In all of the rules that follow, you'll see the name of the nonterminal as
# the key to a list of alternative matches. With each match's action, the
# dollar-sign variables are provided by Jison as references to the value of
# their numeric position, so in this rule:
#
#     "Expression MATH Expression"
#
# `$1` would be the value of the first `Expression`, `$2` would be the token
# for the `MATH` terminal, and `$3` would be the value of the second
# `Expression`.
grammar =
  # Everything that can be assigned to.
  Assignable: [
    o 'SimpleAssignable'
    o 'Array'
    o 'Object'
  ]

  # The types of things that can be accessed or indexed into.
  Value: [
    o 'Assignable'    ,-> Value $1
    o 'STRNUM'        ,-> Value Literal $1
    o 'Parenthetical' ,-> Value $1
    o 'THIS'          ,-> Value Literal 'this', true
    o 'LITERAL'       ,-> Value Literal $1    , true
    o 'Value CALL_START ArgList OptComma CALL_END' ,-> Value Call $1, $3  , $2
    o 'Value CALL_START ...              CALL_END' ,-> Value Call $1, null, $2
  ]

  # Variables and properties that can be assigned to.
  SimpleAssignable: [
    o 'IDENTIFIER'                             ,-> Literal $1
    o 'Value ACCESS IDENTIFIER'                ,-> $1.add Access Literal($3), $2
    o 'Value ACCESS STRNUM'                    ,-> $1.add Index  Literal($3), $2
    o 'Value ACCESS Parenthetical'             ,-> $1.add Index  $3.it,       $2
    o 'Value INDEX_START Expression INDEX_END' ,-> $1.add Index  $3,          $2
    o 'ThisProperty'
    o 'SUPER'                                  ,-> Super()
  ]

  # All the different types of expressions in our language.
  Expression: [
    o 'Value' ,-> $1.unwrap()

    o 'Assignable       ASSIGN          Expression' ,-> Assign $1, $3, $2
    o 'SimpleAssignable COMPOUND_ASSIGN Expression' ,-> Assign $1, $3, $2

    # Arithmetic and logical operators, working on one or two operands.
    # The precedence rules are defined at the bottom of the page.
    # It would be shorter if we could combine most of these rules into
    # a single generic "Operand OpSymbol Operand"-type rule,
    # but in order to make the precedence binding possible, separate
    # rules are necessary.
    o 'Expression PLUS_MINUS Expression' ,-> Op $2, $1, $3
    o 'Expression MATH       Expression' ,-> Op $2, $1, $3
    o 'Expression SHIFT      Expression' ,-> Op $2, $1, $3
    o 'Expression COMPARE    Expression' ,-> Op $2, $1, $3
    o 'Expression LOGIC      Expression' ,-> Op $2, $1, $3
    o 'Expression IMPORT     Expression' ,-> Import $1, $3, !$2
    o 'Expression RELATION   Expression' ,->
      return if $2.charAt(0) is '!'
      then Op($2.slice 1; $1; $3).invert()
      else Op $2, $1, $3

    o 'UNARY      Expression' , -> Op $1, $2
    o 'PLUS_MINUS Expression' ,(-> Op $1, $2), prec: 'UNARY'

    o 'Expression ?' ,-> Existence $1

    o 'CREMENT SimpleAssignable' ,-> Op $1, $2
    o 'SimpleAssignable CREMENT' ,-> Op $2, $1, null, true

    o 'Fun'
    o 'FUNCTION Fun'            ,-> mix $2, statement: true
    o 'FUNCTION IDENTIFIER Fun' ,-> mix $3, statement: true, name: $2

    # The full complement of `if` expressions,
    # including postfix one-liner `if` and `unless`.
    o 'IfBlock'
    o 'Statement  POST_IF Expression' ,-> If $3, Lines($1), name: $2
    o 'Expression POST_IF Expression' ,-> If $3, Lines($1), name: $2

    # Comprehensions can either be normal, with a block of expressions
    # to execute, or postfix, with a single expression.
    o 'LoopHead   Block'    ,-> $1.addBody $2
    o 'Statement  LoopHead' ,-> $2.addBody Lines $1
    o 'Expression LoopHead' ,-> $2.addBody Lines $1

    o 'SWITCH Expression Cases'               ,-> Switch $2, $3
    o 'SWITCH Expression Cases DEFAULT Block' ,-> Switch $2, $3, $5
    o 'SWITCH Cases'                          ,-> Switch null, $2
    o 'SWITCH Cases DEFAULT Block'            ,-> Switch null, $2, $4

    o 'TRY Block'                                      ,-> Try $2
    o 'TRY Block CATCH IDENTIFIER Block'               ,-> Try $2, $4, $5
    o 'TRY Block                        FINALLY Block' ,-> Try $2, null, null, $4
    o 'TRY Block CATCH IDENTIFIER Block FINALLY Block' ,-> Try $2, $4, $5, $7

    # Class definitions have optional bodies of prototype property assignments,
    # and optional references to the superclass.
    o 'CLASS OptExtends'                        ,-> Class null, $2
    o 'CLASS OptExtends Block'                  ,-> Class null, $2, $3
    o 'CLASS SimpleAssignable OptExtends'       ,-> Class $2, $3
    o 'CLASS SimpleAssignable OptExtends Block' ,-> Class $2, $3, $4

    o 'SimpleAssignable EXTENDS Expression' ,-> Extends $1, $3
  ]

  # Any list of statements and expressions,
  # separated by line breaks or semicolons.
  Body: [
    o 'Expression'                 ,-> Lines $1
    o 'Statement'                  ,-> Lines $1
    o 'Body TERMINATOR Expression' ,-> $1.add $3
    o 'Body TERMINATOR Statement'  ,-> $1.add $3
    o 'Body TERMINATOR'
  ]

  # An optional, trailing comma.
  OptComma: [
    o ''
    o ','
  ]

  Arg: [
    o     'Expression'
    o '... Expression' ,-> Splat $2
  ]
  # **ArgList** is both the list of objects passed into a function call,
  # as well as the contents of an array literal
  # (i.e. comma-separated expressions). Newlines work as well.
  ArgList: [
    o ''                                                 ,-> []
    o 'Arg'                                              ,-> [$1]
    o 'ArgList , Arg'                                    ,-> $1.concat $3
    o 'ArgList OptComma TERMINATOR Arg'                  ,-> $1.concat $4
    o 'ArgList OptComma INDENT ArgList OptComma OUTDENT' ,-> $1.concat $4
  ]
  Array: [
    o '[ ArgList OptComma ]' ,-> Arr $2
  ]

  # A reference to a property on `this`.
  ThisProperty: [
    o 'THISPROP' ,-> Value Literal('this'), [Access Literal $1], true
  ]

  # Parenthetical expressions. Note that the **Parenthetical** is a **Value**,
  # not an **Expression**, so if you need to use an expression in a place
  # where only values are accepted, wrapping it in parentheses will always do
  # the trick.
  Parenthetical: [
    o '(        Body         )' ,-> Parens $2.unwrap()
    o '( INDENT Body OUTDENT )' ,-> Parens $3.unwrap()
  ]

  # Pure statements which cannot be expressions.
  Statement: [
    o 'RETURN Expression' ,-> Return $2
    o 'RETURN'            ,-> Return()
    o 'STATEMENT'         ,-> Statement $1
    o 'THROW Expression'  ,-> Throw $2
    o 'COMMENT'           ,-> Comment $1
  ]

  # An indented block of expressions. Note that the [Rewriter](#rewriter)
  # will convert some postfix forms into blocks for us, by adjusting the
  # token stream.
  Block: [
    o 'INDENT Body OUTDENT' ,-> $2
    o 'INDENT      OUTDENT' ,-> Lines()
  ]

  # **Fun** node is the function literal, defined by an indented **Block**
  # preceded by a function arrow, with an optional parameter list.
  Fun: [
    o 'PARAM_START ParamList PARAM_END FUNC_ARROW Block' ,-> Fun $2, $5, $4
    o                                 'FUNC_ARROW Block' ,-> Fun [], $2, $1
  ]
  # The list of parameters that a function accepts can be of any length.
  ParamList: [
    o ''                  ,-> []
    o 'Param'             ,-> [$1]
    o 'ParamList , Param' ,-> $1.concat $3
  ]
  # A single parameter in a function definition can be ordinary, or a splat
  # that hoovers up the remaining arguments.
  Param: [
    o     'ParamVar'
    o '... ParamVar'                   ,-> Splat $2
    o     'ParamVar ASSIGN Expression' ,-> Assign $1, $3, null, $2.logic or '?'
  ]
  ParamVar: [
    o 'IDENTIFIER' ,-> Literal $1
    o 'ThisProperty'
    o 'Array'
    o 'Object'
  ]

  # Things that can be keys within an object literal.
  ObjAssignable: [
    o 'IDENTIFIER' ,-> Literal $1
    o 'STRNUM'     ,-> Literal $1
    o 'Parenthetical'
    o 'ThisProperty'
  ]
  AssignObj: [
    o 'ObjAssignable :        Expression'         ,-> Assign $1, $3, ':'
    o 'ObjAssignable : INDENT Expression OUTDENT' ,-> Assign $1, $4, ':'

    o            'ObjAssignable' ,-> $1
    o '...        ObjAssignable' ,-> Splat  $2
    o 'PLUS_MINUS ObjAssignable' ,-> Assign $2, Literal($1 is '+'), ':'

    o 'COMMENT' ,-> Comment $1
  ]
  # Assignment of properties within an object literal can be separated by
  # comma, as in JavaScript, or simply by newline.
  AssignList: [
    o ''                                                       ,-> []
    o 'AssignObj'                                              ,-> [$1]
    o 'AssignList , AssignObj'                                 ,-> $1.concat $3
    o 'AssignList OptComma TERMINATOR AssignObj'               ,-> $1.concat $4
    o 'AssignList OptComma INDENT AssignList OptComma OUTDENT' ,-> $1.concat $4
  ]
  # In Coco, an object literal is simply a list of assignments.
  Object: [
    o '{ AssignList OptComma }' ,-> Obj $2
  ]

  # The most basic form of *if* is a condition and an action. The following
  # if-related rules are broken up along these lines in order to avoid
  # ambiguity.
  IfBlock: [
    o 'IF Expression Block'              ,-> If $2, $3, name: $1
    o 'IfBlock ELSE IF Expression Block' ,-> $1.addElse If $4, $5, name: $3
    o 'IfBlock ELSE Block'               ,-> $1.addElse $3
  ]

  LoopHead: [
    # The source of a `for`-loop is an array, object or range.
    # Unless it's iterating over an object, you can choose to step through
    # in fixed-size increments.
    o 'FOR Assignable              FOROF Expression'
    , -> mix For(), name: $2,            source: $4
    o 'FOR Assignable , IDENTIFIER FOROF Expression'
    , -> mix For(), name: $2, index: $4, source: $6
    o 'FOR Assignable              FOROF Expression BY Expression'
    , -> mix For(), name: $2,            source: $4, step: $6
    o 'FOR Assignable , IDENTIFIER FOROF Expression BY Expression'
    , -> mix For(), name: $2, index: $4, source: $6, step: $8

    o 'FOR IDENTIFIER              FORIN Expression'
    , -> mix For(), object: true, own: !$1, index: $2,           source: $4
    o 'FOR Assignable , Assignable FORIN Expression'
    , -> mix For(), object: true, own: !$1, index: $2, name: $4, source: $6

    o 'FOR IDENTIFIER FROM Expression TO Expression'
    , -> mix For(), index: $2, from: $4, op: $5, to: $6
    o 'FOR IDENTIFIER FROM Expression TO Expression BY Expression'
    , -> mix For(), index: $2, from: $4, op: $5, to: $6, step : $8

    o 'WHILE Expression' ,-> While $2, $1
    o 'FOR EVER'         ,-> While()
  ]

  Cases: [
    o       'CASE SimpleArgs Block' ,-> [Case $2, $3]
    o 'Cases CASE SimpleArgs Block' ,-> $1.concat Case $3, $4
  ]
  # Just simple, comma-separated, required arguments (no fancy syntax).
  # We need this to be separate from the **ArgList** for use in **Cases**,
  # where having the newlines wouldn't make sense.
  SimpleArgs: [
    o 'Expression'              ,-> [$1]
    o 'SimpleArgs , Expression' ,-> $1.concat $3
  ]

  # Optional `extends` clause for class definition.
  OptExtends: [
    o ''              ,-> null
    o 'EXTENDS Value' ,-> $2
  ]

  # The **Root** is the top-level node in the syntax tree.
  # Since we parse bottom-up, all parsing must end here.
  Root: [
    o '' ,-> Lines()
    o 'Body'
    o 'Block TERMINATOR'
  ]

# Precedence
# ----------

# Operators at the top of this list have higher precedence than the ones lower
# down. Following these rules is what makes `2 + 3 * 4` parse as:
#
#     2 + (3 * 4)
#
# And not:
#
#     (2 + 3) * 4
operators = [
  <[ nonassoc  CREMENT                      ]>
  <[ left      ?                            ]>
  <[ right     UNARY                        ]>
  <[ left      MATH                         ]>
  <[ left      PLUS_MINUS                   ]>
  <[ left      SHIFT                        ]>
  <[ left      RELATION IMPORT              ]>
  <[ left      COMPARE                      ]>
  <[ left      LOGIC                        ]>
  <[ right     : ASSIGN COMPOUND_ASSIGN
               RETURN THROW EXTENDS INDENT  ]>
  <[ right     IF ELSE SWITCH CASE DEFAULT
               CLASS FORIN FOROF FROM TO BY ]>
  <[ left      POST_IF FOR WHILE            ]>
]

# Wrapping Up
# -----------

# Finally, now what we have our **grammar** and our **operators**, we can create
# our **Jison.Parser**. We do this by processing all of our rules, recording all
# terminals (every symbol which does not appear as the name of a rule above)
# as "tokens".
tokens = for name, alternatives in grammar
  for alt of alternatives
    alt.1 = "#{ if name is 'Root' then 'return' else '$$ =' } #{alt.1};"
    token if token not in grammar for token of alt.0

# Initialize the **Parser** with our list of terminal **tokens**, our **grammar**
# rules, and the name of the root. Reverse the operators because Jison orders
# precedence from low to high, and we have it high to low
# (as in [Yacc](http://dinosaur.compilertools.net/yacc/index.html)).
exports.parser = new (require 'jison').Parser then
  tokens      : tokens.join ' '
  bnf         : grammar
  operators   : operators.reverse()
  startSymbol : 'Root'
