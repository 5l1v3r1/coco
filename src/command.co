`#!/usr/bin/env node`
# The `coco` utility.

global import
  Coco : require \./coco
  fs   : require \fs
  path : require \path
  say  : -> process.stdout.write              it + \\n
  warn : -> process.binding(\stdio)writeError it + \\n
  die  : -> warn it; process.exit 1

# Use the [option parser](#optparse).
o = require(\./optparse) do
  compile     : 'compile to JavaScript and save as .js files'
  interactive : 'run an interactive Coco REPL'
  output      :['set the directory for compiled JavaScript' \DIR]
  watch       : 'watch scripts for changes, and recompile'
  print       : 'print the compiled JavaScript to stdout'
  stdin       : 'listen for and compile scripts over stdin'
  eval        : 'compile a string from the command line'
  require     :['require libraries before executing' \FILE+]
  bare        : 'compile without the top-level function wrapper'
  lex         : 'print the tokens the lexer produces'
  tokens      : 'print the tokens the rewriter produces'
  ast         : 'print the syntax tree the parser produces'
  json        : 'print the syntax tree as JSON'
  nodejs      :['pass options through to the "node" binary' \ARGS+]
  version     : 'display Coco version'
  help        : 'display this help message'

if o.$unknowns.length
  say "Unrecognized option(s): #{ o.$unknowns.join ' ' }\n"
  help()
  process.exit 1

o.run = not (o.compile or o.print)
o.print   ||= o.eval or o.stdin and o.compile
o.compile ||= o.output
o.bare    ||= o.eval and o.run

# Many flags cause us to divert before compiling anything.
# Arguments passed after `--` will be passed verbatim to your script as
# `process.argv`.
switch
case o.nodejs  then do forkNode
case o.version then do version
case o.help    then do help
default
  {$args} = o
  {argv}  = process
  argv.0  = argv.1
  if o.require
    ({filename} = module)filename = \.
    that.forEach require
    module <<< {filename}
  switch
  case o.interactive then argv.1 = \repl  ; repl()
  case o.stdin       then argv.1 = \stdin ; compileStdin()
  case o.eval        then argv.1 = \eval  ; compileScript '' $args.join \\n
  case $args.length
    process.argv.splice 2 9e9,
      ...if o.run then $args.splice 1 else [], ...o.$literals
    compileScripts()
  default version(); help(); repl()

# Asynchronously read in each Coco script in a list of source files and
# compile them. If a directory is passed, recursively compile all
# _.co_ files in it and all subdirectories.
function compileScripts ->
  $args.forEach (source) ->
    <- path.exists source
    it or die "No such file or directory: #{source}"
    walk source, path.normalize(source), true
  function walk(source, base, top) ->
    e, stats <- fs.stat source
    if stats.isDirectory()
      e, files <- fs.readdir source
      files.forEach -> walk path.join(source, it), base
    else if top or path.extname(source)toLowerCase() is \.co
      watch source, base if o.watch
      e, buf <- fs.readFile source
      compileScript source, buf.toString(), base
  void

# Compile a single source script, containing the given code, according to the
# requested options.
function compileScript(file, input, base) ->
  t = {file, input, options: filename: file, bare: !!o.bare}
  try
    Coco.emit \lex t
    t.tokens = Coco.tokens t.input, raw: o.lex
    if o.lex or o.tokens
      printTokens t.tokens
      throw
    Coco.emit \parse t
    t.ast = Coco.ast t.tokens
    if o.ast
      say t.ast.toString()trim()
      throw
    if o.json
      say t.ast.stringify 1
      throw
    Coco.emit \compile t
    t.output = t.ast.compileRoot t.options
    if o.run
      Coco.emit \run t
      if o.eval
      then console.log (0; eval) t.output
      else Coco.run t.output, t.options <<< {+js}
    else
      Coco.emit \write t
      if o.print
      then say t.output.trimRight()
      else writeJs t.file, t.output, base
  catch if e
    if Coco.listeners(\failure)length
      Coco.emit \failure e, t
    else
      warn "Failed at: #{file}\n" if file
      (if o.watch then warn else die) e.stack || e
    return
  Coco.emit \success t

# Attach the appropriate listeners to compile scripts incoming over **stdin**,
# and write them back to **stdout**.
function compileStdin ->
  code  = ''
  stdin = process.openStdin()
  stdin.on \data -> code += it if it
  stdin.on \end  -> compileScript null code

# Watch a source Coco file using `fs.watchFile`, recompiling it every
# time the file is updated. May be used in combination with other options,
# such as `--ast` or `--print`.
function watch(source, base) ->
  fs.watchFile source, {+persistent, interval: 500ms} (curr, prev) ->
    return if curr.size is prev.size and +curr.mtime is +prev.mtime
    e, code <- fs.readFile source
    e and die e.stack || e
    compileScript source, code.toString(), base

# Write out a JavaScript source file with the compiled code. By default, files
# are written out in `cwd` as `.js` files with the same name, but the output
# directory can be customized with `--output`.
function writeJs(source, js, base) ->
  filename = path.basename(source, path.extname source) + \.js
  srcDir   = path.dirname source
  dir      = if o.output
  then path.join that, srcDir.slice (if base is \. then 0 else base.length)
  else srcDir
  jsPath = path.join dir, filename
  function compile ->
    e <- fs.writeFile jsPath, js || \\n
    return warn e if e
    if o.compile and o.watch
      require(\util)log "Compiled #{source}"
  <- path.exists dir
  if it
  then do compile
  else require(\child_process)exec "mkdir -p #{dir}", compile

# Pretty-print a stream of tokens.
function printTokens(tokens) ->
  lines = []
  for [tag, val, lno] of tokens
    tag += \: + val unless tag is val += ''
    (lines[lno] ||= [])push tag
  say(if l then l.join(' ')replace /\n/g \\\n else '') for l of lines

# A simple Read-Eval-Print-Loop. Compiles one line
# (or a block of lines if continued using backslash) at a time to JavaScript,
# and evaluates (or prints if _-c_) it.
# Good for simple tests or poking around the
# [**node.js** API](http://nodejs.org/api/).
function repl ->
  module.filename = process.cwd() + \/repl
  {Script} = process.binding \evals
  context  = Script.createContext() <<< {...global, module, require}
  buf      = ''
  readline = require \readline
  stdin    = process.openStdin()
  repl     = readline.createInterface stdin, process.stdout
  repl.on \close stdin~.destroy
  repl.on \line ->
    code = buf + \\n + it
    if \\ is code.slice -1 then buf := code.slice 0 -1; return
    buf := ''
    try
      if o.compile
        console.log \%s Coco.compile code, {o.bare}
      else
        _ = Script.runInContext \
              Coco.compile(code.slice 1; {+bare, +repl}), context
        _ is void or console.dir context._ = _
    catch then say e
    repl.prompt()
  process.on \uncaughtException -> say \\n + (it?.stack or it)
  __defineGetter__ \quit -> process.exit 0
  prompt = \coco
  if o.compile
    prompt += ' -c'
    prompt += \b if o.bare
  repl.setPrompt prompt + '> '
  repl.prompt()

# Start up a new __node.js__ instance with the arguments in `--nodejs` passed
# to it, preserving the other options.
function forkNode ->
  args = process.argv.slice 1; i = 0
  args.splice i--, 2 if that of <[ -N --nodejs ]> while args[++i]
  require(\child_process)spawn do
    process.execPath
    o.nodejs.join(' ')trim()split(/\s+/)concat args
    cwd: process.cwd(), env: process.env, customFds: [0 to 2]

# Print the `--help` message.
function help -> say """
  Usage: coco [options] [files] [arguments]

  Options:
  #{o}
"""

# Print the `--version` message.
function version -> say "Coco #{Coco.VERSION}"
