# The `coco` utility.

global import
  Coco : require(\./coco) import all require(\events).EventEmitter::
  fs   : require \fs
  path : require \path
  say  : -> process.stdout.write               it + \\n
  warn : -> process.binding(\stdio).writeError it + \\n
  die  : -> warn it; process.exit 1

# Use the [OptionParser](#optparse) to extract all options from `process.argv`.
o = require(\./optparse) do
  compile     : 'compile to JavaScript and save as .js files'
  interactive : 'run an interactive Coco REPL'
  output      :['set the directory for compiled JavaScript' \DIR]
  watch       : 'watch scripts for changes, and recompile'
  print       : 'print the compiled JavaScript to stdout'
  stdin       : 'listen for and compile scripts over stdin'
  eval        : 'compile a string from the command line'
  require     :['require a library before executing your script' \FILE+]
  bare        : 'compile without the top-level function wrapper'
  lex         : 'print the tokens the lexer produces'
  tokens      : 'print the tokens the rewriter produces'
  nodes       : 'print the parse tree the parser produces'
  nodejs      :['pass options through to the "node" binary' \ARGS+ \-N]
  version     : 'display Coco version'
  help        : 'display this help message'

o.run = not (o.compile or o.print)
o.print   ||= o.eval or o.stdin and o.compile
o.compile ||= o.output
sources = o.$args

# Run `coco` by parsing passed options and determining what action to take.
# Many flags cause us to divert before compiling anything. Flags passed after
# `--` will be passed verbatim to your script as arguments in `process.argv`.
exports.run = ->
  return forkNode()                   if o.nodejs
  return version()                    if o.version
  return help()                       if o.help
  require.paths.push process.cwd()
  return repl()                       if o.interactive
  return compileStdin()               if o.stdin
  return compileScript '', sources.0  if o.eval
  return (version(); help(); repl())  unless sources.length
  process.argv.splice 2 9e9,
    ...(if o.run then sources.splice 1 else []).concat o.$literals
  compileScripts()

# Asynchronously read in each Coco script in a list of source files and
# compile them. If a directory is passed, recursively compile all
# _.co_ files in it and all subdirectories.
compileScripts = ->
  sources.forEach (source) ->
    path.exists source, (yes) ->
      yes or die "No such file or directory: #{source}"
      walk source, path.normalize(source), true
  function walk (source, base, top) ->
    fs.stat source, (e, stats) ->
      if stats.isDirectory()
        fs.readdir source, (e, files) ->
          files.forEach -> walk path.join(source, it), base
      else if top or path.extname(source).toLowerCase() is \.co
        fs.readFile source, (e, buf) ->
          compileScript source, buf.toString(), base
        watch source, base if o.watch
      void
  void

# Compile a single source script, containing the given code, according to the
# requested options.
compileScript = (file, input, base) ->
  options = fileName: file, bare: o.bare
  if o.require
    for req of o.require
      require if req.0 is \. then fs.realpathSync req else req
  try
    Coco.emit \compile, t = {file, input, options}
    switch
    case o.lex or o.tokens then printTokens Coco.tokens input, rewrite: !o.lex
    case o.nodes           then say Coco.nodes(input).toString().trim()
    case o.run             then Coco.run input, options
    default
      t.output = Coco.compile input, options
      Coco.emit \success, t
      switch
      case o.print   then say t.output.trim()
      case o.compile then writeJs file, t.output, base
  catch e
    Coco.emit \failure, e, t
    unless Coco.listeners(\failure).length
      (if o.watch then warn else die) e?.stack || e

# Attach the appropriate listeners to compile scripts incoming over **stdin**,
# and write them back to **stdout**.
compileStdin = ->
  code  = ''
  stdin = process.openStdin()
  stdin.on \data, -> code += it if it
  stdin.on \end , -> compileScript null, code

# Watch a source Coco file using `fs.watchFile`, recompiling it every
# time the file is updated. May be used in combination with other options,
# such as `--nodes` or `--print`.
watch = (source, base) ->
  fs.watchFile source, {+persistent, interval: 500ms}, (curr, prev) ->
    return if curr.size is prev.size and +curr.mtime is +prev.mtime
    fs.readFile source, (err, code) ->
      die err.stack || err if err
      compileScript source, code.toString(), base

# Write out a JavaScript source file with the compiled code. By default, files
# are written out in `cwd` as `.js` files with the same name, but the output
# directory can be customized with `--output`.
writeJs = (source, js, base) ->
  filename = path.basename(source, path.extname source) + \.js
  srcDir   = path.dirname source
  dir      = if o.output
  then path.join that, srcDir.slice (if base is \. then 0 else base.length)
  else srcDir
  jsPath   = path.join dir, filename
  compile  = ->
    fs.writeFile jsPath, js || ' ', (err) ->
      if err
        warn err
      else if o.compile and o.watch
        (try require(\util).log catch then say) "Compiled #{source}"
  path.exists dir, (exists) ->
    if exists
    then compile()
    else require(\child_process).exec "mkdir -p #{dir}", compile

# Pretty-print a stream of tokens.
printTokens = (tokens) ->
  lines = []
  for [tag, val, lno] of tokens
    tag += \: + val unless tag is val += ''
    (lines[lno] ||= []).push tag
  say(if l then l.join(' ').replace /\n/g \\\n else '') for l of lines

# A simple Read-Eval-Print-Loop. Compiles one line at a time to JavaScript
# and evaluates it. Good for simple tests or poking around the **node.js** API.
repl = ->
  global.__defineGetter__ \quit, -> process.exit 0
  repl = require(\readline).createInterface stdin = process.openStdin()
  stdin.on \data, repl&.write
  repl.on \close, stdin&.destroy
  repl.on \line, ->
    try
      global._ = Coco.eval "#{it}", {+bare, +globals, fileName: \repl}
      console.dir _ unless _ is void
    catch e then say e
    repl.prompt()
  process.on \uncaughtException, -> say \\n + (it?.stack or it)
  repl.setPrompt 'coco> '
  repl.prompt()

# Start up a new __node.js__ instance with the arguments in `--nodejs` passed
# to it, preserving the other options.
forkNode = ->
  args = process.argv.slice 1; i = 0
  args.splice i--, 2 if arg of <[ -N --nodejs ]> while arg = args[++i]
  require(\child_process).spawn do
    process.execPath
    o.nodejs.join(' ').trim().split(/\s+/).concat args
    cwd: process.cwd(), env: process.env, customFds: [0 to 2]

# Print the `--help` message.
help = -> say """
  Usage: coco [options] [files]

  Available options:
  #{o}
"""

# Print the `--version` message.
version = -> say "Coco #{Coco.VERSION}"
