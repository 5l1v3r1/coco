# The Coco Lexer. Uses a series of token-matching regexes to attempt
# matches against the beginning of the source code. When a match is found,
# a token is produced, we consume the match, and start again.
# Tokens are in the form:
#
#     ['TAG', 'value', lineNumber = 0]
#
# which is a format that can be fed directly into
# [Jison](http://github.com/zaach/jison) generated [parser](../lib/parser.js).

# The Lexer Object
# ----------------
# Reads a stream of Coco code and divvies it up into tagged tokens.
# Some potential ambiguity in the grammar has been avoided by
# pushing some extra smarts into Lexer.

# Depends on [Rewriter](#rewriter).
{rewrite, able} = require \./rewriter

exports import
  # `lex` is Lexer's one and only public method.
  lex: (
    # Coco source to be parsed into an array of tokens.
    code
    #  - `.raw`  <br> Suppresses [rewriting](#rewriter) if truthy.
    #  - `.line` <br> Specifies the starting line. Defaults to `0`.
    options
  # `tokenize` is Lexer's main method. Scan by attempting to match tokens
  # one at a time, using a regular expression anchored at the start of the
  # remaining code, or a custom recursive token-matching method
  # (for interpolations). When the next token has been recorded,
  # we move forward within the code past the token, and begin again.
  ) -> exports{}tokenize code||'' options||{}
  tokenize: (code, o) ->
    @inter or code.=replace /\r/g ''
    # Prepend a newline to handle leading INDENT.
    code = \\n + code
    # Stream of parsed tokens,
    # initialized with a TERMINATOR token to ensure `@last` always exists.
    @tokens = [@last = [\TERMINATOR \\n 0]]
    # The current line. Starts from -1 to setoff the prepended newline.
    @line = ~-o.line
    # The current indentation level.
    @dent = 0
    # The stack of all current indentation levels.
    @dents = []
    # The stack for pairing tokens.
    @closes = []
    # Check the first character of current `code`, then call appropriate
    # tokenizers based on it. Each tokenizing method is responsible for
    # returning the number of characters it has consumed.
    while code.=slice i
      switch code.charAt 0
      case ' '   then i = @doSpace     code
      case \\n   then i = @doLine      code
      case \\    then i = @doBackslash code
      case \' \" then i = @doString    code
      case \<
        i = if \[ is code.charAt 1 then @doWords code else @doLiteral code
      case \/
        switch code.charAt 1
        case \* then i = @doComment code
        case \/ then i = @doHeregex code
        default      i = @doRegex code or @doLiteral code
      case \` then i = @doJS code
      default i = @doIdentifier code or @doNumber code or
                  @doLiteral    code or @doSpace  code
    # Dispose initial TERMINATOR.
    @tokens.shift()
    # Close up all remaining open blocks.
    @dedent @dent
    @carp "missing `#{that}`" if @closes.pop()
    if @inter then @rest? or @carp 'unterminated interpolation' else @newline()
    # Rewrite the token stream unless explicitly asked not to.
    o.raw or rewrite @tokens
    @tokens

  #### Tokenizers

  # Matches an identifying literal: variables, keywords, accessors, etc.
  doIdentifier: ->
    return 0 unless match = ID.exec it
    [[] id, colon] = match; {last} = this
    # `id:_` `_.id` `@id`
    if colon or last.0 is \DOT or @adi()
      tag = \ID
      if id of JS_KEYWORDS or id of RESERVED
        (id = new String id)reserved = true
    # keywords
    else switch id
    case <[ this eval ]> then return @token(\LITERAL id, true)length
    case <[ true false null void arguments debugger ]> then tag = \LITERAL
    case \new \do \typeof \delete then tag = \UNARY
    case \return \throw           then tag = \HURL
    case \break  \continue        then tag = \JUMP
    case \catch \function then id = ''
    case \import          then id = \<<<
    case \for  then @seenFor = true; fallthrough
    case \then then @seenFrom = @seenTo = false
    case <[ in of instanceof ]>
      if id is not \instanceof and @seenFor
        tag = \FOR + id.toUpperCase(); @seenFor = false
        # FOROF holds the index variable.
        if id is \of
          id = ''; @seenTo = true
          if last.0 is \ID then switch @tokens[*-2]0
          case \,    then @tokens.splice -2 1; fallthrough
          case \} \] then @tokens.pop(); id = last.1
        break
      if last.1 is \!
        @tokens.pop()
        id = \! + id
      tag = \RELATION
    case <[ and or is not ]>
      if id is \not and last.alias and last.1 is \===
      then last.1 = \!==
      else @token ...COCO_ALIASES[id]; @last.alias = true
      return id.length
    case \unless then tag = \IF
    case \until  then tag = \WHILE
    default
      break if id of JS_KEYWORDS
      @carp "reserved word \"#{id}\"" if id of RESERVED
      if not last.1 and last.0 of <[ CATCH FUNCTION LABEL ]>
        return (last.1 = id)length
      tag = \ID
      # contextual keywords (reserved only in specific places)
      switch id
      case \own then tag = \OWN if last.0 is \FOR
      case \all then if last.1 is \<<<
        last.1 += \<
        return 3
      case \from then if @tokens[*-2]?0 is \FOR
        @<<<{-seenFor, +seenFrom}
        tag = \FROM
      case \ever then if last.0 is \FOR
        @<<<{-seenFor}
        tag = \EVER
      case \to \til
        if @seenFrom
          @<<<{-seenFrom, +seenTo}
          tag = \TO
        else if last.0 is \STRNUM and not isNaN last.1
          last <<< 0:\RANGE op:id
          return id.length
      case \by
        if @seenTo
          @<<<{-seenTo}
          tag = \BY
        else if last.0 is \RANGE and last.to
          last.by = true
          return 2
    @token tag || match.1.toUpperCase(), id
    @token \: \: if colon
    match.0.length

  # Matches a number, including decimal, hex and exponential notation.
  doNumber: ->
    return 0 unless match = NUMBER.exec it
    num = (match.3 or match.0)replace NUMBER_OMIT, ''; {last} = this
    switch num.charAt 0
    # `x.0` => `x[0]`
    case \. then if @adi()
      @token \STRNUM num.slice(1), true
      return match.0.length
    case \0 then if num.charAt(1) not of ['' \. \x \X]
      @carp "deprecated octal literal #{num}"
    if radix = match.1
      num = parseInt rnum = match.2.replace(NUMBER_OMIT, ''), radix
      if isNaN num or num is parseInt rnum.slice(0 -1), radix
        @carp "invalid number #{rnum} in base #{radix}"
    unless last.spaced
      if sign = last.0 is \+-
        num = last.1 + num
        @tokens.pop()
        @last = last = @tokens[*-1]
      # `@0.0` => `@[0][0]`
      else if match.3 and ~(dotpos = num.indexOf \.) and able @tokens
        match.0 = num.=slice 0 dotpos
    if last.0 is \RANGE and (not last.to or last.by is true)
    then last[if last.to then \by else \to] = num
    else if sign then @token \STRNUM num else @strnum num
    match.0.length

  # Matches a string literal.
  doString: ->
    q = it.charAt 0
    if q is it.charAt 1
      return if q is it.charAt 2 then @doHeredoc it, q else @strnum q+q; 2
    if q is \"
      parts = @interpolate it, q
      @addInterpolated parts, unlines
      return 1 + parts.size
    [str] = SIMPLESTR.exec it or @carp 'unterminated string'
    @strnum unlines string q, str.slice 1 -1
    @countLines(str)length

  # Matches heredocs, adjusting indentation to the correct level,
  # as they ignore indentation to the left.
  doHeredoc: (it, q) ->
    if q is \'
      ~(end = it.indexOf q+q+q, 3) or @carp 'unterminated heredoc'
      raw = it.slice 3 end
      # Remove trailing indent.
      doc = raw.replace LASTDENT, ''
      @strnum enlines string q, lchomp detab doc, heretabs doc
      return @countLines(raw)length + 6
    parts = @interpolate it, q+q+q
    tabs  = heretabs it.slice(3 parts.size)replace LASTDENT, ''
    for t, i of parts then if t.0 is \S
      t.1.=replace LASTDENT, '' if i+1 is parts.length
      t.1 = detab t.1, tabs
      t.1 = lchomp t.1 if i is 0
    @addInterpolated parts, enlines
    3 + parts.size

  # Matches block comments.
  doComment: ->
    text = if ~end = it.indexOf \*/ 2 then it.slice 0 end+2 else it + \*/
    if @last.0 of <[ TERMINATOR INDENT THEN ]>
    then @token \COMMENT detab text, @dent; @token \TERMINATOR \\n
    else @last.spaced = true
    @countLines(text)length

  # Matches embedded JavaScript.
  doJS: ->
    [js] = JSTOKEN.exec it or @carp 'unterminated JS literal'
    @js detab js.slice(1 -1), @dent
    @countLines(js)length

  # Matches a regular expression literal aka _regex_,
  # disambiguating from division operators.
  doRegex: ->
    # To coexist with implicit call and ACI,
    # disallow leading space or equal sign when applicable.
    #
    #     f /re/ 9 /ex/   # f(/re/, 9, /ex/)
    #     a /= b / c / d  # division
    #
    if able @tokens
      return 0 if not @last.spaced or /^\/[ =]/test it
               or not match = REGEX.exec it
    else
      match = REGEX.exec it or @carp 'unterminated regex'
    @regex match.1, match.2
    match.0.length

  # Matches a multiline and extended regex literal.
  doHeregex: ->
    {tokens, last} = this
    parts = @interpolate it, \//
    rest  = it.slice 2 + parts.size
    flag  = /^[imgy]{0,4}/exec(rest)0
    if parts.1
      tokens.push [\ID \RegExp last.2] [\CALL( '' last.2]
      if \? is rest.charAt 0
        ++parts.size
        for t, i of parts by -1 then if t.0 is \TOKENS
          dynaflag = parts.splice(i, 1).0.1
          break
      for t, i of parts
        if t.0 is \TOKENS
          tokens.push ...t.1
        else
          val = t.1.replace HEREGEX_OMIT, ''
          continue if not val and bs
          tokens.push t <<< [\STRNUM  string \' val.replace bs||=/\\/g \\\\]
        tokens.push [\+- \+ tokens[*-1]2]
      tokens.pop()
      if flag or dynaflag
        @token \, \,
        if dynaflag then tokens.push ...dynaflag else @token \STRNUM "'#{flag}'"
      @token \)CALL ''
    else @regex parts.0.1.replace(HEREGEX_OMIT, '')replace(/\//g \\\/), flag
    2 + parts.size + flag.length

  # Matches a word literal, or ignores a sequence of whitespaces.
  doBackslash: ->
    [input, word] = BSTOKEN.exec it
    if word then @strnum string \' word else @countLines input
    input.length

  # Matches a words literal, a syntax sugar for a list of strings.
  doWords: ->
    @carp 'unterminated words' unless ~end = it.indexOf \]> 2
    @adi()
    @token \[ \[
    {tokens, line} = this
    for row of it.slice(2 end)split \\n
      if row.match WS||=/\S+/g then for word of that
        tokens.push [\STRNUM; string \' word; line] <<< {+spaced}
      ++line
    @line = line - 1
    @token \] \]
    end + 2

  # Matches newlines and {in,de}dents, determining which is which.
  # If we can detect that the current line is continued onto the next line,
  # then the newline is suppressed:
  #
  #     elements
  #     .map -> ...
  #     .get()
  #
  # Keeps track of the level of indentation, because a single dedent
  # can close multiple indents, so we need to know how far in we happen to be.
  doLine: ->
    [input, tabs] = MULTIDENT.exec it
    @countLines input
    {last} = this; {length} = input
    last <<< {+eol, +spaced}
    return length if length >= it.length
    if 0 > delta = tabs.length - @dent
      @dedent -delta
      LINE_CONTINUER.test it or @newline()
    else
      if tabs and (@emender ||= //[^#{ tabs.charAt 0 }]//)exec tabs
        @carp "contaminated indent #{ escape that }"
      if (tag = last.0) is \ASSIGN and ''+last.1 not of <[ = := += ]>
      or tag of <[ +- DOT LOGIC MATH COMPARE RELATION SHIFT BITWISE ]>
        return length
      cont = LINE_CONTINUER.test it
      if delta then @indent delta, cont else cont or @newline()
    @seenFrom = @seenTo = false
    length

  # Consumes non-newline whitespaces and/or a line comment.
  doSpace: ->
    # Tag the previous token as being `.spaced`,
    # because there are cases where it makes a difference.
    (match = SPACE.exec it) and (@last.spaced = true; match.0.length)

  # We treat all other single characters as a token. e.g.: `( ) , . !`
  # Multi-character operators are also literal tokens, so that Jison can assign
  # the proper order of operations. There are some symbols that we tag specially
  # here. `;` and newlines are both treated as a TERMINATOR, we distinguish
  # parentheses that indicate a method call from regular parentheses, and so on.
  doLiteral: ->
    return 0 unless sym = SYMBOL.exec it
    switch tag = val = sym.=0
    case <[ . ?. ]>                    then tag = \DOT
    case <[ + -  ]>                    then tag = \+-
    case <[ === !== < > <= >= == != ]> then tag = \COMPARE
    case <[ && || ]>                   then tag = \LOGIC
    case \?                            then tag = \LOGIC if @last.spaced
    case <[ / % ** ]>                  then tag = \MATH
    case <[ ++  -- ]>                  then tag = \CREMENT
    case <[ <<<  <<<< ]>               then tag = \IMPORT
    case <[ << >> >>> ]>               then tag = \SHIFT
    case <[  &  |  ^  ]>               then tag = \BITWISE
    case \;                            then tag = \TERMINATOR
    case \( \?(
      @closes.push \)
      tag = \CALL( if val is \?( or @able true
    case \[    then @closes.push \]; @adi()
    case \] \) then @pair val
    case \{
      @closes.push \}
      @token \CLONE '' if @able()
    case \}
      if @inter and val is not @closes[*-1]
        @rest = it.slice 1
        return 9e9
      @pair val
    case \: then if @last.0 not of <[ ID STRNUM ) ]>
      tag = \LABEL; val = ''
    case <[ = := += -= *= /= %= &= ^= |= <<= >>= >>>= **= ]>
      tag = \ASSIGN
      if @last.0 is \LOGIC
        (val = new String val)logic = @tokens.pop()1
      else if @last.1 of <[ . ?. ]> or @last.0 is \? and @adi()
        @last.1 += val
        return val.length
    case \*
      if @last.0 of <[ TERMINATOR INDENT THEN ]> and /^.[^\n\S]*(?=\S)/exec it
        @tokens.push [\{ \{ @line] [\} \} @line] [\ASSIGN \= @line]
        @indent val = that.0.length
        return val
      tag = if able @tokens then \MATH else \STRNUM
    case \@
      if @last.1 of <[ . ?. ]> or @adi()
      then @last.1 += val
      else @token \LITERAL \this true
      return 1
    case \!
      return (@last.1 = \classof; 1) if not @last.spaced and @last.1 is \typeof
      fallthrough
    case \~
      return (@last.1 += val; 1) if @last.1 of <[ . ?. ]> or @adi()
      tag = \UNARY
    case \~> then tag = \->
    case \<~ then tag = \<-; fallthrough
    case \<-
      break if @last.1 is \)
      {tokens} = this; i = tokens.length
      continue until tokens[--i]0 of <[ TERMINATOR INDENT THEN ( ]>
      tokens.splice i+1 0 [\PARAM( '' tokens[i]2]
      @token \)PARAM ''
    case \@@ then tag = \LITERAL; val = \arguments
    case \:: then i = \prototype; fallthrough
    case \.. then @adi(); tag = \ID; val = i || \constructor
    default if \( is val.charAt 0
      @token \CALL( \(; tag = \)CALL; val = \)
    @token tag, val
    sym.length

  #### Token Manipulators

  # Records an INDENT.
  indent: (delta, dummy) ->
    @dent += delta
    @dents.push if dummy then ''+delta else @token \INDENT delta
    @closes.push \DEDENT
    void

  # Records a DEDENT, or DEDENTs if there are multiple matching INDENTs.
  dedent: (debt) ->
    @dent -= debt
    while debt > 0 and dent = @dents.pop()
      if debt < dent and not @inter
        @carp "unmatched dedent (#{debt} for #{dent})"
      debt -= if typeof dent is \number then @token \DEDENT dent else dent
      @pair \DEDENT
    void

  # Generates a newline token. Consecutive newlines get merged together.
  newline: -> @token \TERMINATOR \\n unless @last.1 is \\n

  # Expands variables and expressions inside double-quoted strings or heregexes
  # using Ruby-like notation for substitution of arbitrary expressions.
  #
  #     "Hello #{name.capitalize()}."
  #
  # Will recursively create a new lexer for each interpolation,
  # tokenizing the contents and merging them into the token stream.
  interpolate: (str, end) ->
    parts = []; end0 = end.charAt 0; pos = 0; i = -1
    str.=slice end.length
    while ch = str.charAt ++i
      if ch is \\ then ++i; continue
      if ch is end0
        continue unless end is str.slice i, i + end.length
        parts.push [\S; @countLines str.slice 0 i; @line]
        return parts <<< size: pos + i + end.length
      continue unless ch is \# and \{ is str.charAt i+1
      # `"#{0}#{1}"` => `0 + "" + 1`
      if i or nested and not s?
        s = parts.push [\S; @countLines str.slice 0 i; @line]
      clone  = exports{+inter}
      nested = clone.tokenize str.slice(i+2), {@line, +raw}
      nested.shift() while nested.0?0 is \TERMINATOR
      @countLines str.slice i, delta = str.length - clone.rest.length
      pos += delta; str = clone.rest; i = -1
      if nested.length
        if that > 1
          nested.unshift [\( \( nested[0]2]
          nested.push    [\) \) @line]
        parts.push [\TOKENS nested]
    @carp "missing `#{end}`"; void

  # Merges `@interpolate`d strings.
  addInterpolated: (parts, nlines) ->
    return @strnum nlines string \" parts.0.1 unless parts.1
    @adi()
    {tokens, last} = this
    tokens.push [\( \" last.2]
    for t, i of parts
      if t.0 is \TOKENS
        tokens.push ...t.1
      else
        continue if i > 1 and not t.1
        tokens.push [\STRNUM; nlines string \" t.1; t.2]
      tokens.push [\+- \+ tokens[*-1]2]
    tokens.pop()
    @token \) '' last.0 is \DOT

  #### Helpers

  # Adds a token to the results,
  # taking note of the line number and returning `value`.
  token: (tag, value, callable) ->
    @tokens.push @last = [tag, value, @line]
    @last.callable = true if callable
    value

  # Records a string/number token, supplying implicit dot if applicable.
  strnum: -> @token \STRNUM it, @adi() || @last.0 is \DOT; void

  # Records a literal token flagged embedded.
  js: -> @token \LITERAL new String(it) <<< {+js}

  # Records a regex token.
  regex: (body, flag) ->
    try RegExp body catch @carp e.message
    @js "/#{ body or '(?:)' }/#{ flag and flag.replace /(.)(?=.*\1)/g '' }"

  # Increments `@line` by the number of newlines in a string.
  countLines: -> ++@line while pos = 1 + it.indexOf \\n pos; it

  # Checks if the last token is
  #
  # - `f()`: `call`able via explicit parentheses
  # - `x''`: indexable via implicit brackets
  able: (call) -> not @last.spaced and able @tokens, null call

  # Supplies an implicit DOT if applicable.
  adi: ->
    not @last.spaced and if @last.0 is \?
    then @last <<< [\DOT \?.]
    else able @tokens and @token \DOT \.

  # Pairs up a closing token.
  pair: ->
    unless it is wanted = @closes[*-1]
      # Auto-close DEDENT to support syntax like:
      #
      #     [ a
      #       b ]
      #
      @carp "unmatched `#{it}`" unless \DEDENT is wanted and it is @closes[*-2]
      @dedent @dents[*-1]
    @closes.pop()

  # Throws a syntax error with the current line number.
  carp: -> throw SyntaxError "#{it} on line #{ @line + 1 }"

#### String Helpers

# Constructs a string token by (un)escaping quotes and newlines.
string = let do
  escaped = /\\(?:[\\0-7bfnrtuvx]|[^\n\S]|([\w\W]))?/g
  descape = ($0, $1) -> $1 or if $0 is \\ then \\\\ else $0
  qs = "'":/'/g '"':/"/g
then (q, body) -> q + body.replace(escaped, descape)replace(qs[q], \\\$&) + q

# Detects the minimum indent count for a heredoc, ignoring empty lines.
function heretabs(doc)
  dent = 0/0
  dent = len unless dent <= len = that.0.length - 1 while TABS.exec doc
  dent
TABS = /\n[^\n\S]*(?!$)/mg

# Erases all external indentations up to specified length.
function detab(str, len)
  if len then str.replace detab[len]||=//\n[^\n\S]{1,#{len}}//g \\n else str

# Erases all newlines and indentations.
function unlines -> it.replace INDENTS, ''
INDENTS = /\n[^\n\S]*/g

# Keeps newlines by escaping them.
function enlines -> it.replace LINES, \\\n
LINES = /\n/g

# Deletes the first character if newline.
function lchomp -> it.slice 1 + it.lastIndexOf \\n 0

#### Constants

##### Keywords

# Keywords that Coco shares in common with JavaScript.
JS_KEYWORDS = <[
  true false null this void super return throw break continue
  if else for while switch case default try catch finally class extends
  new do delete typeof in instanceof import function let with debugger
]>

# Coco-only alias keywords.
COCO_ALIASES  = not: <[ UNARY !  ]>, is: <[ COMPARE === ]>
              , and: <[ LOGIC && ]>, or: <[ LOGIC   ||  ]>

# The list of keywords that are reserved by JavaScript, but not used.
# We throw a syntax error for these to avoid runtime errors.
RESERVED = <[
  var  const enum export
  implements interface package private protected public static yield
]>

##### Regexes

ID = // ^
  ( [$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]* )
  ( [^\n\S]* : (?![:=]) )?  # Is this a property name?
//
SYMBOL = // ^ (?
: [-+*/%&|^:<>]=              # compound assign / comparison
| \.{1,3}                     # dot / `constructor` / splat/placeholder/yada*3
| ([+&|:])\1                  # increment / logic / `prototype`
| \([^\n\S]*\)                # call
| -[->]                       # decrement / function
| [!=]==?                     # equality
| \?[.(]                      # soak access/call
| ~[.>]                       # bind access/function
| <(?: <(?:=|<{0,2}) | [-~])  # left shift / import / backcall
| >>>?=?                      # rite shift
| \*\*=?                      # pow
| @@                          # `arguments`
| [^\s#]
) //
SPACE     = /^(?=.)[^\n\S]*(?:#.*)?/
MULTIDENT = /^(?:\s*#.*)*(?:\n([^\n\S]*))+/
SIMPLESTR = /^'[^\\']*(?:\\[\s\S][^\\']*)*'/
JSTOKEN   = /^`[^\\`]*(?:\\[\s\S][^\\`]*)*`/
BSTOKEN   = /^\\(?:(\S[^\s,;)}\]]*)|\s+)/

NUMBER = // ^ (?
: 0x[\da-f][\da-f_]*                                              # hex
| ([2-9]|[12]\d|3[0-6]) r ([\da-z][\da-z_]*)                      # 2-36 base
| ( (?:\d[\d_]*(?:\.\d[\d_]*)?|\.\d[\d_]*) (?:e[+-]?\d[\d_]*)? )  # decimal
  [a-z_]*  # decimal comment
) //i
NUMBER_OMIT = /_+/g

REGEX = //
  ^ /(
  [^ [ / \n \\ ]* (?:                        # every other thing
    (?: \\.                                  # anything escaped
      | \[ [^\]\n\\]* (?:\\.[^\]\n\\]*)* \]  # or character class
    ) [^ [ / \n \\ ]*                        # every other thing again
  )* )/ ([imgy]{0,4})
//
HEREGEX_OMIT  = /\s+(?:#.*)?/g

LASTDENT = /\n[^\n\S]*$/

LINE_CONTINUER = // ^ \s* (?:
  [,?&|^] | \.(?![.\d]) | (?:and|or)(?![$\w\x7f-\uffff]|[^\n\S]*:(?![:=]))
) //
