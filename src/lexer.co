# The Coco Lexer. Uses a series of token-matching regexes to attempt
# matches against the beginning of the source code. When a match is found,
# a token is produced, we consume the match, and start again.
# Tokens are in the form:
#
#     ['TAG', 'value', lineNumber = 0]
#
# which is a format that can be fed directly into
# [Jison](http://github.com/zaach/jison) generated [parser](../lib/parser.js).

# The Lexer Object
# ----------------
# Reads a stream of Coco code and divvies it up into tagged tokens.
# Some potential ambiguity in the grammar has been avoided by
# pushing some extra smarts into Lexer.

# Depends on [Rewriter](#rewriter).
{rewrite, able} = require \./rewriter

exports import
  # `lex` is Lexer's one and only public method.
  lex: (
    # Coco source to be parsed into an array of tokens.
    code
    #  - `.raw`  <br> Suppresses [rewriting](#rewriter) if truthy.
    #  - `.line` <br> Specifies the starting line. Defaults to `0`.
    options
  # `tokenize` is Lexer's main method. Scan by attempting to match tokens
  # one at a time, using a regular expression anchored at the start of the
  # remaining code, or a custom recursive token-matching method
  # (for interpolations). When the next token has been recorded,
  # we move forward within the code past the token, and begin again.
  ) -> exports{}tokenize code || '', options || {}
  tokenize: (code, o) ->
    # Prepend a newline to handle leading INDENT.
    code = \\n + code.replace /\r/g ''
    # Stream of parsed tokens,
    # initialized with a TERMINATOR token to ensure `@last` always exists.
    @tokens = [@last = [\TERMINATOR \\n 0]]
    # The current line. Starts from -1 to setoff the prepended newline.
    @line = ~-o.line
    # The current indentation level.
    @indent = 0
    # The stack of all current indentation levels.
    @indents = []
    # Check the first character of current `code`, then call appropriate
    # tokenizers based on it. Each tokenizing method is responsible for
    # returning the number of characters it has consumed.
    while code.=slice i
      switch code.charAt 0
      case ' ' then i = @doSpace     code
      case \\n then i = @doLine      code
      case \\  then i = @doBackslash code
      case \'  then i = @doHeredoc code, \' or @doString code
      case \"  then i = @doHeredoc code, \" or @doString code, 2q
      case \<
        i = @[if \[ is code.charAt 1 then \doWords else \doLiteral] code
      case \/
        i = if \* is code.charAt 1
        then @doComment code
        else if \// is code.substr 1 2
        then @doHeregex code
        else @doRegex code or @doLiteral code
      case \` then i = @doJS code
      default i = @doIdentifier code or @doNumber code or
                  @doLiteral    code or @doSpace  code
    # Dispose initial TERMINATOR.
    @tokens.shift()
    # Close up all remaining open blocks.
    @dedent @indent
    o.inter or @newline()
    # Rewrite the token stream unless explicitly asked not to.
    o.raw or rewrite @tokens
    @tokens

  #### Tokenizers

  # Matches an identifying literal: variables, keywords, accessors, etc.
  # Check to ensure that JavaScript reserved words aren't being used as
  # identifiers.
  doIdentifier: ->
    return 0 unless match = IDENTIFIER.exec it
    {last} = this
    switch id = match.1
    case \from
      break unless @tokens[*-2]?.0 is \FOR
      @<<<{-seenFor, +seenFrom}
      return @token(\FROM id)length
    case \ever
      break unless last.0 is \FOR
      @seenFor = false
      return @token(\EVER id)length
    case <[ to til ]>
      if @seenFrom
        @<<<{-seenFrom, +seenTo}
        return @token(\TO id)length
      else if last.0 is \STRNUM and /^[-+\d.]/test last.1
        last <<< 0:\RANGE op:id
        return id.length
    case \by
      if @seenTo
        @seenTo = false
        return @token(\BY id)length
      else if last.0 is \RANGE and last.to
        last.by = true
        return id.length
    case \all
      break unless last.0 is \IMPORT and last.1 is \<<<
      last.1 += \<
      return id.length
    tag = \IDENTIFIER; colon = match.2
    if colon or last.0 is \DOT or @adi()
      if id of JS_KEYWORDS or id of RESERVED
        (id = new String id)reserved = true
    else if id of <[ this eval ]>
      @token \LITERAL id, true
      return id.length
    else if id of JS_KEYWORDS or id of <[ then of arguments ]>
      switch tag = id.toUpperCase()
      case \FOR  then @seenFor = true; fallthrough
      case \THEN then @seenFrom = @seenTo = false
      case \IMPORT              then id = \<<<
      case <[ CATCH FUNCTION ]> then id = ''
      case <[ TRUE FALSE NULL VOID ARGUMENTS DEBUGGER ]> then tag = \LITERAL
      case <[ NEW DO TYPEOF DELETE                    ]> then tag = \UNARY
      case <[ BREAK CONTINUE                          ]> then tag = \JUMP
      case <[ IN OF INSTANCEOF ]>
        if tag is not \INSTANCEOF and @seenFor
          if tag is \OF
            id = ''; @seenTo = true
            if last.0 is \IDENTIFIER
              switch @tokens[*-2]0
              case \,        then @tokens.splice -2 1; fallthrough
              case <[ } ] ]> then @tokens.pop(); id = last.1
          @seenFor = false
          tag = \FOR + tag
          break
        if last.1 is \!
          @tokens.pop()
          id = \! + id
        tag = \RELATION
    else switch id
    case <[ and or is not ]>
      if id is \not and last.alias and last.1 is \===
        last.1 = \!==
        return id.length
      @token ...COCO_ALIASES[id]; @last.alias = true
      return id.length
    case \unless then tag = \IF
    case \until  then tag = \WHILE
    default
      @carp "reserved word \"#{id}\"" if id of RESERVED
      if not last.1 and last.0 of <[ CATCH FUNCTION LABEL ]>
        return (last.1 = id)length
      tag = \OWN if id is \own and last.0 is \FOR
    @token tag, id
    @token \: \: if colon
    match.0.length

  # Matches a number, including decimal, hex and exponential notation.
  doNumber: ->
    return 0 unless match = NUMBER.exec it
    num = match.3 or match.0; {last} = this
    switch num.charAt 0
    case \. then if @adi()
      @token \STRNUM num.slice(1), true
      return match.0.length
    case \0 then if num.charAt(1) not of ['' \. \x \X]
      @carp "deprecated octal literal #{num}"
    if radix = match.1
      num = parseInt rnum = match.2, radix
      if isNaN num or num is parseInt rnum.slice(0 -1), radix
        @carp "invalid number #{rnum} in base #{radix}"
    unless last.spaced
      if sign = last.0 is \+-
        num = last.1 + num
        @tokens.pop()
        @last = last = @tokens[*-1]
      # `@0.0` => `@[0][0]`
      else if match.3 and ~(dotpos = num.indexOf \.) and able @tokens
        match.0 = num.=slice 0 dotpos
    if last.0 is \RANGE and (not last.to or last.by is true)
    then last[if last.to then \by else \to] = num
    else if sign then @token \STRNUM num else @strnum num
    match.0.length

  # Matches a normal string literal.
  doString: (code, double) ->
    if double
      str = @balancedString code, \"
      if 0 < str.indexOf \#{ 1
        @interpolate str.slice(1 -1), unlines
        return str.length
    else
      [str] = SIMPLESTR.exec code or @carp 'unterminated string'
    @strnum unlines str
    @countLines(str)length

  # Matches heredocs, adjusting indentation to the correct level, as heredocs
  # preserve whitespace, but ignore indentation to the left.
  doHeredoc: (code, q) ->
    return 0 unless code.slice(1 3) is q+q and ~end = code.indexOf q+q+q, 3
    txt = code.slice 3 end
    lnl = txt is not doc = txt.replace /\n[^\n\S]*$/ ''
    if ~doc.indexOf \\n
      tabs = /\n[^\n\S]*(?!$)/mg  # non-empty bol
      dent = 0/0
      dent = len unless dent <= len = that.0.length - 1 while tabs.exec doc
      doc  = detab doc, dent
      if \\n is doc.charAt 0
        doc.=slice 1
        ++@line
    if q is \" and ~doc.indexOf \#{
      @interpolate doc, enlines
    else
      @strnum enlines string doc, q
      @countLines doc
    ++@line if lnl
    txt.length + 6

  # Matches block comments.
  doComment: ->
    text = if ~end = it.indexOf \*/ 2 then it.slice 0 end+2 else it + \*/
    if @last.0 of <[ TERMINATOR INDENT THEN ]>
    then @token \COMMENT detab text, @indent; @token \TERMINATOR \\n
    else @last.spaced = true
    @countLines(text)length

  # Matches embedded JavaScript.
  doJS: ->
    [js] = JSTOKEN.exec it or @carp 'unterminated JS literal'
    @js detab js.slice(1 -1), @indent
    @countLines(js)length

  # Matches a regular expression literal, aka regex.
  doRegex: ->
    # Distinguish from division operator.
    if able @tokens, null
      return 0 unless @last.spaced and re = REGEX.exec it
    # Must be a regex when the last token is unindexable.
    else
      re = REGEX.exec it or @carp 'unterminated regex'
    @js if re.=0 is \// then '/(?:)/' else re
    re.length

  # Matches a multiline and extended regex literal.
  doHeregex: ->
    [heregex, body, flags] = HEREGEX.exec it or @carp 'unterminated heregex'
    flags = '' if dynaflag = flags is \?
    if 0 > body.indexOf \#{
      body.=replace(HEREGEX_OMIT, '')replace(/\//g \\\/)
      @js "/#{ body or '(?:)' }/#{flags}"
      return @countLines(heregex)length
    @token \IDENTIFIER \RegExp; @token \CALL( ''
    {tokens} = this; interp = @interpolate body
    flags = interp.pop()1 if dynaflag and interp[*-1]0 is \TOKENS
    for token, i of interp
      if token.0 is \TOKENS
        tokens.push ...token.1
      else
        val = token.1.replace HEREGEX_OMIT, ''
        continue if i and not val
        tokens.push token <<<
          \STRNUM string(val.replace bs ||= /\\/g, \\\\\; \')
      tokens.push [\+- \+ tokens[*-1]2]
    tokens.pop()
    if flags
      @token \, \,
      if typeof flags is \string
      then @token \STRNUM "'#{flags}'"
      else tokens.push ...flags
    @token \)CALL ''
    heregex.length

  # Matches a word literal or ignores an escaped whitespace.
  doBackslash: ->
    unless word = WORD.exec it
      ++@line if \\n is it.charAt 1
      return 2
    word.=0.slice 1
    @strnum if \\ is word then "'\\\\'" else string word, \'
    word.length + 1

  # Matches a words literal, a syntax sugar for a list of strings.
  doWords: ->
    @carp 'unterminated words' unless ~end = it.indexOf \]> 2
    @adi()
    @token \[ \[
    {tokens, line} = this
    for row of it.slice(2 end)split \\n
      if row.match w ||= /\S+/g then for word of that
        tokens.push [\STRNUM; string word, \'; line] <<< {+spaced}
      ++line
    @line = line - 1
    @token \STRNUM "''" unless word
    @token \] \]
    end + 2

  # Matches newlines, indents, and outdents, and determines which is which.
  # If we can detect that the current line is continued onto the next line,
  # then the newline is suppressed:
  #
  #     elements
  #       .each( ... )
  #       .map( ... )
  #
  # Keeps track of the level of indentation, because a single dedent
  # can close multiple indents, so we need to know how far in we happen to be.
  doLine: ->
    [input, tabs] = MULTIDENT.exec it
    @countLines input
    {last} = this; {length} = input
    last <<< {+eol, +spaced}
    return length if length >= it.length
    indent = tabs.length
    if indent < @indent
      @dedent @indent - indent
      LINE_CONTINUER.test it or @newline()
    else
      if tabs and (@emender ||= ///[^#{ tabs.charAt 0 }]///)exec tabs
        @carp "contaminated indent #{ escape that }"
      if (tag = last.0) is \ASSIGN and ''+last.1 not of <[ = := ]>     or
         tag of <[ +- DOT LOGIC MATH COMPARE RELATION SHIFT BITWISE ]> or
         LINE_CONTINUER.test it
        return length
      if @indent < indent
      then @indents.push @token \INDENT indent - @indent
      else @newline()
    @<<<{indent, -seenFrom, -seenTo}
    length

  # Consumes non-newline whitespaces and a line comment after them if any.
  doSpace: ->
    # Tag the previous token as being `.spaced`,
    # because there are cases where it makes a difference.
    (match = SPACE.exec it) and (@last.spaced = true; match.0.length)

  # We treat all other single characters as a token. e.g.: `( ) , . !`
  # Multi-character operators are also literal tokens, so that Jison can assign
  # the proper order of operations. There are some symbols that we tag specially
  # here. `;` and newlines are both treated as a TERMINATOR, we distinguish
  # parentheses that indicate a method call from regular parentheses, and so on.
  doLiteral: ->
    return 0 unless val = SYMBOL.exec it
    switch tag = val.=0
    case <[ . ?. ]>                    then tag = \DOT
    case <[ + -  ]>                    then tag = \+-
    case <[ === !== < > <= >= == != ]> then tag = \COMPARE
    case <[ && || ]>                   then tag = \LOGIC
    case \?                            then tag = \LOGIC if @last.spaced
    case <[ / % ]>                     then tag = \MATH
    case <[ ++ -- ]>                   then tag = \CREMENT
    case <[ <<<  <<<< ]>               then tag = \IMPORT
    case <[ << >> >>> ]>               then tag = \SHIFT
    case <[  &  |  ^  ]>               then tag = \BITWISE
    case \;                            then tag = \TERMINATOR
    case \?(                           then tag = \CALL(
    case <[ = := += -= *= /= %= &= ^= |= <<= >>= >>>= ]>
      tag = \ASSIGN
      if @last.0 is \LOGIC
        (val = new String val)logic = @tokens.pop()1
      else if @last.1 of <[ . ?. ]>
        @last.1 += val
        return val.length
    case \:
      if @last.0 not of <[ IDENTIFIER STRNUM ) ]>
        @token \LABEL ''
        return 1
    case \*
      tag = if able @tokens then \MATH else \STRNUM
    case \!
      if not @last.spaced and @last.1 is \typeof
        @last.1 = \classof
        return 1
      fallthrough
    case \~
      if @last.1 of <[ . ?. ]> or @adi()
        @last.1 += val
        return 1
      tag = \UNARY
    case <[ -> ~> ]>
      @tagParameters(); tag = \->
    case <[ <- <~ ]>
      @tagParameters(); tag = \BACKCALL
      break if @last.0 is \)PARAM
      {tokens} = this; i = tokens.length
      continue until tokens[--i]0 of <[ TERMINATOR INDENT THEN ( ]>
      tokens.splice i+1 0 [\PARAM( '' tokens[i]2]
      @token \)PARAM ''
    default
      :ALIASES
        switch val
        case \@
          if @last.1 is \. or @adi()
          then @last.1 += val
          else @token \LITERAL \this true
        case \@@ then @token \LITERAL \arguments
        case \:: then @adi(); @token \IDENTIFIER \prototype
        default break ALIASES
        return val.length
      switch val.charAt 0
      case \(
        if val.length > 1
          @token \CALL( \(
          @token \)CALL \)
          return val.length
        tag = \CALL( if @able true
      case \[ then @adi()
      case \{ then @token \CLONE '' if @able()
    @token(tag, val)length

  #### Token Manipulators

  # Records DEDENT(s) given tab `count`.
  # Multiple if we are moving back inwards past several recorded INDENTs.
  dedent: (count) ->
    while count > 0 and indent = @indents.pop()
      @carp "unmatched dedent (#{count} for #{indent})" if count < indent
      count -= @token \DEDENT indent
    void

  # Generates a newline token. Consecutive newlines get merged together.
  newline: -> @token \TERMINATOR \\n unless @last.1 is \\n

  # A source of ambiguity in our grammar used to be parameter lists in function
  # definitions versus argument lists in function calls. Walk backwards, tagging
  # parameters specially in order to make things easier for the parser.
  tagParameters: ->
    return unless @last.0 is \) and @last.1
    {tokens} = this; level = 1; i = tokens.length - 1
    while tok = tokens[--i]
      switch tok.0
      case <[ ) )CALL ]> then ++level
      case <[ ( CALL( ]>
        break if --level
        if that is \( then tok.0 = \PARAM(; @last.0 = \)PARAM
        return
    void

  # Matches a balanced group such as a double-quoted string. Pass in
  # a series of delimiters, all of which must be nested correctly within the
  # contents of the string. This method allows us to have strings within
  # interpolations within strings, ad infinitum.
  balancedString: (str, end) ->
    stack = [end]; i = 0
    while chr = str.charAt ++i
      if chr is \\ then ++i; continue
      switch end
      case chr
        stack.pop()
        return str.slice 0 i+1 unless end = stack[*-1]
      case \"
        stack.push end = \} if \{ is chr and \# is str.charAt i-1
      case \}
        switch chr
        case [\" \'] then stack.push end = chr
        case \{      then stack.push end = \}
    @carp "missing `#{stack.pop()}` in a string"

  # Expands variables and expressions inside double-quoted strings or heregexes
  # using Ruby-like notation for substitution of arbitrary expressions.
  #
  #     "Hello #{name.capitalize()}."
  #
  # Will recursively create a new lexer for each interpolation,
  # tokenizing the contents and merging them into the token stream.
  interpolate: (str, nlines) ->
    {line} = this; ts = []; pi = 0; i = -1
    while str.charAt ++i
      if that is \\
        ++i
        continue
      continue unless that is \# and \{ is str.charAt i+1
      # "#{0}#{1}" -> 0 + "" + 1
      if pi < i or nested and s >= ''
        ts.push [\S; s = str.slice pi, i; @line]
        @countLines s
      code = @balancedString str.slice(i+1), \}
      pi   = 1 + i += code.length
      continue unless code.=slice 1 -1
      nested = @lex code, {@line, +inter, +raw}
      nested.shift() if nested.0?.0 is \TERMINATOR
      if len = nested.length
        if len > 1
          nested.unshift [\( \( nested[ 0 ]2]
          nested.push    [\) \) nested[len]2]
        ts.push [\TOKENS nested]
      @countLines code
    if pi < str.length
      ts.push [\S s = str.slice pi; @line]
      @countLines s
    ts.unshift [\S '' line] unless s?
    return ts unless nlines?
    {tokens} = this
    dot = if @able() then tokens.push [\DOT '' line] else @last.0 is \DOT
    tokens.push [\( \" line]
    for t, i of ts
      tokens.push [\+- \+ tokens[*-1]2] if i
      if t.0 is \TOKENS
      then tokens.push ...t.1
      else tokens.push [\STRNUM nlines string t.1, \"; t.2]
    @token \) '' dot
    void

  #### Helpers

  # Adds a token to the results,
  # taking note of the line number and returning `value`.
  token: (tag, value, callable) ->
    @tokens.push @last = [tag, value, @line]
    @last.callable = true if callable
    value

  # Records a string/number token, supplying implicit dot if applicable.
  strnum: -> @token \STRNUM it, @adi() || @last.0 is \DOT; void

  # Records a literal token flagged embedded.
  js: -> @token \LITERAL new String(it) <<< {+js}

  # Increments `@line` by the number of newlines in a string.
  countLines: (str) ->
    pos = 0
    ++@line while pos = 1 + str.indexOf \\n pos
    str

  # Checks if the last token is
  #
  # - `f()`: `call`able via explicit parentheses
  # - `x''`: indexable via implicit brackets
  able: (call) -> not @last.spaced and able @tokens, null call

  # Supplies an implicit DOT if applicable.
  adi: -> @token \DOT \. if @able()

  # Throws a syntax error with the current line number.
  carp: -> throw SyntaxError "#{it} on line #{ @line + 1 }"

#### String Helpers

# Constructs a string token by escaping quotes and newlines.
string = (body, quote) ->
  return quote + quote unless body
  body.=replace /\\([\s\S])/g ($0, $1) ->
    if $1 of [\\n quote] then $1 else $0
  .replace /// #{quote} ///g \\\$&
  quote + body + quote

# Erases all external indentations of specific length.
detab = (str, len) ->
  if len then str.replace /// \n [^\n\S]{#{len}} ///g \\n else str

# Erases all newlines and indentations.
unlines = -> it.replace /\n[^\n\S]*/g ''

# Keeps newlines by escaping them.
enlines = -> it.replace /\n/g \\\n

#### Constants

##### Keywords

# Keywords that Coco shares in common with JavaScript.
JS_KEYWORDS = <[
  true false null this void super return throw break continue
  if else for while switch case default try catch finally class extends
  new do delete typeof in instanceof import function let with debugger
]>

# Coco-only alias keywords.
COCO_ALIASES  = not: <[ UNARY !  ]>, is: <[ COMPARE === ]>
              , and: <[ LOGIC && ]>, or: <[ LOGIC   ||  ]>

# The list of keywords that are reserved by JavaScript, but not used.
# We throw a syntax error for these to avoid runtime errors.
RESERVED = <[
  var  const enum export
  implements interface package private protected public static yield
]>

##### Regexes

IDENTIFIER = /// ^
  ( [$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]* )
  ( [^\n\S]* : (?![:=]) )?  # Is this a property name?
///
NUMBER = /// ^ (?
: 0x[\da-f]+                                  # hex
| ([2-9]|[12]\d|3[0-6]) r ([\da-z]+)          # 2-36 base
| ( (?:\d+(?:\.\d+)?|\.\d+) (?:e[+-]?\d+)? )  # decimal
  [a-z_]*                                     # decimal comment
) ///i
SYMBOL = /// ^ (?
: [-+*/%&|^:<>]=                # compound assign / comparison
| ([+&|:])\1                    # increment / logic / prototype access
| -[->]                         # decrement / function
| \([^\n\S]*\)                  # call
| [!=]==?                       # equality
| \.{3}                         # splat/placeholder/yadayadayada
| \?[.(]                        # soak  access/call
| ~[.>]                         # bound access/function
| <(?: <(?: = | <<? )? | [-~])  # left shift / import / backcall
| >>>?=?                        # rite shift
| @@                            # arguments shorthand
| [^\s#]
) ///
SPACE     = /^(?=.)[^\n\S]*(?:#.*)?/
MULTIDENT = /^(?:\s*#.*)*(?:\n([^\n\S]*))+/
SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/
JSTOKEN   = /^`[^\\`]*(?:\\.[^\\`]*)*`/
WORD      = /^\\\S[^\s,;)}\]]*/

REGEX = ///
  ^ / (?!\s)           # disallow leading whitespace
  [^ [ / \n \\ ]* (?:  # every other thing
    (?: \\.                                  # anything escaped
      | \[ [^\]\n\\]* (?:\\.[^\]\n\\]*)* \]  # or character class
    ) [^ [ / \n \\ ]*                        # every other thing again
  )* / [imgy]{0,4} (?!\d)  # disallow trailing numbers
///
HEREGEX      = /// ^ /{3} ([\s\S]*?) /{3} (\?|[imgy]{0,4}) ///
HEREGEX_OMIT = /\s+(?:#.*)?/g

LINE_CONTINUER = /// ^ \s* (?: , | \??\.(?![.\d]) ) ///
