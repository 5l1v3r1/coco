# The Coco Lexer. Uses a series of token-matching regexes to attempt
# matches against the beginning of the source code. When a match is found,
# a token is produced, we consume the match, and start again.
# Tokens are in the form:
#
#     ['TAG', 'value', lineNumber = 0]
#
# which is a format that can be fed directly into
# [Jison](http://github.com/zaach/jison) generated [parser](../lib/parser.js).

# The Lexer Object
# ----------------
# Reads a stream of Coco code and divvies it up into tagged tokens.
# Some potential ambiguity in the grammar has been avoided by
# pushing some extra smarts into Lexer.

# Depends on [Rewriter](#rewriter).
{rewrite, able} = require \./rewriter

exports import
  # `lex` is Lexer's one and only public method.
  lex: (
    # Coco source to be parsed into an array of tokens.
    code
    #  - `.raw`  <br> Suppresses [rewriting](#rewriter) if truthy.
    #  - `.line` <br> Specifies the starting line. Defaults to `0`.
    options
  # `tokenize` is Lexer's main method. Scan by attempting to match tokens
  # one at a time, using a regular expression anchored at the start of the
  # remaining code, or a custom recursive token-matching method
  # (for interpolations). When the next token has been recorded,
  # we move forward within the code past the token, and begin again.
  ) -> exports{}tokenize code||'' options||{}
  tokenize: (code, o) ->
    # Prepend a newline to handle leading INDENT.
    code = \\n + code.replace /\r/g ''
    # Stream of parsed tokens,
    # initialized with a TERMINATOR token to ensure `@last` always exists.
    @tokens = [@last = [\TERMINATOR \\n 0]]
    # The current line. Starts from -1 to setoff the prepended newline.
    @line = ~-o.line
    # The current indentation level.
    @dent = 0
    # The stack of all current indentation levels.
    @dents = []
    # Check the first character of current `code`, then call appropriate
    # tokenizers based on it. Each tokenizing method is responsible for
    # returning the number of characters it has consumed.
    while code.=slice i
      switch code.charAt 0
      case ' ' then i = @doSpace     code
      case \\n then i = @doLine      code
      case \\  then i = @doBackslash code
      case \'  then i = @doHeredoc code, \' or @doString code, \'
      case \"  then i = @doHeredoc code, \" or @doString code, \"
      case \<
        i = if \[ is code.charAt 1 then @doWords code else @doLiteral code
      case \/
        switch code.charAt 1
        case \* then i = @doComment code
        case \/ then i = @doHeregex code
        default      i = @doRegex code or @doLiteral code
      case \` then i = @doJS code
      default i = @doIdentifier code or @doNumber code or
                  @doLiteral    code or @doSpace  code
    # Dispose initial TERMINATOR.
    @tokens.shift()
    # Close up all remaining open blocks.
    @dedent @dent
    o.inter or @newline()
    # Rewrite the token stream unless explicitly asked not to.
    o.raw or rewrite @tokens
    @tokens

  #### Tokenizers

  # Matches an identifying literal: variables, keywords, accessors, etc.
  doIdentifier: ->
    return 0 unless match = ID.exec it
    [[] id, colon] = match; {last} = this
    # `id:_` `_.id` `@id`
    if colon or last.0 is \DOT or @adi()
      tag = \ID
      if id of JS_KEYWORDS or id of RESERVED
        (id = new String id)reserved = true
    # keywords
    else switch id
    case \for  then @seenFor = true; fallthrough
    case \then then @seenFrom = @seenTo = false
    case <[ this eval ]> then return @token(\LITERAL id, true)length
    case <[ true false null void arguments debugger ]> then tag = \LITERAL
    case <[ new do typeof delete ]> then tag = \UNARY
    case <[ return throw         ]> then tag = \HURL
    case <[ break continue       ]> then tag = \JUMP
    case <[ catch function ]> then id = ''
    case \import              then id = \<<<
    case <[ in of instanceof ]>
      if id is not \instanceof and @seenFor
        tag = \FOR + id.toUpperCase(); @seenFor = false
        # FOROF holds the index variable.
        if id is \of
          id = ''; @seenTo = true
          if last.0 is \ID then switch @tokens[*-2]0
          case \,        then @tokens.splice -2 1; fallthrough
          case <[ } ] ]> then @tokens.pop(); id = last.1
        break
      if last.1 is \!
        @tokens.pop()
        id = \! + id
      tag = \RELATION
    case <[ and or is not ]>
      if id is \not and last.alias and last.1 is \===
      then last.1 = \!==
      else @token ...COCO_ALIASES[id]; @last.alias = true
      return id.length
    case \unless then tag = \IF
    case \until  then tag = \WHILE
    default
      break if id of JS_KEYWORDS
      @carp "reserved word \"#{id}\"" if id of RESERVED
      if not last.1 and last.0 of <[ CATCH FUNCTION LABEL ]>
        return (last.1 = id)length
      tag = \ID
      # contextual keywords (reserved only in specific places)
      switch id
      case \own then tag = \OWN if last.0 is \FOR
      case \all then if last.1 is \<<<
        last.1 += \<
        return 3
      case \from then if @tokens[*-2]?0 is \FOR
        @<<<{-seenFor, +seenFrom}
        tag = \FROM
      case \ever then if last.0 is \FOR
        @<<<{-seenFor}
        tag = \EVER
      case <[ to til ]>
        if @seenFrom
          @<<<{-seenFrom, +seenTo}
          tag = \TO
        else if last.0 is \STRNUM and not isNaN last.1
          last <<< 0:\RANGE op:id
          return id.length
      case \by
        if @seenTo
          @<<<{-seenTo}
          tag = \BY
        else if last.0 is \RANGE and last.to
          last.by = true
          return 2
    @token tag || match.1.toUpperCase(), id
    @token \: \: if colon
    match.0.length

  # Matches a number, including decimal, hex and exponential notation.
  doNumber: ->
    return 0 unless match = NUMBER.exec it
    num = match.3 or match.0; {last} = this
    switch num.charAt 0
    # `x.0` => `x[0]`
    case \. then if @adi()
      return @token(\STRNUM num.slice(1), true)length + 1
    case \0 then if num.charAt(1) not of ['' \. \x \X]
      @carp "deprecated octal literal #{num}"
    if radix = match.1
      num = parseInt rnum = match.2, radix
      if isNaN num or num is parseInt rnum.slice(0 -1), radix
        @carp "invalid number #{rnum} in base #{radix}"
    unless last.spaced
      if sign = last.0 is \+-
        num = last.1 + num
        @tokens.pop()
        @last = last = @tokens[*-1]
      # `@0.0` => `@[0][0]`
      else if match.3 and ~(dotpos = num.indexOf \.) and able @tokens
        match.0 = num.=slice 0 dotpos
    if last.0 is \RANGE and (not last.to or last.by is true)
    then last[if last.to then \by else \to] = num
    else if sign then @token \STRNUM num else @strnum num
    match.0.length

  # Matches a normal string literal.
  doString: (code, q) ->
    if q is \"
      str = @balancedString code, q
      if 0 < str.indexOf \#{ 1
        @interpolate str.slice(1 -1), unlines
        return str.length
    else
      [str] = SIMPLESTR.exec code or @carp 'unterminated string'
    @strnum unlines string q, str.slice 1 -1
    @countLines(str)length

  # Matches heredocs, adjusting indentation to the correct level, as heredocs
  # preserve whitespace, but ignore indentation to the left.
  doHeredoc: (code, q) ->
    return 0 unless code.slice(1 3) is q+q and ~end = code.indexOf q+q+q, 3
    txt = code.slice 3 end
    lnl = txt is not doc = txt.replace /\n[^\n\S]*$/ ''
    if ~doc.indexOf \\n
      tabs = /\n[^\n\S]*(?!$)/mg  # non-empty bol
      dent = 0/0
      dent = len unless dent <= len = that.0.length - 1 while tabs.exec doc
      doc  = detab doc, dent
      if \\n is doc.charAt 0
        doc.=slice 1
        ++@line
    if q is \" and ~doc.indexOf \#{
      @interpolate doc, enlines
    else
      @strnum enlines string q, doc
      @countLines doc
    ++@line if lnl
    txt.length + 6

  # Matches block comments.
  doComment: ->
    text = if ~end = it.indexOf \*/ 2 then it.slice 0 end+2 else it + \*/
    if @last.0 of <[ TERMINATOR INDENT THEN ]>
    then @token \COMMENT detab text, @dent; @token \TERMINATOR \\n
    else @last.spaced = true
    @countLines(text)length

  # Matches embedded JavaScript.
  doJS: ->
    [js] = JSTOKEN.exec it or @carp 'unterminated JS literal'
    @js detab js.slice(1 -1), @dent
    @countLines(js)length

  # Matches a regular expression literal aka _regex_,
  # disambiguating from division operators.
  doRegex: ->
    # To coexist with implicit call and ACI,
    # disallow leading space or equal sign when applicable.
    #
    #     f /re/ 9 /ex/   # f(/re/, 9, /ex/)
    #     a /= b / c / d  # division
    #
    if (divisable = able @tokens) and @last.spaced
      return 0 if /^\/[ =]/test it or not match = REGEX.exec it
    else
      return 0 if divisable
      match = REGEX.exec it or @carp 'unterminated regex'
    @regex match.1, match.2
    match.0.length

  # Matches a multiline and extended regex literal.
  doHeregex: ->
    [heregex, body, flags] = HEREGEX.exec it or @carp 'unterminated heregex'
    flags = '' if dynaflag = flags is \?
    if 0 > body.indexOf \#{
      @regex body.replace(HEREGEX_OMIT, '')replace(/\//g \\\/), flags
      return @countLines(heregex)length
    @token \ID \RegExp; @token \CALL( ''
    {tokens} = this; interp = @interpolate body
    flags = interp.pop()1 if dynaflag and interp[*-1]0 is \TOKENS
    for token, i of interp
      if token.0 is \TOKENS
        tokens.push ...token.1
      else
        val = token.1.replace HEREGEX_OMIT, ''
        continue if not val and i > 1
        tokens.push token <<<
          \STRNUM  string \' val.replace BS||=/\\/g \\\\
      tokens.push [\+- \+ tokens[*-1]2]
    tokens.pop()
    if flags
      @token \, \,
      if typeof flags is \string
      then @token \STRNUM "'#{flags}'"
      else tokens.push ...flags
    @token \)CALL ''
    heregex.length

  # Matches a word literal, or ignores a sequence of whitespaces.
  doBackslash: ->
    [input, word] = BSTOKEN.exec it
    if word then @strnum string \' word else @countLines input
    input.length

  # Matches a words literal, a syntax sugar for a list of strings.
  doWords: ->
    @carp 'unterminated words' unless ~end = it.indexOf \]> 2
    @adi()
    @token \[ \[
    {tokens, line} = this
    for row of it.slice(2 end)split \\n
      if row.match WS||=/\S+/g then for word of that
        tokens.push [\STRNUM; string \' word; line] <<< {+spaced}
      ++line
    @line = line - 1
    @token \] \]
    end + 2

  # Matches newlines and {in,de}dents, determining which is which.
  # If we can detect that the current line is continued onto the next line,
  # then the newline is suppressed:
  #
  #     elements
  #     .map -> ...
  #     .get()
  #
  # Keeps track of the level of indentation, because a single dedent
  # can close multiple indents, so we need to know how far in we happen to be.
  doLine: ->
    [input, tabs] = MULTIDENT.exec it
    @countLines input
    {last} = this; {length} = input
    last <<< {+eol, +spaced}
    return length if length >= it.length
    delta = tabs.length - @dent
    if delta < 0
      @dedent -delta
      LINE_CONTINUER.test it or @newline()
    else
      if tabs and (@emender ||= //[^#{ tabs.charAt 0 }]//)exec tabs
        @carp "contaminated indent #{ escape that }"
      if (tag = last.0) is \ASSIGN and ''+last.1 not of <[ = := ]> or
         tag of <[ +- DOT LOGIC MATH COMPARE RELATION SHIFT BITWISE ]>
        return length
      cont = LINE_CONTINUER.test it
      if delta then @indent delta, cont else cont or @newline()
    @<<<{-seenFrom, -seenTo}
    length

  # Consumes non-newline whitespaces and a line comment after them if any.
  doSpace: ->
    # Tag the previous token as being `.spaced`,
    # because there are cases where it makes a difference.
    (match = SPACE.exec it) and (@last.spaced = true; match.0.length)

  # We treat all other single characters as a token. e.g.: `( ) , . !`
  # Multi-character operators are also literal tokens, so that Jison can assign
  # the proper order of operations. There are some symbols that we tag specially
  # here. `;` and newlines are both treated as a TERMINATOR, we distinguish
  # parentheses that indicate a method call from regular parentheses, and so on.
  doLiteral: ->
    return 0 unless sym = SYMBOL.exec it
    switch tag = val = sym.=0
    case <[ . ?. ]>                    then tag = \DOT
    case <[ + -  ]>                    then tag = \+-
    case <[ === !== < > <= >= == != ]> then tag = \COMPARE
    case <[ && || ]>                   then tag = \LOGIC
    case \?                            then tag = \LOGIC if @last.spaced
    case <[ / % ** ]>                  then tag = \MATH
    case <[ ++  -- ]>                  then tag = \CREMENT
    case <[ <<<  <<<< ]>               then tag = \IMPORT
    case <[ << >> >>> ]>               then tag = \SHIFT
    case <[  &  |  ^  ]>               then tag = \BITWISE
    case \(                            then tag = \CALL( if @able true
    case \?(                           then tag = \CALL(
    case \;                            then tag = \TERMINATOR
    case \: then if @last.0 not of <[ ID STRNUM ) ]>
      tag = \LABEL; val = ''
    case <[ = := += -= *= /= %= &= ^= |= <<= >>= >>>= **= ]>
      tag = \ASSIGN
      if @last.0 is \LOGIC
        (val = new String val)logic = @tokens.pop()1
      else if @last.1 of <[ . ?. ]> or @last.0 is \? and @adi()
        @last.1 += val
        return val.length
    case \*
      if @last.0 of <[ TERMINATOR INDENT THEN ]> and /^.[^\n\S]*(?=\S)/exec it
        @tokens.push [\{ \{ @line] [\} \} @line] [\ASSIGN \= @line]
        @indent val = that.0.length
        return val
      tag = if able @tokens then \MATH else \STRNUM
    case \@
      if @last.1 of <[ . ?. ]> or @adi()
      then @last.1 += val
      else @token \LITERAL \this true
      return 1
    case \!
      return (@last.1 = \classof; 1) if not @last.spaced and @last.1 is \typeof
      fallthrough
    case \~
      return (@last.1 += val; 1) if @last.1 of <[ . ?. ]> or @adi()
      tag = \UNARY
    case \~> then tag = \->
    case \<~ then tag = \<-; fallthrough
    case \<-
      break if @last.1 is \)
      {tokens} = this; i = tokens.length
      continue until tokens[--i]0 of <[ TERMINATOR INDENT THEN ( ]>
      tokens.splice i+1 0 [\PARAM( '' tokens[i]2]
      @token \)PARAM ''
    case \[  then @adi()
    case \{  then @token \CLONE '' if @able()
    case \@@ then tag = \LITERAL; val = \arguments
    case \:: then i = \prototype; fallthrough
    case \.. then @adi(); tag = \ID; val = i || \constructor
    default if \( is val.charAt 0
      @token \CALL( \(; tag = \)CALL; val = \)
    @token tag, val
    sym.length

  #### Token Manipulators

  # Records an INDENT.
  indent: (delta, dummy) ->
    @dent += delta
    @dents.push if dummy then ''+delta else @token \INDENT delta
    void

  # Records a DEDENT, or DEDENTs if there are multiple matching INDENTs.
  dedent: (debt) ->
    @dent -= debt
    while debt > 0 and dent = @dents.pop()
      @carp "unmatched dedent (#{debt} for #{dent})" if debt < dent
      debt -= if typeof dent is \number then @token \DEDENT dent else dent
    void

  # Generates a newline token. Consecutive newlines get merged together.
  newline: -> @token \TERMINATOR \\n unless @last.1 is \\n

  # Matches a balanced group such as a double-quoted string. Pass in
  # a series of delimiters, all of which must be nested correctly within the
  # contents of the string. This method allows us to have strings within
  # interpolations within strings, ad infinitum.
  balancedString: (str, end) ->
    stack = [end]; i = 0
    while chr = str.charAt ++i
      if chr is \\ then ++i; continue
      switch end
      case chr
        stack.pop()
        return str.slice 0 i+1 unless end = stack[*-1]
      case \"
        stack.push end = \} if \{ is chr and \# is str.charAt i-1
      case \}
        switch chr
        case \" \' then stack.push end = chr
        case \{    then stack.push end = \}
    @carp "missing `#{stack.pop()}` in a string"

  # Expands variables and expressions inside double-quoted strings or heregexes
  # using Ruby-like notation for substitution of arbitrary expressions.
  #
  #     "Hello #{name.capitalize()}."
  #
  # Will recursively create a new lexer for each interpolation,
  # tokenizing the contents and merging them into the token stream.
  interpolate: (str, nlines) ->
    {line} = this; ts = []; pi = 0; i = -1
    while str.charAt ++i
      if that is \\
        ++i
        continue
      continue unless that is \# and \{ is str.charAt i+1
      # `"#{0}#{1}"` => `0 + "" + 1`
      if pi < i or nested and s >= ''
        ts.push [\S; s = str.slice pi, i; @line]
        @countLines s
      code = @balancedString str.slice(i+1), \}
      pi   = 1 + i += code.length
      continue unless code.=slice 1 -1
      nested = @lex code, {@line, +inter, +raw}
      nested.shift() if nested.0?0 is \TERMINATOR
      if len = nested.length
        if len > 1
          nested.unshift [\( \( nested[ 0 ]2]
          nested.push    [\) \) nested[len]2]
        ts.push [\TOKENS nested]
      @countLines code
    if pi < str.length
      ts.push [\S; s = str.slice pi; @line]
      @countLines s
    ts.unshift [\S '' line] unless s?
    return ts unless nlines?
    {tokens} = this
    dot = if @able() then tokens.push [\DOT '' line] else @last.0 is \DOT
    tokens.push [\( \" line]
    for t, i of ts
      if t.0 is \TOKENS
        tokens.push ...t.1
      else
        s = nlines string \" t.1
        continue if i > 1 and s.length < 3
        tokens.push [\STRNUM s, t.2]
      tokens.push [\+- \+ tokens[*-1]2]
    tokens.pop()
    @token \) '' dot
    void

  #### Helpers

  # Adds a token to the results,
  # taking note of the line number and returning `value`.
  token: (tag, value, callable) ->
    @tokens.push @last = [tag, value, @line]
    @last.callable = true if callable
    value

  # Records a string/number token, supplying implicit dot if applicable.
  strnum: -> @token \STRNUM it, @adi() || @last.0 is \DOT; void

  # Records a literal token flagged embedded.
  js: -> @token \LITERAL new String(it) <<< {+js}

  # Records a regex token.
  regex: (body, flags) ->
    try RegExp body catch @carp e.message
    @js "/#{ body or '(?:)' }/#{ flags and flags.replace /(.)(?=.*\1)/g '' }"

  # Increments `@line` by the number of newlines in a string.
  countLines: -> ++@line while pos = 1 + it.indexOf \\n pos; it

  # Checks if the last token is
  #
  # - `f()`: `call`able via explicit parentheses
  # - `x''`: indexable via implicit brackets
  able: (call) -> not @last.spaced and able @tokens, null call

  # Supplies an implicit DOT if applicable.
  adi: ->
    not @last.spaced and if @last.0 is \?
    then @last <<< [\DOT \?.]
    else able @tokens and @token \DOT \.

  # Throws a syntax error with the current line number.
  carp: -> throw SyntaxError "#{it} on line #{ @line + 1 }"

#### String Helpers

# Constructs a string token by (un)escaping quotes and newlines.
string = let do
  escaped = /\\(?:[\\0-7bfnrtuvx]|[^\n\S]|([\w\W]))?/g
  descape = ($0, $1) -> $1 or if $0 is \\ then \\\\ else $0
  qs = "'":/'/g '"':/"/g
then (q, body) -> q + body.replace(escaped, descape)replace(qs[q], \\\$&) + q

# Erases all external indentations up to specified length.
function detab(str, len) ->
  if len then str.replace detab[len]||=//\n[^\n\S]{1,#{len}}//g \\n else str

# Erases all newlines and indentations.
function unlines -> it.replace INDENTS, ''
INDENTS = /\n[^\n\S]*/g

# Keeps newlines by escaping them.
function enlines -> it.replace LINES, \\\n
LINES = /\n/g

#### Constants

##### Keywords

# Keywords that Coco shares in common with JavaScript.
JS_KEYWORDS = <[
  true false null this void super return throw break continue
  if else for while switch case default try catch finally class extends
  new do delete typeof in instanceof import function let with debugger
]>

# Coco-only alias keywords.
COCO_ALIASES  = not: <[ UNARY !  ]>, is: <[ COMPARE === ]>
              , and: <[ LOGIC && ]>, or: <[ LOGIC   ||  ]>

# The list of keywords that are reserved by JavaScript, but not used.
# We throw a syntax error for these to avoid runtime errors.
RESERVED = <[
  var  const enum export
  implements interface package private protected public static yield
]>

##### Regexes

ID = // ^
  ( [$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]* )
  ( [^\n\S]* : (?![:=]) )?  # Is this a property name?
//
NUMBER = // ^ (?
: 0x[\da-f]+                                  # hex
| ([2-9]|[12]\d|3[0-6]) r ([\da-z]+)          # 2-36 base
| ( (?:\d+(?:\.\d+)?|\.\d+) (?:e[+-]?\d+)? )  # decimal
  [a-z_]*                                     # decimal comment
) //i
SYMBOL = // ^ (?
: [-+*/%&|^:<>]=              # compound assign / comparison
| \.{1,3}                     # dot / `constructor` / splat/placeholder/yada*3
| ([+&|:])\1                  # increment / logic / `prototype`
| \([^\n\S]*\)                # call
| -[->]                       # decrement / function
| [!=]==?                     # equality
| \?[.(]                      # soak access/call
| ~[.>]                       # bind access/function
| <(?: <(?:=|<{0,2}) | [-~])  # left shift / import / backcall
| >>>?=?                      # rite shift
| \*\*=?                      # pow
| @@                          # `arguments`
| [^\s#]
) //
SPACE     = /^(?=.)[^\n\S]*(?:#.*)?/
MULTIDENT = /^(?:\s*#.*)*(?:\n([^\n\S]*))+/
SIMPLESTR = /^'[^\\']*(?:\\[\s\S][^\\']*)*'/
JSTOKEN   = /^`[^\\`]*(?:\\[\s\S][^\\`]*)*`/
BSTOKEN   = /^\\(?:(\S[^\s,;)}\]]*)|\s+)/

REGEX = //
  ^ /(
  [^ [ / \n \\ ]* (?:                        # every other thing
    (?: \\.                                  # anything escaped
      | \[ [^\]\n\\]* (?:\\.[^\]\n\\]*)* \]  # or character class
    ) [^ [ / \n \\ ]*                        # every other thing again
  )* )/ ([imgy]{0,4})
//
HEREGEX      = // ^ / / ([\s\S]*?) / / ([imgy]{1,4}|\??) //
HEREGEX_OMIT = /\s+(?:#.*)?/g

LINE_CONTINUER = // ^ \s* (?:
  [,?&|^] | \.(?![.\d]) | (?:and|or)(?![$\w\x7f-\uffff]|[^\n\S]*:(?![:=]))
) //
