# The main entry functions for
# [tokenizing](#lexer), [parsing](#grammar), and [compiling](#nodes)
# Coco source into JavaScript.

Coco = exports

# Override Jison's default lexer, so that it can accept
# the generic stream of tokens our lexer produces.
{lex}    = require \./lexer
{parser} = require \./parser
parser import
  yy    : require \./nodes
  lexer :
    lex           : -> [tag, @yytext, @yylineno] = @tokens[++@pos] or ['']; tag
    setInput      : -> @pos = -1; @tokens = it
    upcomingInput : -> ''

Coco import
  VERSION: \0.2.3b

  # Compiles a string of Coco code to JavaScript.
  compile: (code, options) -> parser.parse(lex code).compileRoot options

  # Parses a string or tokens of Coco code, returning the AST.
  nodes: -> parser.parse if typeof it is \string then lex it else it

  # Tokenizes a string of Coco code, returning the array of tokens.
  tokens: lex

  # Same as `tokens`, except that this skips [rewriting](#rewriter).
  lex: -> lex it, {-rewrite}

#### [node.js](http://nodejs.org)
if (fs = require \fs) and (path = require \path)
  Coco import
    # Executes a string of Coco, correctly
    # setting `__filename`, `__dirname`, and relative `require`.
    run: (code, options or {}) ->
      root = module
      root.=parent while root.parent
      root.filename = if options.filename then fs.realpathSync that else \.
      root.moduleCache &&= {}
      unless options.js
        if require.extensions or
           path.extname(root.filename).toLowerCase() is not \.co
          code = Coco.compile code, options
      root._compile code, root.filename
    # Evaluates a string of Coco. The Coco REPL uses this to run the input.
    eval: (code, options) ->
      __dirname = path.dirname __filename = module.filename = options?.filename
      eval Coco.compile code, options

  if require.extensions
    require.extensions\.co = (module, filename) ->
      module._compile (Coco.compile fs.readFileSync filename, \utf8), filename
  # __TODO__: Remove `registerExtension` when fully deprecated.
  else if require.registerExtension
    require.registerExtension \.co Coco.compile

#### other platforms
else
  Coco import {
    eval : (code, options) -> (0; eval) Coco.compile code, options
    run  : (code, options or {}) ->
      do Function Coco.compile code, options <<< {+bare}; void
    # Attatch `require` for debugging.
    require
  }
  # Support Gecko JS Module.
  @EXPORTED_SYMBOLS = [\Coco] if toString() is '[object BackstagePass]'
