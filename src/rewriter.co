# The Coco language has a good deal of optional syntax, implicit syntax,
# and shorthand syntax. This can greatly complicate a grammar and bloat
# the resulting parse table. Instead of making the parser handle it all, we take
# a series of passes over the token stream, using this **Rewriter** to convert
# shorthand into the unambiguous long form, add implicit indentation and
# parentheses, balance incorrect nestings, and generally clean things up.

# **Rewriter** is used by [Lexer](#lexer),
# directly against its internal array of tokens.

exports import {rewrite, able}

# Rewrite the token stream in multiple passes, one logical filter at
# a time. This could certainly be changed into a single pass through the
# stream, with a big ol' efficient switch, but it's much nicer to work with
# like this. The order of these passes matters--indentation must be
# corrected before implicit parentheses can be wrapped around blocks of code.

function rewrite ->
  removeTerminators      it
  closeCalls             it
  addImplicitIndentation it
  tagPostfixConditionals it
  addImplicitParentheses it
  addImplicitBraces      it
  ensureBalance          it
  rewriteClosingParens   it
  expandLiterals         it
  it

# - Dispatch leading terminators that would introduce ambiguity in the grammar.
# - Some blocks occur in the middle of expressions.
#   Remove their trailing terminators here to simplify things.
function removeTerminators(tokens) ->
  i = -1
  break unless that.0 is \TERMINATOR while tokens[++i]
  i and tokens.splice 0 i
  i = 1
  while tokens[++i]
    continue unless tokens[i-1]0 is \TERMINATOR
    that.=0
    tokens.splice i-1 1 if that of EXPR_END or
                           that of <[ ELSE CASE DEFAULT CATCH FINALLY ]>
  void

# The lexer has tagged each of the opening parenthesis of
# a call. Match it with its closing pair.
function closeCalls(tokens) ->
  stack = []
  for token of tokens
    switch token.0
    case <[ ( CALL( ]> then stack.push that
    case <[ ) )CALL ]> then stack.pop() is \CALL( and token.0 = \)CALL
  void

# Tag postfix conditionals as such, so that we can parse them with a
# different precedence.
function tagPostfixConditionals(tokens) ->
  detectEnd tokens, i+1, ok, go if token.0 is \IF for token, i of tokens
  function ok -> it.0 of <[ TERMINATOR INDENT ]>
  function go -> token.0 = \POST_IF if it.0 is not \INDENT
  void

# Because our grammar is LALR(1), it can't handle some single-line
# expressions that lack ending delimiters. **Rewriter** adds the implicit
# blocks, so it doesn't need to. `)` can close a single-line block,
# but we need to make sure it's balanced.
function addImplicitIndentation(tokens) ->
  i = -1
  while token = tokens[++i]
    [tag] = token
    continue unless tag of <[ THEN -> ELSE DEFAULT TRY CATCH FINALLY ]>
    switch next = tokens[i+1]0
    case <[ INDENT THEN ]> then continue
    case \IF               then continue if tag is \ELSE
    indent = [\INDENT 0 token.2]; dedent = [\DEDENT 0]
    if tag is \THEN
      tokens.splice --i, 1 if tokens[i-1]?.0 is \TERMINATOR
      tokens[i] = indent
    else
      tokens.splice ++i, 0 indent
    switch
    case \, is next           then --i; fallthrough  # ->,
    case \, is tokens[i+2]?.0 then go 0 i+=2; ++i    # -> 0,
    case next of <[ ( [ { ]> and                     # -> [0],
         \, is tokens[idx = 1 + indexOfPair tokens, i+1]?.0
      go 0 idx; ++i
    default
      seenSwitch = false
      detectEnd tokens, i+1, ok, go
  function ok(token, i) ->
    switch token.0
    case \DEDENT            then true
    case \TERMINATOR        then token.1 is not \;
    case \DOT               then tokens[i-1]eol
    case \ELSE              then tag is \THEN
    case \CATCH             then tag is \TRY
    case \FINALLY           then tag of <[ TRY CATCH THEN ]>
    case \SWITCH            then not seenSwitch := true
    case <[ CASE DEFAULT ]> then not seenSwitch
  function go(token, i) ->
    tokens.splice if tokens[i-1]0 is \, then i-1 else i, 0 dedent <<< {token.2}
  void

# Object literals may be written without braces for simple cases.
# Insert the missing braces here to aid the parser.
function addImplicitBraces(tokens) ->
  stack = []; i = -1
  while token = tokens[++i]
    unless \: is tag = token.0
      switch
      case tag of EXPR_START
        tag = \{ if tag is \INDENT and tokens[i-1]?.0 is \{
        stack.push [tag, i]
      case tag of EXPR_END
        start = stack.pop()
      continue
    paren   = tokens[i-1]?.0 is \)
    oneline = paren and tokens[start.1 - 1]?.0 is \: or # a: (..):
              tokens[i-2]?.0 is \:                      # a: b:
    continue unless oneline or stack[*-1]?.0 is not \{
    stack.push [\{]
    idx  = if paren then start.1 else i-1
    idx -= 2 while tokens[idx-2]?.0 is \COMMENT
    tokens.splice idx, 0 [\{ \{ token.2]
    detectEnd tokens, ++i+1, ok, go
  function ok(token, i) ->
    return true if token.1 is \; or \DEDENT is tag = token.0
    switch tag
    case \,          then break
    case \TERMINATOR then return true if oneline
    default return false
    t1 = tokens[i+1]?.0
    t1 is not (if tag is \, then \TERMINATOR else \COMMENT) and
    \: is not tokens[if t1 is \( then 1 + indexOfPair tokens, i+1 else i+2]?.0
  function go(token, i) -> tokens.splice i, 0 [\} '' token.2]
  void

# Methods may be optionally called without parentheses for simple cases.
# Insert the missing parentheses here to aid the parser.
function addImplicitParentheses(tokens) ->
  i = 0; brackets = []
  while token = tokens[++i]
    [tag] = token; prev = tokens[i-1]
    if doblock = token.1 is \do and tokens[i+1]?.0 is \INDENT
      tokens.splice i, 1
      (tpair = tokens[indexOfPair tokens, i])0 = \)
      (token = tokens[                    i])0 = \(
    else if tag is \[
      brackets.push prev.0 is \DOT
    if prev.0 is \]
      if brackets.pop() then token.index = true else continue
    continue unless prev.spaced and able tokens, i, true
    if doblock
      token.0 = \CALL(; tpair.0 = \)CALL
      continue
    continue unless tag of ARG or tag is \+- and !(token.spaced or token.eol)
    skipBlock = seenSwitch = false
    tokens.splice --i, 1 if soak = prev.0 is \?
    tokens.splice i++, 0 [\CALL( if soak then \?( else \(, token.2]
    detectEnd tokens, i, ok, go
  function ok(token, i) ->
    return true if token.alias and token.1 of <[ && || ]>
    pre = tokens[i-1]
    switch token.0
    case \SWITCH             then seenSwitch := true; fallthrough
    case <[ IF CLASS WITH ]> then skipBlock  := true
    case \CASE
      if seenSwitch then skipBlock := true else return true
    case \DOT
      return true if pre.eol or pre.0 is \DEDENT
    case \INDENT
      return skipBlock := false if skipBlock
      return pre.0 not of
        <[ { [ , -> : ELSE ASSIGN IMPORT UNARY DEFAULT TRY CATCH FINALLY ]>
    case <[ TERMINATOR POST_IF FOR WHILE BY TO ]>
      return pre.0 is not \,
    false
  function go(token, i) ->
    tokens.splice i + (token.0 is \DEDENT), 0 [\)CALL '' token.2]
  void

# Ensure that all listed pairs of tokens are correctly balanced throughout
# the course of the token stream.
function ensureBalance(tokens) ->
  levels = {}; olines = {}
  for token of tokens
    [tag] = token
    for [open, close] of BALANCED_PAIRS
      levels[open] |= 0
      if tag is open
        olines[open] = token.2 if levels[open]++ is 0
      else if tag is close and --levels[open] < 0
        carp "too many `#{token.1}`" token.2
  carp "unclosed #{open}" olines[open] if level > 0 for open, level in levels
  void

# We'd like to support syntax like this:
#
#     el.click((event) ->
#       el.hide())
#
# In order to accomplish this, move outdents that follow closing parens
# inwards, safely. The steps to accomplish this are:
#
# 1. Check that all paired tokens are balanced and in order.
# 2. Rewrite the stream with a stack: if you see an `EXPR_START`, add it
#    to the stack. If you see an `EXPR_END`, pop the stack and replace
#    it with the inverse of what we've just popped.
# 3. Keep track of "debt" for tokens that we manufacture, to make sure we end
#    up balanced in the end.
# 4. Be careful not to alter array or parentheses delimiters with overzealous
#    rewriting.
function rewriteClosingParens(tokens) ->
  debt  = {}; debt[key] = 0 for key in INVERSES
  stack = []; i = -1
  while token = tokens[++i]
    [tag] = token
    unless tag of EXPR_END
      stack.push token if tag of EXPR_START
      continue
    if debt[inv = INVERSES[tag]] > 0
      --debt[inv]
      tokens.splice i--, 1
      continue
    stoken = stack.pop()
    continue if tag is end = INVERSES[start = stoken.0]
    ++debt[start]
    tokens.splice i, 0,
      [end, if start is \INDENT then stoken.1 else end, token.2]
  void

# - Slip unary {pl,min}uses off signed numbers.
# - Expand number ranges.
# - Insert a comma between a primitive argument and a non-primitive one.
function expandLiterals(tokens) ->
  i = -1
  while token = tokens[++i]
    switch token.0
    case \STRNUM
      if ~'-+'indexOf sig = (num = '' + token.1)charAt 0
        token.1 = num.slice 1
        tokens.splice i++, 0 [\+- sig, token.2]
    case \RANGE
      ts = []; lno = token.2
      to = token.to - if token.op is \to then 0 else 1e-15
      for n from +token.1 to to by +token.by or 1
        if 32r200 < ts.push [\STRNUM n, lno] [\, \, lno]
          carp 'range limit exceeded' lno
      if ts.length then ts.pop() else carp 'empty range' lno
      tokens.splice i, 1 ...ts
      i += ts.length - 1
    case <[ ) )CALL ]> then break unless token.1
    case \}            then break if     token.1
    case \]            then break unless token.index
    case \LITERAL      then break
    default continue
    if token.spaced and tokens[i+1]0 of ARG
      tokens.splice ++i, 0 [\, \, token.2]
  void

### Helpers

# Seeks `tokens` from index `i` for a token of the same level matching `ok`,
# then calls `go`.
function detectEnd(tokens, i, ok, go) ->
  levels = 0
  while token = tokens[i]
    if      not levels then return go token, i if ok token, i
    else if 0 > levels then return go token, i-1
    [tag] = token
    if      tag of EXPR_START then ++levels
    else if tag of EXPR_END   then --levels
    ++i
  void

# Checks whether or not the previous token is {index,`call`}able.
function able(tokens, i = tokens.length, call) ->
  [tag] = token = tokens[i-1]
  tag of <[ IDENTIFIER SUPER ] ]> or
  if call
  then token.callable or tag is \? or tag of <[ ) )CALL ]> and token.1
  else tag of <[ STRNUM LITERAL ) )CALL } ]>

function indexOfPair(tokens, i) ->
  level = 1; end = INVERSES[start = tokens[i]0]
  while tokens[++i]
    switch that.0
    case start then ++level
    case end   then return i unless --level
  -1

function carp(msg, lno) -> throw SyntaxError "#{msg} on line #{-~lno}"

### Constants

# List of the token pairs that must be balanced.
BALANCED_PAIRS =
  <[      ( )      ]>
  <[      [ ]      ]>
  <[      { }      ]>
  <[  CALL( )CALL  ]>
  <[ PARAM( )PARAM ]>
  <[ INDENT DEDENT ]>

# The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
# look things up from either end.
INVERSES = {}
# Tokens that signal the start/end of a balanced pair.
EXPR_START = []
EXPR_END   = []
for [left, rite] of BALANCED_PAIRS
  EXPR_START.push INVERSES[rite] = left
  EXPR_END  .push INVERSES[left] = rite

# Tokens that can start an argument list.
ARG = <[ IDENTIFIER STRNUM LITERAL ( [ { -> PARAM( FUNCTION ...
         UNARY CREMENT IF TRY CLASS SWITCH LET WITH RANGE SUPER ]>
