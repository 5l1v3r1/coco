# Defines an editing mode for [Ace](http://ace.ajax.org).
#
# Open [test/ace.htm](../test/ace.htm) to test.

require, exports, module <- define \ace/mode/coco

exports.Mode = class CocoMode extends require(\ace/mode/text)Mode
  ->
    @$tokenizer =
      new (require \ace/tokenizer)Tokenizer CocoMode.Rules
    @$outdent   =
      new (require \ace/mode/matching_brace_outdent)MatchingBraceOutdent

  indenter = /// (?
  : [({[=:]
  | [-~]>
  | \b (?: else | d(?:o|efault) | try | finally
         | catch(?:\s*[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)? )
  ) \s* $ ///

  getNextLineIndent: (state, line, tab) ->
    indent   = @$getIndent line
    {tokens} = @$tokenizer.getLineTokens line, state
    unless tokens.length and tokens[*-1]type is \comment
      indent += tab if state is \start and indenter.test line
    indent

  toggleCommentLines: (state, doc, startRow, endRow) ->
    comment = /^(\s*)#/; range = new (require \ace/range)Range 0 0 0 0
    for i from startRow to endRow
      if out = comment.test line = doc.getLine i
      then line.=replace comment, \$1
      else line.=replace /^\s*/   \$&#
      range.end.row = range.start.row = i
      range.end.column = line.length + 1
      doc.replace range, line
    1 - out * 2

  checkOutdent: (state, line, input) -> @$outdent.checkOutdent line, input

  autoOutdent: (state, doc, row) -> @$outdent.autoOutdent doc, row

### Highlight Rules

identifier = '[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*'
stringfill = token: \string, regex: '.+'

CocoMode.Rules =
start: [
  token: \identifier
  regex: '(?:@|(?:\\.|::)\\s*)' + identifier
,
  token: ->
    switch it
    case <[
      this super return throw break continue
      if else for while switch case default try catch finally class extends
      new do delete typeof in instanceof import function debugger
      then of unless until   is not and or   arguments eval
    ]> then \keyword
    case <[ true false null void ]> then \constant.language
    case <[
      var with   const enum export
      implements interface let package private protected public static yield
    ]> then \invalid.illegal
    case <[
      Array Boolean Date Function Number Object RegExp String Error
      EvalError RangeError ReferenceError SyntaxError TypeError URIError
    ]> then \language.support.buildin.class
    case <[
      Math JSON   isNaN isFinite parseInt parseFloat
      encodeURI decodeURI encodeURIComponent decodeURIComponent
    ]> then \language.support.buildin.function
    case <[ it that from to til by own ever fallthrough ]> then \variable
    default \identifier
  regex: identifier + '(?:\\s*:)?'
,
  token: \keyword
  regex: '@@?(?!@)'
,
  token: \string
  regex: '\\\\\\S[^\\s,;)}\\]]*'
,
  token: \string.doc
  regex: \'''
  next : \qdoc
,
  token: \string.doc
  regex: \"""
  next : \qqdoc
,
  token: \string
  regex: \'
  next : \qstring
,
  token: \string
  regex: \"
  next : \qqstring
,
  token: \string
  regex: \`
  next : \js
,
  token: \string
  regex: '<\\['
  next : \words
,
  token: \string.regex
  regex: \///
  next : \heregex
,
  token: \comment.doc
  regex: '/\\*'
  next : \comment
,
  token: \comment
  regex: '#.*'
,
  token: \string.regex
  regex: '
    /(?!\\s)
    [^[/\\n\\\\]*
    (?: (?:\\\\.
          |\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\]
        )[^[/\\n\\\\]*
    )*/[imgy]{0,4}(?!\\w)
  '
,
  token: \constant.numeric
  regex: '(?:0x[\\da-fA-F]+
            |(?:[1-9]\\d?)[rR][\\da-zA-Z]+
            |(?:\\d+(?:\\.\\d+)?)(?:[eE][+-]?\\d+)?[a-zA-Z_]*)'
,
  token: \lparen
  regex: '[({[]'
,
  token: \rparen
  regex: '[)}\\]]'
,
  token: \keyword.operator
  regex: \\\S+
,
  token: \text
  regex: \\\s+
]
heregex: [
  token: \string.regex
  regex: '.*?///(?:\\?|[imgy]{0,4})'
  next : \start
,
  token: \comment.regex
  regex: '\\s+(?:#.*)?'
,
  token: \string.regex
  regex: '\\S+'
]
qdoc:
  token: \string
  regex: ".*?'''"
  next : \start
  stringfill
qqdoc:
  token: \string
  regex: '.*?"""'
  next : \start
  stringfill
qstring:
  token: \string
  regex: "[^\\\\']*(?:\\\\.[^\\\\']*)*'"
  next : \start
  stringfill
qqstring:
  token: \string
  regex: '[^\\\\"]*(?:\\\\.[^\\\\"]*)*"'
  next : \start
  stringfill
js:
  token: \string
  regex: '[^\\\\`]*(?:\\\\.[^\\\\`]*)*`'
  next : \start
  stringfill
words:
  token: \string
  regex: '.*?]>'
  next : \start
  stringfill
comment:
  token: \comment.doc
  regex: '.*?\\*/'
  next : \start
  {}= token: \comment.doc, regex: '.+'

void
