# Quick and dirty implementation of
# [code-illuminated](http://code.google.com/p/code-illuminated/)-esque
# annotated source viewer, powered by
# [showdown](http://attacklab.net/showdown/) and
# [google-code-prettify](http://code.google.com/p/google-code-prettify/).
#
# Imported from [src/index.html](#).

navi = document.getElementById \navi
docs = document.getElementById \docs
sdcv = new Showdown.converter
htms = __proto__: null

do @onhashchange = ->
  unless page = /^\D+(?=(\d*)$)/.exec location.hash.slice 1
    navi.className = docs.innerHTML = ''
    return
  navi.className = \menu
  docs.innerHTML = \...
  [name] = page
  return load page, that if htms[name]
  xhr = new XMLHttpRequest
  xhr.open \GET, name + \.co, true
  xhr.overrideMimeType? \text/plain
  xhr.onreadystatechange = ->
    load page, htms[name] = build name, xhr.responseText if xhr.readyState is 4
  xhr.send null

load = ([name, sect], html) ->
  document.title = name + ' - Coco Docs'
  docs.innerHTML = html
  document.getElementById(sect).scrollIntoView() if sect
  prettyPrint()

build = (name, source) ->
  htm = comment = code = i = ''
  re  = /^[^\n\S]*#(?!##[^#]|{) ?(.*)/
  for line of source.split \\n
    unless line
      br = true
      code &&+= \\n
      continue
    if re.exec line
      if code or comment and br
        htm += block name, comment, code, i++
        comment = code = ''
      comment += that.1 + \\n
    else
      code += line + \\n
    br = false
  htm += block name, comment, code, i if comment
  "<h1>#{name}</h1>" + htm

block = (name, comment, code, i) ->
  code &&= """
   <pre class="code prettyprint lang-co"
    >#{ code.replace(/&/g, '&amp;').replace(/</g, '&lt;') }</pre>
  """
  """
   <div id=#{i} class=block><div class=comment
    ><a class=anchor href=##{name}#{i}>##{i}</a
    >#{ sdcv.makeHtml comment }</div
    >#{code}</div>
  """

PR.registerLangHandler do
  PR.createSimpleLexer do
    [
      [\str /^\\\S[^\s,;)}\]]*/ 0 \\]
      [\str /// ^ ' (?: ''[\s\S]*?'' | [^\\']*(?:\\.[^\\']*)* ) ' /// 0 \']
      [\str /// ^ " (?: ""[\s\S]*?"" | [^\\"]*(?:\\.[^\\"]*)* ) " /// 0 \"]
      [\lit /^`[^\\`]*(?:\\.[^\\`]*)*`/, 0, \`]
      [\lit /^<\[[\s\S]*?]>/, 0, \<]
      [\lit /// ^ (?
      : /{3} [\s\S]+? /{3}
      | / (?! \s )
        [^ [ / \n \\ ]*
        (?:
          (?
          : \\[\s\S]
          | \[
              [^ \] \n \\ ]*
              (?: \\[\s\S] [^ \] \n \\ ]* )*
             ]
          ) [^ [ / \n \\ ]*
        )* /
      ) [imgy]{0,4} (?!\w) /// 0 \/]
      [\com /// ^ \# (?: \##[^#][\s\S]*?### | .*) ///, 0, \#]
      [\typ /// ^ (?
      : 0x[\da-f]+
      | [1-9]\d? r [\da-z]+
      | (?:\d+(?:\.\d+)?|\.\d+) (?:e[+-]?\d+)? [a-z]*
      ) ///i 0 \0123456789.]
    ]
    [
      [\kwd /// ^ (?
      : t(?:ry|h(?:row|en)|ypeof)
      | f(?:or(?: own)?|inally|unction)
      | n(?:ew|ot)
      | c(?:ontinue|a(?:se|tch)|lass)
      | i(?:f|n(?:stanceof)?|mport(?: all)?|s(?:nt)?)
      | e(?:lse|xtends)
      | d(?:e(?:fault|lete|bugger)|o)
      | un(?:less|til)
      | o[fr] | return | break | while | switch | and
      ) \b ///]
      [\typ /// ^ (?: true | false | null | void | this | super ) \b ///]
    ]
  [\co]
