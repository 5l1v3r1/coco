# The Coco parser is generated by [Jison](http://github.com/zaach/jison)
# from this grammar file. Jison is a bottom-up parser generator, similar in
# style to [Bison](http://www.gnu.org/software/bison), implemented in JavaScript.
# It can recognize [LALR(1), LR(0), SLR(1), and LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
# type grammars. To create the Jison parser, we list the pattern to match
# on the left-hand side, and the action to take (usually the creation of syntax
# tree nodes) on the right. As the parser runs, it
# shifts tokens from our token stream, from left to right, and
# [attempts to match](http://en.wikipedia.org/wiki/Bottom-up_parsing)
# the token sequence against the rules below. When a match can be made, it
# reduces into the [nonterminal](http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)
# (the enclosing name at the top), and we proceed from there.
#
# If you run the `coke build:parser` command, Jison constructs a parse table
# from our rules and saves it into [lib/parser.js](../lib/parser.js).

# Jison DSL
# ---------

# Since we're going to be wrapped in a function by Jison in any case, if our
# action immediately returns a value, we can optimize by removing the function
# wrapper and just returning the value directly.
unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/

# Our handy DSL for Jison grammar generation, thanks to
# [Tim Caswell](http://github.com/creationix). For every rule in the grammar,
# we pass the pattern-defining string, the action to run, and extra options,
# optionally. If no action is specified, we simply pass the value of the
# previous nonterminal.
o = (patterns, action, options) ->
  patterns.=trim().split /\s+/
  action &&= unwrap.exec(action).1
    .replace /\b(?!Er)[A-Z][\w.]*/g, \yy.$&
    .replace /\.L\(/g, '$&yylineno, '
  [patterns, action ? \$1, options]

# Grammatical Rules
# -----------------

# In all of the rules that follow, you'll see the name of the nonterminal as
# the key to a list of alternative matches. With each match's action, the
# dollar-sign variables are provided by Jison as references to the value of
# their numeric position, so in this rule:
#
#     "Expression MATH Expression"
#
# `$1` would be the value of the first _Expression_, `$2` would be the token
# value for the _MATH_ terminal, and `$3` would be the value of the second
# _Expression_.
bnf =
  # Everything that can be assigned to.
  Assignable: [
    o \SimpleAssignable
    o \Array
    o \Object
  ]

  # The types of things that can be accessed or indexed into.
  Value: [
    o \Assignable    ,-> Value $1
    o \STRNUM        ,-> Value L Literal $1
    o \LITERAL       ,-> Value L Literal $1, true
    o \Parenthetical ,-> Value $1
    o \THIS          ,-> Value L Literal \this, true

    o 'Value CALL( ArgList OptComma )CALL' ,-> Value L Call $1, $3, $2
  ]

  # Variables and properties that can be assigned to.
  SimpleAssignable: [
    o \IDENTIFIER ,-> L Literal $1
    o \ThisProperty

    o 'Value DOT IDENTIFIER'           ,-> $1.add L Index L(Key     $3) ,$2
    o 'Value DOT STRNUM'               ,-> $1.add L Index L(Literal $3) ,$2
    o 'Value DOT Parenthetical'        ,-> $1.add L Index $3.it         ,$2
    o 'Value DOT [ ArgList OptComma ]' ,-> $1.add L Index $4            ,$2

    o 'Value CLONE Object' ,-> new Clone $1.unwrap(), $3

    o \SUPER ,-> L new Super
  ]

  # All the different types of expressions in our language.
  Expression: [
    o \Value ,-> $1.unwrap()

    o 'Assignable ASSIGN Expression' ,-> L Assign $1, $3, $2

    o 'CREMENT SimpleAssignable' ,-> L Op $1, $2
    o 'SimpleAssignable CREMENT' ,-> L Op $2, $1, null, true

    # Arithmetic and logical operators, working on one or two operands.
    # The precedence rules are defined at the bottom of the page.
    # It would be shorter if we could combine most of these rules into
    # a single generic "Operand OpSymbol Operand"-type rule,
    # but in order to make the precedence binding possible, separate
    # rules are necessary.
    o 'UNARY Expression' , -> L Op $1, $2
    o '+-    Expression' ,(-> L Op $1, $2), prec: \UNARY

    o 'Expression +-       Expression' ,-> L Op $2, $1, $3
    o 'Expression MATH     Expression' ,-> L Op $2, $1, $3
    o 'Expression SHIFT    Expression' ,-> L Op $2, $1, $3
    o 'Expression COMPARE  Expression' ,-> L Op $2, $1, $3
    o 'Expression BITWISE  Expression' ,-> L Op $2, $1, $3
    o 'Expression LOGIC    Expression' ,-> L Op $2, $1, $3
    o 'Expression RELATION Expression' ,->
      L if $2.charAt(0) is \!
      then Op($2.slice 1; $1; $3).invert()
      else Op $2, $1, $3

    o 'Expression IMPORT Expression' ,-> L Import $1, $3, $2 is \<<<<

    o 'Expression ?' ,-> Existence $1

    # Functions can be either anonymous, or named using `function` keyword.
    o \Function
    o 'FUNCTION Function' ,-> $2.named $1

    # The full complement of `if` and `unless` expressions,
    # including postfix one-liners.
    o \IfBlock
    o 'IfBlock ELSE Block'            ,-> $1.addElse $3
    o 'Expression POST_IF Expression' ,-> L If $3, $1, name: $2

    # Loops can either be normal, with a block of expressions
    # to execute, or postfix, with a single expression.
    o 'LoopHead   Block'    ,-> $1.addBody $2
    o 'Expression LoopHead' ,-> $2.addBody Block $1

    o 'RETURN Expression' ,-> L Return $2
    o \RETURN             ,-> L Return()
    o \STATEMENT          ,-> L new Statement $1
    o 'THROW  Expression' ,-> L new Throw $2

    o 'SWITCH Expression Cases'               ,-> L new Switch $2, $3
    o 'SWITCH Expression Cases DEFAULT Block' ,-> L new Switch $2, $3, $5
    o 'SWITCH Cases'                          ,-> L new Switch null, $2
    o 'SWITCH Cases DEFAULT Block'            ,-> L new Switch null, $2, $4

    o 'TRY Block'                           ,-> L new Try $2
    o 'TRY Block CATCH Block'               ,-> L new Try $2, $3, $4
    o 'TRY Block CATCH Block FINALLY Block' ,-> L new Try $2, $3, $4, $6
    o 'TRY Block             FINALLY Block' ,-> L new Try $2, null, null, $4

    # A class definition have a title, superreference, or body,
    # each of which is optional.
    o 'CLASS OptExtends'                        ,-> L new Class null, $2
    o 'CLASS OptExtends Block'                  ,-> L new Class null, $2, $3
    o 'CLASS SimpleAssignable OptExtends'       ,-> L new Class $2, $3
    o 'CLASS SimpleAssignable OptExtends Block' ,-> L new Class $2, $3, $4

    o 'SimpleAssignable EXTENDS Expression' ,-> Util.Extends $1, $3
  ]

  # A line of Coco can be either an expression, backcall, comment, or
  # [yadayadayada](http://search.cpan.org/~tmtm/Yada-Yada-Yada-1.00/Yada.pm).
  Line: [
    o \Expression

    o 'PARAM( ArgList OptComma )PARAM BACK_CALL Expression'
    , -> Call.back $2, $5, $6
    o 'IDENTIFIER BACK_CALL Expression' ,-> Call.back [L Literal $1], $2, $3
    o            'BACK_CALL Expression' ,-> Call.back [            ], $1, $2

    o \COMMENT ,-> L new Comment $1
    o \...     ,-> L new Throw JS "Error('stub code executed')"
  ]
  # A list of lines, separated by newlines or semicolons.
  Body: [
    o \Line                  ,-> Block $1
    o 'Body TERMINATOR Line' ,-> $1.add $3
    o 'Body TERMINATOR'
  ]

  # An optional, trailing comma.
  OptComma: [
    o '' 0
    o \, 0
  ]

  Arg: [
    o     \Expression
    o '... Expression' ,-> L Splat $2
    o \...             ,-> L Splat Arr()
  ]
  # **ArgList** is either the list of objects passed into a function call,
  # the parameter list of a function, or the contents of an array literal
  # (i.e. comma-separated expressions). Newlines work as well.
  ArgList: [
    o ''                                                ,-> []
    o \Arg                                              ,-> [$1]
    o 'ArgList , Arg'                                   ,-> $1.concat $3
    o 'ArgList OptComma TERMINATOR Arg'                 ,-> $1.concat $4
    o 'ArgList OptComma INDENT ArgList OptComma DEDENT' ,-> $1.concat $4
  ]

  # A reference to a property on `this`.
  ThisProperty: [
    o \THISPROP ,-> Value L(Literal \this), [Index L Key $1], true
  ]

  Parenthetical: [
    o '(        Body        )' ,-> L Parens $2.unwrap()
    o '( INDENT Body DEDENT )' ,-> L Parens $3.unwrap()
  ]

  # An indented block of expressions. Note that [Rewriter](#rewriter)
  # converts some single-line forms into blocks for us.
  Block: [
    o 'INDENT Body DEDENT' ,-> $2
    o 'INDENT      DEDENT' ,-> Block()
  ]

  # **Function** is the function literal, defined by an indented **Block**
  # preceded by an optional parameter list and a function arrow.
  Function: [
    o 'PARAM( ArgList OptComma )PARAM FUNC_ARROW Block' ,-> L Fun $2, $6, $5
    o                                'FUNC_ARROW Block' ,-> L Fun [], $2, $1
  ]

  Array: [
    o '[ ArgList OptComma ]' ,-> L Arr $2
  ]

  # Things that can be keys within an object literal.
  Key: [
    o \IDENTIFIER ,-> L Literal $1
    o \STRNUM     ,-> L Literal $1
    o \Parenthetical
    o \ThisProperty
  ]
  Property: [
    o 'Key :        Expression'        ,-> L Assign $1.asKey(), $3, \:
    o 'Key : INDENT Expression DEDENT' ,-> L Assign $1.asKey(), $4, \:

    o \Key
    o '... Key' ,-> L Splat  $2
    o '+-  Key' ,-> L Assign $2.asKey(), Literal($1 is \+), \:

    o 'Key LOGIC Expression' ,-> L Op $2, $1, $3

    o \COMMENT ,-> L new Comment $1
  ]
  # Properties within an object literal can be separated by
  # commas, as in JavaScript, or simply by newlines.
  Properties: [
    o ''                                                      ,-> []
    o \Property                                               ,-> [$1]
    o 'Properties , Property'                                 ,-> $1.concat $3
    o 'Properties OptComma TERMINATOR Property'               ,-> $1.concat $4
    o 'Properties OptComma INDENT Properties OptComma DEDENT' ,-> $1.concat $4
  ]
  Object: [
    o '{ Properties OptComma }' ,-> L Obj $2
  ]

  # The most basic form of `if` is a condition and an action. The following
  # `if`-related rules are broken up along these lines to avoid ambiguity.
  IfBlock: [
    o 'IF Expression Block'              ,-> L If $2, $3, name: $1
    o 'IfBlock ELSE IF Expression Block' ,-> $1.addElse L If $4, $5, name: $3
  ]

  LoopHead: [
    # The source of a `for`-loop is an array, object, or range.
    # Unless it's iterating over an object, you can choose to step through
    # in fixed-size increments.
    o 'FOR Assignable FOROF Expression'
    , -> L new For name: $2, index: $3, source: $4
    o 'FOR Assignable FOROF Expression BY Expression'
    , -> L new For name: $2, index: $3, source: $4, step: $6

    o 'FOR IDENTIFIER              FORIN Expression'
    , -> L new For object: true, own: !$1, index: $2,           source: $4
    o 'FOR IDENTIFIER , Assignable FORIN Expression'
    , -> L new For object: true, own: !$1, index: $2, name: $4, source: $6

    o 'FOR IDENTIFIER FROM Expression'
    , -> L new For index: $2, from: Literal(0), op: \til, to: $4
    o 'FOR IDENTIFIER FROM Expression TO Expression'
    , -> L new For index: $2, from: $4, op: $5, to: $6
    o 'FOR IDENTIFIER FROM Expression TO Expression BY Expression'
    , -> L new For index: $2, from: $4, op: $5, to: $6, step : $8

    o 'WHILE Expression' ,-> L new While $2, $1
    o 'FOR EVER'         ,-> L new While
  ]

  Cases: [
    o       'CASE Expression Block' ,-> [L new Case $2, $3]
    o 'Cases CASE Expression Block' ,-> $1.concat L new Case $3, $4
  ]

  # Optional `extends` clause for class definition.
  OptExtends: [
    o ''                   ,-> null
    o 'EXTENDS Expression' ,-> $2
  ]

  # **Root** is the top-level node in the syntax tree.
  # Since we parse bottom-up, all parsing must end here.
  Root: [
    o \Body
    o 'Block TERMINATOR'
    o '' ,-> Block()
  ]

# Precedence
# ----------
# Operators at the top of this list have higher precedence than the ones lower
# down as in [Yacc](http://dinosaur.compilertools.net/yacc/index.html).
# Following these rules is what makes `2 + 3 * 4` parse as:
#
#     2 + (3 * 4)
#
# And not:
#
#     (2 + 3) * 4
operators = [
  <[ nonassoc  CREMENT      ]>
  <[ left      ?            ]>
  <[ right     UNARY        ]>
  <[ left      MATH         ]>
  <[ left      +-           ]>
  <[ left      SHIFT IMPORT ]>
  <[ left      RELATION     ]>
  <[ left      COMPARE      ]>
  <[ left      BITWISE      ]>
  <[ left      LOGIC        ]>
  <[ right     : ASSIGN RETURN THROW EXTENDS INDENT ]>
  <[ right     IF ELSE SWITCH CASE DEFAULT CLASS FORIN FOROF FROM TO BY ]>
  <[ left      POST_IF FOR WHILE ]>
# Reverse them because Jison orders precedence from low to high.
].reverse()

# Wrapping Up
# -----------

# Process all of our rules and prepend resolutions, while recording all
# terminals (every symbol which does not appear as the name of a rule above)
# as `tokens`.
tokens = (
  for name, alternatives in bnf
    for alt of alternatives
      alt.1 = "#{ if name is \Root then \return else '$$ =' } #{alt.1};"
      token if token not in bnf for token of alt.0
).join ' '

# Finally, initialize the `parser` with `bnf`, `operators`, `tokens`,
# and the name of the root.
exports.parser =
  new (require \jison).Parser {bnf, operators, tokens, startSymbol: \Root}
