# Contains all of the node classes for the syntax tree. Most
# nodes are created as the result of actions in the [grammar](#grammar),
# but some are created by other nodes as a method of code generation. To convert
# the syntax tree into a string of JavaScript code, call `compileRoot`.

### Node
# The abstract base class for all nodes in the syntax tree.
# Each subclass implements the `compileNode` method, which performs the
# code generation for that node. To compile a node to JavaScript,
# call `compile` on it, which wraps `compileNode` in some generic extra smarts.
# An options hash is passed and cloned throughout, containing information about
# the environment from higher in the tree (such as if a returned value is
# being requested by the surrounding function), information about the current
# scope, and indentation level.
class Node
  compile: (options, level) ->
    o = {}; continue for key, o[key] in options
    o import {level} if level?
    node = @unfoldSoak o or this
    # If a statement appears within an expression, wrap it in a closure.
    return node.compileClosure o if o.level and node.isStatement o
    code = (node import tab: o.indent)compileNode o
    o.scope.free tmp for tmp of node.temps if node.temps
    code

  compileClosure: (o) ->
    # Statements that _jump_ out of current context (like `return`) can't be
    # an expression via closure-wrapping, as their meaning will change.
    that.carp 'inconvertible statement' if @jumps()
    # The wrapper shares a scope with its parent closure
    # to preserve the expected lexical scope.
    (fun = Fun [] Block this)wrapper = true
    args = []
    if @contains(-> it.value is \this)
      args.push Literal \this
      method = \.call
    mentionsArgs = false
    @traverseChildren ->
      mentionsArgs := it.value = \_args if it.value is \arguments
      void
    if mentionsArgs
      args.push Literal \arguments
      fun.params.push Var \_args
    Parens(Chain(fun, [Call(args) <<< {method}]), true)compileNode o

  # Compiles a child node as a block statement.
  compileBlock: (o, name) ->
    code = \\n + that + \\n + @tab if @[name]?.compile o, LEVEL_TOP
    "{#{ code or '' }}"

  # If the code generation wishes to use the result of a complex expression
  # in multiple places, ensure that the expression is only ever evaluated once,
  # by assigning it to a temporary variable.
  cache: (o, once, level) ->
    unless @isComplex()
      return [ref = if level? then @compile o, level else this, ref]
    sub = Assign ref = Var(o.scope.temporary \ref), this
    # Pass a `level` to precompile.
    return [sub.compile o, level; ref.value] if level?
    # If flagged as `once`, the tempvar will be auto-freed.
    if once then [sub, ref <<< {+temp}] else [sub, ref, [ref.value]]

  # Compiles to a source/variable pair suitable for looping.
  compileLoopReference: (o, name) ->
    src = tmp = @compile o, LEVEL_LIST
    unless -1/0 < +src < 1/0 or this instanceof Var and o.scope.check src
      src = "#{ tmp = o.scope.temporary name } = #{src}"
    [src, tmp]

  # Passes each child to a function, returning its return value if exists.
  eachChild: (fn) ->
    for name of @children then if child = @[name]
      if \length in child
      then return that if fn(node )? for node of child
      else return that if fn(child)?
    void

  # Performs `eachChild` on every descendant.
  # Overridden by `Fun` not to cross scope by default.
  traverseChildren: (fn, xscope) ->
    @eachChild -> if fn(it)? then that else it.traverseChildren fn, xscope

  # Do I, or any of my children, contain a node of a certain kind?
  # Recursively traverses down the nodes' descendants and passess them to
  # `pred`, returning `true` when it finds a match.
  # Does not cross scope boundaries.
  contains: (pred) -> !!@traverseChildren -> pred it or null

  # Performs anaphoric conversion if a `that` is found within `@[@aTarget]`.
  anaphorize: ->
    @children = [@aTarget]
    if @eachChild hasThat
      if (base = this)[name = @aSource] instanceof Existence
        base.=[name]; name = \it
      base[name] = Assign Var(\that), base[name]
    delete @children
    void
  function hasThat ->
    it.value is \that or if it.aSource
    then hasThat that if it[that]
    else it.eachChild hasThat

  # Throw a syntax error, appending `@line` number to the message.
  carp: ->
    throw SyntaxError "#{it} on line #{ @line or @traverseChildren -> it.line }"

  # Default implementations of the common node properties and methods. Nodes
  # will override these with custom logic, if needed.
  children: []

  terminator: \;

  isComplex    : YES
  isStatement  : NO
  isAssignable : NO
  isCallable   : NO
  isEmpty      : NO
  isAccessor   : NO
  # Do I contain a statement that jumps out of me?
  jumps: NO
  # Do I assign a certain variable?
  assigns: NO
  # Do I hold a default value in an assignment context?
  hasDefault: NO

  unfoldSoak   : NO
  unfoldAssign : NO
  unwrap       : THIS
  asKey        : THIS
  asArr        : THIS
  varName      : String
  selections   : NO
  getCall      : NO

  invert: -> Op \! this

  # Constructs a node that returns the current node's result.
  makeReturn: (arref) ->
    if arref then Call.make JS(arref + \.push), [this] else Return this

  # Extra info for `toString`.
  show: String

  # String representation of the node for inspecting the parse tree.
  # This is what `coco --nodes` prints out.
  toString: (idt or '') ->
    tree = \\n + idt + @constructor.displayName
    tree += ' ' + that if @show()
    @eachChild -> tree += it.toString idt + TAB; void
    tree

  # JSON serialization
  stringify : (space) -> JSON.stringify this, null space
  toJSON    : -> {type: @constructor.displayName, ...this}

# JSON deserialization
exports.parse    = (json) -> exports.fromJSON JSON.parse json
exports.fromJSON = function ->
  return it unless it and typeof it is \object
  if it.type
    node = exports[it.type]::{}
    node[key] = fromJSON val for key, val in it
    return node
  if it.length? then fromJSON v for v of it else it

#### Modules

Negatable =
  show   : -> @negated and \!
  invert : -> @negated ^= 1; this

#### Block
# A list of expressions that forms the body of an
# indented block of code--the implementation of a function, a clause in an
# `if`, `switch`, `try`, and so on.
class exports.Block extends Node
  (node) ~>
    return node if node instanceof Block
    @lines = []
    @add node if node

  children: [\lines]

  add: ->
    if @back
      that.add it
    else if it.lines
      @lines.push ...that
    else
      @lines.push it
      @back = that if it.back
    this

  unwrap: -> if @lines.length is 1 then @lines.0 else this

  asArr: -> Arr @lines

  isComplex: -> @lines.length > 1 or @lines.0?.isComplex()

  isStatement: (o) ->
    return true if o and not o.level
    return true if node.isStatement o for node of @lines

  isCallable: -> that.isCallable() if lastNonComment(@lines)0

  jumps: -> return that if node.jumps it for node of @lines

  # **Block** does not return its entire body, rather it
  # ensures that the final line is returned.
  makeReturn: ->
    [node, i] = lastNonComment @lines
    if node
      @lines[i] = node.=makeReturn it
      @lines.splice i, 1 if node instanceof Return and not node.it
    this

  compileNode: (o) ->
    o.block = this
    codes = []; top = not o.level
    for node of @lines
      node = node.unfoldSoak o or node
      if top
        code = (node <<< {+front})compile o
        code = o.indent + code + node.terminator unless node.isStatement o
      else
        continue if node.comment
        code = node.compile o, LEVEL_LIST
      codes.push code
    return codes.join \\n if top
    code = codes.join ', ' or 'void 8'
    if codes.length > 1 and o.level >= LEVEL_LIST then "(#{code})" else code

  # **Block** is the only node that can serve as the root.
  compileRoot: (options) ->
    o = {level: LEVEL_TOP, scope: @scope = Scope.root = new Scope} <<<< options
    o.indent = @tab = if bare = delete o.bare then '' else TAB
    shebang  = (first = @lines.0) instanceof JS and
               ~first.code.lastIndexOf \#! 0 and @lines.shift()code
    if delete o.repl
      if bare
        [node, i] = lastNonComment @lines
        @lines[i] = Parens node if node
      else
        @makeReturn()
    code = @compileWithDeclarations(o)replace /[^\n\S]+$/gm ''
    # If we happen to be the top-level **Block**, wrap everything in
    # a safety closure, unless requested not to.
    code = "(function(){\n#{code}\n}).call(this);\n" unless bare
    if shebang then code = shebang + \\n + code else code

  # Compile the expressions body for the contents of a function, with
  # declarations of all inner variables pushed up to the top.
  compileWithDeclarations: (o) ->
    o.level = LEVEL_TOP
    code = post = ''
    for node, i of @lines
      break unless node.comment or node instanceof Literal
    if i
      rest   = @lines.splice i, 9e9
      code   = @compileNode o
      @lines = rest
    code &&+= \\n if post = (if @lines.length then @compileNode o else '')
    code += o.indent + that + \;\n if @scope?.vars o
    code + post

#### Atom
# An abstract node for simple values.
class Atom extends Node
  show      : -> @value
  isComplex : NO

#### Literal
# `this`, regexes, and primitive values.
class exports.Literal extends Atom
  (@value) ~> return JS "#{value}" true if value.js

  isEmpty    : -> switch @value case <[ void null ]> then true
  isCallable : -> switch @value case <[ this eval ]> then true

  compile: (o, level ? o.level) ->
    switch val = @value
    case \this     then return o.scope.fun?.bound or val
    case \void     then val += ' 8'; fallthrough
    case \null     then @carp 'invalid use of ' + @value if level is LEVEL_CALL
    case \debugger then return '(function(){ debugger }())' if level
    case \*        then return '0'
    val

#### Var
# Variables.
class exports.Var extends Atom
  (@value) ~>

  isAssignable : YES
  isCallable   : YES

  assigns: -> it is @value

  asKey: -> Key(@value) <<< {@line}

  varName: @::show

  compile: (o) ->
    o.scope.free @value if @temp
    @value

#### Key
# The name of a property, in the form of `{key: _}` or `_.key`.
class exports.Key extends Atom
  (name, @reserved or name.reserved) ~> @name = '' + name

  isAssignable: -> not @reserved

  compile: @::show = -> if @reserved then "'#{@name}'" else @name

#### Index
# Dots and brackets to access an object's property.
class exports.Index extends Node
  (@key, @symbol) ~>
    switch key.length
    case 0 then @key = Key \__proto__
    case 1 then @key = key.0
    @assign = symbol.slice 1 if \= is symbol?.slice -1

  children: [\key]

  show: -> @symbol

  isComplex: -> @key.isComplex()

  compile: (o) ->
    code = @key.compile o, LEVEL_PAREN
    if @key instanceof Key and \' is not code.charAt 0
    then ".#{code}" else "[#{code}]"

#### Chain
# Acts as a container for property-access/function-call chains, by holding
# __Index__ or __Call__ instances as `@tails`.
class exports.Chain extends Node
  (head, tails) ~>
    return head if not tails and head instanceof Chain
    @<<<{head, tails or []}

  children: <[ head tails ]>

  add: -> @tails.push it; this

  # __Chain__ can be unwrapped as its inner node, if there are no subnodes.
  unwrap: -> if @tails.length then this else @head

  jumps        : -> not @tails.length and @head.jumps it
  assigns      : -> not @tails.length and @head.assigns it
  isStatement  : -> not @tails.length and @head.isStatement it
  isComplex    : -> @tails.length or do @head.isComplex
  isCallable   : -> @tails.length or do @head.isCallable
  isAssignable : ->
    if @tails[*-1]
    then that instanceof Index
    else @head.isAssignable

  makeReturn: -> if @tails.length then super ... else @head.makeReturn it

  getCall: -> (tail = @tails[*-1]) instanceof Call and tail

  varName: ->
    {key} = that if @tails[*-1]
    if key instanceof Key
      {name} = key
      name = \$ + name if key.reserved or name of <[ arguments eval ]>
    else if key instanceof Literal and /^[$\w]+$/test key.value
      name = \$ + key.value
    name or ''

  # A reference has base part (`this` value) and name part.
  # We cache them separately for compiling complex expressions, so that e.g.
  #
  #     a()[b()] ||= c
  #
  # compiles to
  #
  #     (_base = a())[_name = b()] || (_base[_name] = c);
  #
  cacheReference: (o) ->
    name = @tails[*-1]
    return @cache o, true if name instanceof Call
    # `a` `a.b`
    if @tails.length < 2 and not @head.isComplex() and not name?.isComplex()
      return [this, this]
    base = Chain @head, @tails.slice 0 -1
    # `a().b`
    if base.isComplex()
      ref  = o.scope.temporary \ref
      base = Chain Assign Var(ref), base
      bref = Var(ref) <<< {+temp}
    # `a{}`
    return [base, bref] unless name
    # `a[b()]`
    if name.isComplex()
      ref  = o.scope.temporary \key
      name = Index Assign Var(ref), name.key
      nref = Index Var(ref) <<< {+temp}
    [base.add name; Chain bref || base.head, [nref or name]]

  SIMPLENUM = /^\d+$/

  compileNode: (o) ->
    @head import {@front, @newed}
    return @head.compile o unless @tails.length
    return that .compile o if @unfoldAssign o
    if @tails.0 instanceof Call and not @head.isCallable()
      @carp 'invalid callee'
    @expandArray o; @expandBind o; @expandSplat o; @expandStar o
    base = @head.compile o, LEVEL_CALL; rest = ''
    for t of @tails
      base = 'new ' + base if t.new
      rest += t.compile o
    base += ' ' if \. is rest.charAt 0 and SIMPLENUM.test base
    base + rest

  # Unfolds a soak into an __If__: `a?.b` -> `a.b if a?`
  unfoldSoak: (o) ->
    if @head.unfoldSoak o
      that.then.tails.push ...@tails
      return that
    for node, i of @tails
      if node.soak
        node.soak = ''
        [test, @head] = Chain(@head, @tails.splice 0 i)cacheReference o
        return If do
          JS "typeof #{ test.compile o, LEVEL_OP } == 'function'"
          this, {+soak}
      else if node.symbol is \?.
        node.symbol = ''
        [test, @head] = Chain(@head, @tails.splice 0 i)unwrap()cache o, true
        return If Existence(test), this, {+soak}
    void

  unfoldAssign: (o) ->
    if @head.unfoldAssign o
      that.right.tails.push ...@tails
      return that
    for index, i of @tails then if index.assign
      index.assign = ''
      [left, @head] = Chain(@head, @tails.splice 0 i)cacheReference o
      return Assign(left, this, that) <<< {+access}
    void

  expandSplat: (o) ->
    {tails} = this; i = -1
    while call = tails[++i]
      {thisplat, args} = call
      continue unless thisplat or args &&= Splat.compileArray o, args, true
      @carp 'splatting "new"' if call.new
      call.method = \.apply
      if thisplat
        delete call.thisplat
        continue
      if tails[i-1] instanceof Index
        [@head, ref] = Chain(@head, tails.splice 0 i-1)cache o, true
        i = 0
      call.args = [ref or Literal(\null), JS args]
    void

  expandBind: (o) ->
    {tails} = this; i = -1
    while index = tails[++i]
      continue unless index.symbol is \~.
      index.symbol = ''
      args   = Chain(@head, tails.splice 0 i)unwrap()cache o, true
      args.1 = Chain args.1, [tails.shift()]
      call   = Call.make Util(\bind), args
      @head  = if @newed then Parens call, true else call
      i = -1
    void

  expandStar: (o) ->
    {tails} = this; i = -1
    while index = tails[++i]
      continue if index.args or index.stars or index.key instanceof Key
      stars = index.stars = []
      index.eachChild seek
      continue unless stars.length
      [sub, ref, temps] = Chain(@head, tails.splice 0 i)unwrap()cache o
      ref += ' ' if SIMPLENUM.test ref.=compile o
      star.value = ref + \.length for star of stars
      @head = JS sub.compile(o, LEVEL_CALL) + tails.shift()compile o
      o.scope.free temps.0 if temps
      i = -1
    function seek ->
      if it.value is \*               then stars.push it
      else unless it instanceof Index then it.eachChild seek
      void
    void

  expandArray: (o) ->
    {tails} = this; i = -1
    while index = tails[++i] then if index.key?.length
      [sub, ref, temps] = Chain(@head, tails.splice 0 i)unwrap()cache o
      @head = JS Arr do
        Chain if j then ref else sub, [Index n] for n, j of tails.shift()key
      .compile o
      o.scope.free temps.0 if temps
      i = -1
    void

#### Call
# `x(y)`
class exports.Call extends Node
  (args or [], sym) ~>
    if args.length is 1 and args.0 instanceof Splat and args.0.it.isEmpty()
      @thisplat = true; args = [Literal \this; Literal \arguments]
    @<<<{args, soak: sym is \?( and \?}

  children: [\args]

  show: -> (@new or '') + (@soak or '') + (@thisplat or '')

  compile: (o) ->
    "#{@method || ''}(#{ (a.compile o, LEVEL_LIST for a of @args)join ', ' })"

  @make = (callee, args) -> Chain(callee)add Call args

  @back = (params, arrow, node) ->
    (call = node.getCall()) or node = Chain(node)add call = Call()
    {args} = call
    break if a instanceof Splat and a.it.isEmpty() for a, i of args
    node import back: (args[i] = Fun params, null, arrow.charAt(1) + \>)body

  @let = (fun) ->
    args = fun.params; ps = fun.params = []
    for a, i of args then ps.push do
      if a.op is \= and not a.logic
      then args[i] = a.right; a.left
      else if a.varName()
      then Var that
      else a.carp 'invalid "let" argument'
    if delete fun.bound
      fun.method = \.call
      args.unshift Literal \this
    Parens @make fun, args

#### Clone
# An operation that creates a new object with its `__proto__`
# set to the operand, attaching specified properties.
class exports.Clone extends Node
  (@base, @mixins) ->

  children: <[ base mixins ]>

  unfoldSoak: -> If.unfoldSoak it, this, \base

  compileNode: (o) ->
    Import(Call.make(Util \clone; [@base]), Obj @mixins)compileNode o

#### List
# An abstract node for a list of items.
class List extends Node
  children : [\items]
  isEmpty  : -> not @items.length

#### Obj
# `{x: y}`
class exports.Obj extends List
  (@items or []) ~>

  asObj: THIS

  assigns: -> return true if node.assigns it for node of @items

  compileNode: (o) ->
    {items} = this
    return (if @front then '({})' else '{}') unless items.length
    code = ''; idt = \\n + o.indent += TAB; dic = {}
    for node, i of items
      if node.comment
        code += idt + node.compile o
        continue
      node.=first if logic = node.hasDefault()
      if node instanceof Splat or (node.left or node) instanceof Parens
        rest = items.slice i
        break
      if multi then code += \, else multi = true
      code += idt + if node instanceof Assign
        key = node.left.compile o
        if node.isAccessor()
          fun = node.right.first
          key = "#{ if fun.params.length then \set else \get } #{key}"
          key + fun.compile(o, LEVEL_LIST)slice 8
        else
          node.compile o
      else
        "#{ key = node.compile o }: #{key}"
      dic[0 + key] = 0 + key in dic and
        node.carp "duplicate property name \"#{key}\""
      logic and code += """ #{
        if logic.op is \? then "!= null ? #{key} :" else logic.op
      } """ + logic.second.compile o, LEVEL_OP
    code = "{#{ code and code + \\n + @tab }}"
    if rest
    then Import(JS code; Obj rest)compile o <<< indent: @tab
    else if @front then "(#{code})" else code

#### Arr
# `[x, y]`
class exports.Arr extends List
  (@items or []) ~>

  selections: -> @items.length > 1 and @items

  asObj: -> Obj(Assign Literal(i), item, \: for item, i of @items)

  compileNode: (o) ->
    {items} = this
    return '[]' unless items.length
    if code = Splat.compileArray o, items
      return if @newed then "(#{code})" else code
    o.indent += TAB
    code = (obj.compile o, LEVEL_LIST for obj of items)join ', '
    if 0 < code.indexOf \\n
    then "[\n#{o.indent}#{code}\n#{@tab}]"
    else "[#{code}]"

#### Op
# Simple Arithmetic and logical operations, with some special conversions.
class exports.Op extends Node
  (op, first, second, post) ~>
    switch op
    case \of then return new Of first, second
    case \do then return Parens Call.make first
    case \new
      first.newed = true
      if first instanceof Chain
        for node of first.tails then if node instanceof Call
          node.new = true
          return first
    @<<<{op, first, second, post}

  children: <[ first second ]>

  show: -> @op

  isCallable: -> switch @op case <[ && || ? new delete ]>
    @first.isCallable() or @second?.isCallable()

  EQUALITY = /^[!=]==?$/
  COMPARER = /^(?:[!=]=|[<>])=?$/

  invert: ->
    if EQUALITY.test op = @op and not COMPARER.test @second.op
      @op = '!='charAt(op.indexOf \=) + op.slice 1
      return this
    return Op \! Parens this if @second
    return @first if op is \! and @first.op of <[ ! in instanceof < > <= >= ]>
    Op \! this

  unfoldSoak: (o) ->
    @op of <[ ++ -- delete ]> and If.unfoldSoak o, this, \first

  hasDefault: -> switch @op case <[ ? || && ]> then this

  compileNode: (o) ->
    return @compileUnary o unless @second
    switch @op
    case \?          then return @compileExistence o
    case \instanceof then return @compileIOS o, that if @second.selections()
    default if COMPARER.test @op and COMPARER.test @second.op
      return @compileChain o
    @first import {@front}
    code = "#{ @first .compile o, level = LEVEL_OP + PREC[@op] } #{@op} \
            #{ @second.compile o, level }"
    if o.level <= level then code else "(#{code})"

  # Mimic Python's chained comparisons when multiple comparison operators are
  # used sequentially. For example:
  #
  #     $ coco -e 'console.log 50 < 65 === 9r72 > 10'
  #     true
  #
  # See <http://docs.python.org/reference/expressions.html#notin>.
  compileChain: (o) ->
    code = @first.compile o, level = LEVEL_OP + PREC[@op]
    [sub, @second.first] = @second.first.cache o, true
    code += " #{@op} #{ sub    .compile o, level    } && \
                     #{ @second.compile o, LEVEL_OP }"
    if o.level <= LEVEL_OP then code else "(#{code})"

  compileExistence: (o) ->
    unless o.level
      return Op(\&& Existence(@first)invert(), @second)compileNode o
    fsts = @first.cache o, true
    code = Existence(fsts.0)compile(o, LEVEL_COND) +
           ' ? ' + fsts.1  .compile(o, LEVEL_LIST) +
           ' : ' + @second .compile(o, LEVEL_LIST)
    if o.level < LEVEL_COND then code else "(#{code})"

  compileUnary: (o) ->
    {op, first} = this
    switch op
    case \delete
      @carp 'invalid deletion' if first instanceof Var or !first.isAssignable()
      return @compileDelete o if o.level
    case <[ ++ -- ]>
      if first instanceof Var and not o.scope.check first.value, true
        @carp "modification of undeclared variable \"#{first.value}\""
    case \classof
      return "#{ utility \toString }.call(
              #{ first.compile o, LEVEL_LIST }).slice(8, -1)"
    first.carp 'invalid constructor' if op is \new and not first.isCallable()
    code = first.compile o, LEVEL_OP + PREC.unary
    if @post
      code += op
    else
      op += ' ' if op of <[ new typeof delete ]> or
                   op of <[ + - ]> and first.op is op
      code = op + code
    if o.level < LEVEL_CALL then code else "(#{code})"

  # `x instanceof [A, B]`
  compileIOS: (o, items) ->
    code = ''; [sub, ref] = @first.cache o, false level = LEVEL_OP + PREC\<
    for item, i of items
      code += "#{ if i then ' || ' + ref else sub } instanceof \
               #{ item.compile o, level }"
    sub is ref or o.scope.free ref
    if o.level <= LEVEL_OP then code else "(#{code})"

  # `v = delete o.k`
  compileDelete: (o) ->
    code = ref = o.scope.temporary \ref
    [get, del] = Chain(@first)cacheReference o
    code += " = #{ get.compile o, LEVEL_LIST }
       , delete #{ del.compile o, LEVEL_LIST }, #{ref}"
    if o.level < LEVEL_LIST then code else "(#{code})"

#### Assign
# Assignment to a local variable or the property of an object,
# including `:` within object literals.
class exports.Assign extends Node
  (@left, @right, @op or \=, @logic or @op.logic) ~> @op += ''

  children: <[ left right ]>

  show: -> (@logic or '') + @op

  assigns: -> @[if @op is \: then \right else \left]assigns it

  isAccessor: ->
    @right.op is \~ and
    (fun = @right.first) instanceof Fun and fun.params.length < 2

  isCallable: -> switch @op case <[ = := ]> then @right.isCallable()

  unfoldSoak: (o) -> If.unfoldSoak o, this, \left

  unfoldAssign: -> @access and this

  METHOD_DEF = /// ^
    (?: ([\s\S]+)\.prototype(?=\.) | [\s\S]*? )
    (?: (?:\.|^) ([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)
      | \[ ( ([\"\']).+?\4 | \d+ ) ] )
  $ ///

  compileNode: (o) ->
    {right} = this
    return (Parens(right) <<< {@front, @newed})compile o if @left.isEmpty()
    left = @transleft(o)unwrap()
    if left.items
      return @compileDestructuring o, left unless @logic
      @carp "indestructurable assignment #{@show()}"
    return @compileConditional o, left if @logic
    if left.hasDefault()
      right = Op left.op, right, left.second
      left.=first
    name = left.compile o, LEVEL_LIST
    # Keep track of the name of the base object
    # we've been assigned to, for correct internal references.
    if right instanceof [Fun, Class] and METHOD_DEF.exec name
      right.name ||= that.2 or that.3
      right.clas   = that if that.1
    val = right.compile o, LEVEL_LIST
    if @op is \:
      left.carp "invalid property name \"#{name}\"" if left.isComplex()
      return name + ': ' + val
    left.isAssignable() or
      left.carp "#{ left.compile o <<< indent: '', LEVEL_LIST } \
                 // invalid assignee"
    if left instanceof Var
      if @op is \=
        o.scope.declare name
      else unless o.scope.check name, true
        left.carp "assignment to undeclared variable \"#{name}\""
    code = name + " #{ if @op is \:= then \= else @op } " + val
    if o.level < LEVEL_COND then code else "(#{code})"

  compileConditional: (o, left) ->
    [test, @left] = Chain(left)cacheReference o
    Op(delete @logic, test, this)compileNode o

  # Implementation of recursive destructuring,
  # when assigning to an array or object literal.
  # See <http://wiki.ecmascript.org/doku.php?id=harmony:destructuring>.
  compileDestructuring: (o, left) ->
    {items} = left; len = items.length
    rite = @right.compile o, if len is 1 then LEVEL_CALL else LEVEL_LIST
    if (len > 1 or o.level) and
       (not IDENTIFIER.test rite or left.assigns rite)
      cache = "#{ rref = o.scope.temporary \ref } = #{rite}"
      rite  = rref
    list = @"rend#{ left.constructor.displayName }" o, items, rite
    o.scope.free rref  if rref
    list.unshift cache if cache
    list.push rite     if o.level or not list.length
    code = list.join ', '
    if list.length < 2 or o.level < LEVEL_LIST then code else "(#{code})"

  rendArr: (o, nodes, rite) ->
    for node, i of nodes
      continue if node.isEmpty()
      if node instanceof Splat
        node.carp 'multiple splats in an assignment' if ivar
        len = nodes.length; empty = (node.=it)isEmpty()
        if i is len - 1
          break if empty
          val = utility(\slice) + \.call( + rite + if i then ", #{i})" else \)
        else
          val = "#{rite}.length - #{ len - i - 1 }"
          # Optimize `(..., a) ->`.
          if empty and i is len - 2
            ivar = val
            continue
          start = i + 1; @temps = [ivar = o.scope.temporary \i]
          if empty then node = Var ivar else val = "
            #{len} <= #{rite}.length \
            ? #{ utility \slice }.call(#{rite}, #{i}, #{ivar} = #{val}) \
            : (#{ivar} = #{i}, [])"
        val = Var val
      else
        if (inc = ivar) and start < i then inc += " + #{ i - start }"
        val = Chain lr ||= Literal(rite), [Index Literal inc || i]
      Assign(node, val, @op)compile o, LEVEL_TOP

  rendObj: (o, nodes, rite) ->
    for node of nodes
      node.=it if splat = node instanceof Splat
      # `{a or b} = c` to `a = c.a or b`
      node.=first if logic = node.hasDefault()
      if node instanceof Parens
        [node, key] = Chain(node.it)cacheReference o
      else if node instanceof Assign
      then key = node.left; node.=right
      else key = node
      node = Var node.name if node instanceof Key
      node = logic import {first: node} if logic
      val  = Chain lr ||= Var(rite), [Index key.asKey()]
      val  = Import Obj(), val if splat
      Assign(node, val, @op)compile o, LEVEL_TOP

  # Resolves property destructuring.
  transleft: (o) ->
    {left} = this
    # `x{k} = o` to `{k: x.k} = o`
    if left instanceof Clone
      {base, mixins: items} = left
      if items.length > 1
      then [sub, ref, @temps] = base.cache o
      else sub = ref = base
      for node, i of items
        base = if i then ref else sub
        if node instanceof Assign
          node.right = Chain base, [Index node.right.asKey()]
        else
          # `o{k or v} = ..` to `{k: a.k or v} = ..`
          node.=first if logic = node.hasDefault()
          if node instanceof Parens
          # `a{(++i)} = b` to `{(_ref): a[_ref = ++i]} = b`
          then [node, key] = node.cache o, true; key = Parens key
          else key = node
          val = Chain base, [Index node.asKey()]
          val = logic import {first: val} if logic
          items[i] = Assign key, val, \:
      left = Obj items
    # `x[k] = a` to `[x[k]] = a`
    else if left instanceof Chain and
            (tail = left.tails[*-1]) instanceof Index and tail.key.length
      {key} = left.tails.pop()
      [sub, ref, @temps] = left.cache o
      left = Arr(Chain if i then ref else sub, [Index k] for k, i of key)
    left

#### Import
# Operators that copy properties from right to left.
class exports.Import extends Node
  (@left, @right, @all and \All) ~>
    if not all and left instanceof Obj and right.items
      return Obj left.items.concat right.asObj()items

  children: <[ left right ]>

  show: -> @all

  isCallable: -> @left.isCallable()

  compileNode: (o) ->
    if @all or not @right.items
      return Call.make Util("import#{ @all or '' }"), [@left, @right]
             .compileNode o
    {items} = @right.asObj()
    return @left.compile o unless items.length
    top = not o.level
    if items.length < 2 and (top or items.0 instanceof Splat)
    then sub = lref = @left
    else [sub, lref, @temps] = @left.cache o
    [delim, space] = if top then [\; \\n + @tab] else [\, ' ']
    delim += space
    code = ''
    for node of items
      code += if com then space else delim
      if com = node.comment
        code += node.compile o
        continue
      if node instanceof Splat
        code += Import(lref, node.it)compile o, LEVEL_TOP
        continue
      node.=first if logic = node.hasDefault()
      if dyna = node instanceof Parens
        [key, val] = node.it.cache o, true
      else if node instanceof Assign
        if node.isAccessor()
          fun = node.right.first
          code += "#{ lref.compile o }
            .__define#{ if fun.params.length then \S else \G }etter__
            (#{ node.left.compile o, LEVEL_LIST }
            , #{      fun.compile o, LEVEL_LIST })"
          continue
        {left: key, right: val} = node
      else
        key = val = node
      val = logic import {first: val} if logic
      asn = Assign Chain(lref, [Index if dyna then key else key.asKey()]), val
      code += asn.compile o, LEVEL_PAREN
    if sub is lref
    then code.=slice delim.length
    else code = sub.compile(o, LEVEL_PAREN) + code
    return code if top
    node instanceof Splat or
      code += (if com then ' ' else ', ') + lref.compile o, LEVEL_LIST
    if o.level < LEVEL_LIST then code else "(#{code})"

#### Of
# Handles `of` operation that tests if the left operand is included within
# the right operand, arraywise.
class exports.Of extends Node
  (@item, @array) ->

  children: <[ item array ]>

  @::<<<< Negatable

  compileNode: (o) ->
    items = @array.selections()
    level = if items then LEVEL_OP + PREC\== else LEVEL_LIST
    [sub, ref] = @item.cache o, false level
    if items
      code = ''
      [cmp, cnj] = if @negated then [' !== ' ' && '] else [' === ' ' || ']
      for item, i of items
        code += (if i then cnj + ref else sub) + cmp + item.compile o, level
      level = LEVEL_OP + PREC\||
    else
      code = "#{ utility \indexOf }.call(#{ @array.compile o, level }, #{ref}
            ) #{ if @negated then \< else \>= } 0"
      return code if sub is ref
      code = sub + ', ' + code
    o.scope.free ref unless sub is ref
    if o.level < level then code else "(#{code})"

#### Existence
# Checks a value for existence--not `undefined` nor `null`.
class exports.Existence extends Node
  (@it) ~>

  children: [\it]

  @::<<<< Negatable

  compileNode: (o) ->
    node = @it.unwrap()
    code = node.compile o, LEVEL_OP + PREC\==
    if node instanceof Var and not o.scope.check code, true
      [op, eq] = if @negated then <[ || = ]> else <[ && ! ]>
      code = "typeof #{code} #{eq}= 'undefined' #{op} #{code} #{eq}== null"
    else
      code += " #{ op = if @negated then \== else \!= } null"
    if o.level < LEVEL_OP + PREC[op] then code else "(#{code})"

#### Fun
# A function definition. This is the only node that creates a `new Scope`.
class exports.Fun extends Node
  (@params or [], @body or Block(), arrow) ~> @bound = \_this if arrow is \~>

  children: <[ params body ]>

  show: -> @bound

  named: -> @<<<{name: it, +statement}

  isCallable: YES

  # Short-circuit `traverseChildren` method to prevent it
  # from crossing scope boundaries by default.
  traverseChildren: (_, xscope) -> super ... if xscope

  isStatement: -> !!@statement

  makeReturn: -> if @statement then @<<<{+returns} else super ...

  compileNode: (o) ->
    pscope = o.scope
    sscope = pscope.shared or pscope
    scope  = o.scope = @body.scope =
      new Scope (if @wrapper then pscope else sscope), @wrapper && sscope
    scope.fun = this
    delete o.globals
    scope.assign \_proto @proto.compile(o) + \.prototype if @proto
    o.indent += TAB
    {params, body, name, tab} = this
    code = \function
    if @bound is \_this
      if @ctor
        scope.assign \_this 'new _ctor'
        code += """
           _ctor(){} _ctor.prototype = _proto;
          #{tab}function
        """
        body.add Return Literal \_this
      else if sscope.fun?.bound
      then @bound = that
      else sscope.assign \_this \this
    args = []; asns = []
    for p, i of params
      # `(a, ...b) ->` to `-> [a, ...b] = @@`
      if p instanceof Splat then splatted = true
      # `(a = x) ->` to `(a ? x) ->`
      else if p.op is \= and not p.logic
        params[i] = Op \? p.left, p.right
    splatted &&= Assign Arr(paramName o, p for p of params), Literal \arguments
    for p of params
      arg = p
      if dfv = arg.hasDefault()    then arg.=first
      else if arg instanceof Splat then arg.=it
      if arg.isEmpty()
        splatted or arg = Var scope.temporary \arg
      else if arg not instanceof Var
        val = ref = paramName o, p
        val = Op p.op, ref, p.second if dfv
        asns.push Assign arg, val
        arg = ref
      else if dfv
        asns.push Assign arg, p.second, \=, p.op
      splatted or args.push arg
    {lines}  = body
    wasEmpty = not lines.length
    if splatted then asns.unshift splatted else
      args.0 = Var \it if not args.length and not @wrapper and
                          body.contains(-> it.value is \it)
      dic = {}
      for a, i of args
        if dic[0 + a.=compile o]
          args[i]carp "duplicate formal argument \"#{a}\""
        scope.add args[i] = dic[0 + a] = a, \arg
    lines.unshift ...asns if asns.length
    body.makeReturn() unless wasEmpty or @ctor
    if @statement
      name                    or @carp 'nameless function'
      pscope is o.block.scope or @carp 'misplaced function declaration'
      scope .add name, \function
      pscope.add name, \function unless @returns
      code += ' ' + name
    code += "(#{ args.join ', ' }){"
    code += "\n#{ body.compileWithDeclarations o }\n#{tab}" if lines.length
    code += \}
    if @ctor and \_ is not name.charAt 0
      code += " #{name}.displayName = '#{name}';"
    code += "\n#{tab}return #{name};" if @returns
    return tab + code if @statement
    if @front then "(#{code})" else code

  function paramName (o, node) ->
    return that if node.param
    prm = node
    if splat = prm instanceof Splat then prm.=it
    else    if prm.hasDefault()     then prm.=first
    if prm.varName()
      prm = Var that
    else if prm not instanceof Var and not prm.isEmpty()
      prm = Var o.scope.temporary \arg
    node.param = if splat then Splat prm else prm

#### Class
class exports.Class extends Node
  (@title, @sup, body) -> @fun = Fun [] body

  children: <[ title sup fun ]>

  isCallable: YES

  compileNode: (o) ->
    {fun, title} = this; {lines} = fun.body
    decl  = title.varName() or title.value if title
    name  = decl or @name
    name  = \_Class unless name and IDENTIFIER.test name
    lname = Var fun.bound = name
    fun.body.traverseChildren -> it.clas = name if it instanceof Fun; void
    for node, i of lines
      if node instanceof Obj
        lines[i] = Import Var(\_proto), node
        proto = lname
      else if node instanceof Fun and not node.statement
        node.carp 'more than one constructor in a class' if ctor
        proto = lname if (ctor = node)bound
    ctor or lines.unshift ctor = Fun()
    lines.push lname
    ctor import {name, +ctor, +statement, -clas}
    if @sup
      args  = [@sup]
      proto = Util.Extends lname, fun.params.* = Var \_super
    clas = Parens Call.make(fun<<<{proto} args), true
    clas = Assign lname, clas if decl and title.isComplex()
    clas = Assign title, clas if title
    clas.compile o

#### Super
# Reference to the parent method or constructor.
class exports.Super extends Node
  isAssignable : YES
  isCallable   : YES

  compile: (o) ->
    {fun} = o.scope.shared or o.scope
    fun or @carp 'stray "super"'
    {name, clas} = fun
    if name
      if clas
        return clas + \.superclass.prototype +
               if IDENTIFIER.test name then \. + name else \[ + name + \]
      else if IDENTIFIER.test name
        return name + \.superclass
    return \_super if o.scope.check \_super
    @carp '"super" in a nameless function'

#### Parens
# An extra set of parentheses,
# specifying evaluation order and/or forcing expression.
class exports.Parens extends Node
  (@it, @keep) ~>

  children: [\it]

  isComplex  : -> @it.isComplex()
  isCallable : -> @it.isCallable()

  compileNode: (o) ->
    {it} = this
    unless @keep or @newed
      if it instanceof [Atom, Chain, Fun, Parens] or
         it instanceof Op and o.level < LEVEL_OP + (PREC[it.op] or PREC.unary)
        return (it <<< {@front})compile o, Math.max o.level, LEVEL_PAREN
    o.level = LEVEL_PAREN
    if it.isStatement o then it.compileClosure o else "(#{ it.compile o })"

#### Splat
# A splat, either as an argument to a call
# or as part of a destructuring assignment.
class exports.Splat extends Parens
  (@it) ~>

  isAssignable: YES

  assigns: -> @it.assigns it

  compile: -> @it.compile @@0, @@1

  # Compiles a list of nodes mixed with splats to a proper array.
  @compileArray = (o, list, apply) ->
    break if node instanceof Splat for node, index of list
    return '' if index >= list.length
    if list.length is 1
      code = list.0.compile o, LEVEL_LIST
      return if apply then code else utility(\slice) + ".call(#{code})"
    args = []; atoms = []
    for node of list.splice index, 9e9
      code = node.compile o, LEVEL_LIST
      if node instanceof Splat
        atoms.length &&= !args.push "[#{ atoms.join ', ' }]"
        args.push utility(\slice) + ".call(#{code})"
      else atoms.push code
    args.push "[#{ atoms.join ', ' }]" if atoms.length
    base = if index
    then "[#{ (node.compile o, LEVEL_LIST for node of list)join ', ' }]"
    else args.shift()
    "#{base}.concat(#{ args.join ', ' })"

#### Statement
# `continue` `break`
class exports.Statement extends Node
  (@verb) ->

  show: -> @verb

  isStatement : YES
  makeReturn  : THIS

  jumps: ->
    not (it and (it.loop or it.block and @verb is not \continue)) and this

  compileNode: -> it.indent + @verb + \;

#### Throw
class exports.Throw extends Statement
  (@it) ->

  children: [\it]

  jumps: NO

  compileNode: (o) -> o.indent + "throw #{ @it.compile o, LEVEL_PAREN };"

#### Return
class exports.Return extends Throw
  ~> @<<<{it} if it and it.value is not \void

  jumps: THIS

  compileNode: (o) ->
    it = if @it then ' ' + @it.compile o, LEVEL_PAREN else ''
    o.indent + "return#{it};"

#### While
# The traditional `while` loop.
# Returns an array of values collected from the last expression when requested.
class exports.While extends Node
  (@test, name) -> @negated = name is \until

  children: <[ test body ]>

  aSource: \test, aTarget: \body

  @::{show} = Negatable

  isStatement: YES

  jumps: ->
    {lines} = @body
    return unless lines.length
    context = {+loop}
    return node if node.jumps context for node of lines

  addBody: (@body) ->
    [last, i] = lastNonComment body.lines
    body.lines.splice i, 1 if last.verb is \continue
    this

  makeReturn: ->
    if it
      @body.makeReturn it
    else unless @jumps()
      @returns = true
    this

  compileNode: (o) ->
    code = unless @test then \true else
      @anaphorize()
      (if @negated then @test.invert() else @test)compile o, LEVEL_PAREN
    code = @tab + if code is \true then 'for (;;' else 'while (' + code
    o.indent += TAB
    code + ') {' + @compileBody o

  compileBody: (o) ->
    {lines} = @body; end = \}
    if @returns
      [last, i] = lastNonComment lines
      if last and last not instanceof Throw
        o.scope.assign res = \_results, '[]'
        lines[i] = last.makeReturn res
      end = "}\n#{@tab}return #{ res or '[]' };"
    return end unless lines.length
    "\n#{ @body.compile o, LEVEL_TOP }\n" + @tab + end

#### For
# Coco's replacements for the `for` loop are array, object or range iterators.
class exports.For extends While
  -> this import all it

  children: <[ name source from to step body ]>

  aSource: null

  show: -> @index

  compileNode: (o) ->
    temps = @temps = []
    if idx = @index
    then o.scope.declare idx
    else temps.push idx = o.scope.temporary \i
    unless @object
      [step, pvar] = (@step || Literal 1)compileLoopReference o, \step
      temps.push pvar unless step is pvar
    if @from
      eq = if @op is \til then '' else \=
      [tail, tvar] = @to.compileLoopReference o, \to
      vars = idx + ' = ' + @from.compile o
      unless tail is tvar
        vars += ', ' + tail
        temps.push tvar
      cond = if +pvar
      then "#{idx} #{ if pvar < 0 then \> else \< }#{eq} #{tvar}"
      else "#{pvar} < 0 ? #{idx} >#{eq} #{tvar} : #{idx} <#{eq} #{tvar}"
    else
      if @name or @object and @own
        [srcPart, svar] = @source.compileLoopReference o, \ref
        srcPart is svar or temps.push svar
      else
        srcPart = svar = @source.compile o, LEVEL_PAREN
      unless @object
        srcPart = "(#{srcPart})" unless srcPart is svar
        if 0 > pvar and (pvar | 0) is +pvar  # negative int
          vars = "#{idx} = #{srcPart}.length - 1"
          cond = "#{idx} >= 0"
        else
          temps.push lvar = o.scope.temporary \len
          vars = "#{idx} = 0, #{lvar} = #{srcPart}.length"
          cond = "#{idx} < #{lvar}"
    if @object
      forPart = idx + ' in ' + srcPart
      if @own
        o.scope.assign \_own '{}.hasOwnProperty'
        ownPart = "if (_own.call(#{svar}, #{idx})) "
    else
      step is pvar or vars += ', ' + step
      forPart = vars + "; #{cond}; " + switch +pvar
      case  1 then \++ + idx
      case -1 then \-- + idx
      default idx + if pvar < 0 then ' -= ' + pvar.slice 1 else ' += ' + pvar
    @pluckDirectCalls o
    head = @tab + "for (#{forPart}) #{ ownPart or '' }{"
    o.indent += TAB
    if @name
      head += \\n + o.indent
      item  = svar + "[#{idx}]"
      if @nref
        head += that + ' = ' + item + ', '
        item  = that
      head += Assign(@name, Literal item)compile(o, LEVEL_TOP) + \;
    body  = @compileBody o
    head += \\n + @tab if @name and \} is body.charAt 0
    head + body

  pluckDirectCalls: (o) ->
    @body.eachChild dig = ~>
      unless (call = it.getCall()) and it.tails.length is 1 and
             ((fn = it.head.unwrap()) instanceof Fun or
              fn instanceof Parens and fn.=it instanceof Fun) and
             fn.params.length is call.args.length - !!call.method
        return if it instanceof [Fun, For] then null else it.eachChild dig
      if @index
        fn.params.push call.args.* = Var @index
      if name = @name
        call.args.push if name.isComplex()
        then Var @nref ||= @temps.* = o.scope.temporary \ref
        else name
        fn.params.push name
      it.head = Var ref = o.scope.temporary \fn
      o.scope.assign ref, fn.compile o <<< indent: '', LEVEL_LIST
      o.indent = @tab
      void

#### Try
# Classic `try`-`catch`-`finally` block with optional `catch`.
class exports.Try extends Node
  (@attempt, @thrown, @recovery, @ensure) ->

  children: <[ attempt recovery ensure ]>

  show: -> @thrown

  isStatement: YES

  isCallable: -> @attempt.isCallable() or @recovery?.isCallable()

  jumps: -> @attempt.jumps it or @recovery?.jumps it

  makeReturn: ->
    @attempt .=makeReturn it
    @recovery.=makeReturn it if @recovery
    this

  compileNode: (o) ->
    o.indent += TAB
    code = @tab + 'try ' + @compileBlock o, \attempt
    if @recovery or not @ensure
      code += " catch (#{ @thrown or \_e }) " + @compileBlock o, \recovery
    if @ensure
      code += " finally " + @compileBlock o, \ensure
    code

#### Switch
# Compiles to the regular JS `switch`-`case`-`default`,
# but with forced `break` after each cases.
class exports.Switch extends Node
  (@switch, @cases, @default) ->

  children: <[ switch cases default ]>

  aSource: \switch, aTarget: \cases

  isStatement: YES

  isCallable: ->
    return true if c.isCallable() for c of @cases
    @default?.isCallable()

  jumps: (x or {+block}) ->
    return that if c.body.jumps x for c of @cases
    @default?.jumps x

  makeReturn: ->
    c.makeReturn it for c of @cases
    @default?.makeReturn it
    this

  compileNode: (o) ->
    cond = !!@switch and (@anaphorize(); @switch.compile o, LEVEL_PAREN)
    {tab} = this
    code  = tab + "switch (#{cond}) {\n"
    stop  = @default or @cases.length - 1
    code += cs.compileCase o, tab, i is stop, !cond for cs, i of @cases
    if @default
      o.indent = tab + TAB
      code += tab + "default:\n#{that}\n" if @default.compile o, LEVEL_TOP
    code + tab + \}

#### Case
class exports.Case extends Node
  (@test, @body) ->

  children: <[ test body ]>

  isCallable: -> @body.isCallable()

  makeReturn: ->
    lastNonComment(@body.lines)0.value is \fallthrough or @body.makeReturn it
    this

  compileCase: (o, tab, nobr, bool) ->
    tests = if @test instanceof Arr then @test.items else [@test]
    tests.length or tests.push Literal \void
    if bool
      [t] = tests; i = 0; t = Op \|| t, that while tests[++i]
      (@<<<{t, aSource: \t, aTarget: \body})anaphorize()
      tests = [@t.invert()]
    code = ''
    code += tab + "case #{ t.compile o, LEVEL_PAREN }:\n" for t of tests
    [last, i] = lastNonComment exps = @body.lines
    exps[i] = JS '/* fallthrough */' if ft = last?.value is \fallthrough
    o.indent = tab += TAB
    code += that + \\n        if @body.compile o, LEVEL_TOP
    code += tab  + 'break;\n' unless nobr or ft or last instanceof Statement
    code

#### If
# The `if`/`else` structure that acts as both statement and expression.
class exports.If extends Node
  (@if, @then, {@soak, name} or {}) ~> @negated = name is \unless

  children: <[ if then else ]>

  aSource: \if, aTarget: \then

  @::{show} = Negatable

  # Rewrites a chain of **If**s to add a default case as the final `else`.
  addElse: ->
    if @chain
    then @else.addElse it
    else @chain = (@else = it) instanceof If
    this

  # An **If** only compiles into a statement if either of its bodies needs
  # to be a statement. Otherwise a conditional operator is safe.
  isStatement: (o) ->
    o and not o.level or @then.isStatement o or @else?.isStatement o

  isCallable: -> @then.isCallable() or @else?.isCallable()

  jumps: -> @then.jumps it or @else?.jumps it

  makeReturn: ->
    @then.=makeReturn it
    @else.=makeReturn it if @else
    this

  compileNode: (o) ->
    @anaphorize()
    if @isStatement o then @compileStatement o else @compileExpression o

  compileStatement: (o) ->
    code = (if delete o.elsed then '' else @tab) + 'if (' +
           (if @negated then @if.invert() else @if)compile o, LEVEL_PAREN
    o.indent += TAB
    @then = Block @then
    code += ') ' + @compileBlock o, \then
    return code unless @else
    code + ' else ' + if @chain
    then @else.compile o <<< {indent: @tab, +elsed}, LEVEL_TOP
    else @compileBlock o, \else

  compileExpression: (o) ->
    cond = if @negated then @if.invert() else @if
    code = cond.compile o, LEVEL_COND
    pad  = if @else?.isComplex() and @then.isComplex()
    then \\n + o.indent += TAB else ' '
    code += pad + '? ' +  @then .compile(o, LEVEL_LIST) +
            pad + ': ' + (@else?.compile(o, LEVEL_LIST) or 'void 8')
    if o.level < LEVEL_COND then code else "(#{code})"

  unfoldSoak: -> @soak and this

  # Unfolds a node's child if soak, then tuck the node under the created **If**.
  @unfoldSoak = (o, parent, name) ->
    if parent[name]unfoldSoak o
      parent[name] = that.then
      that import then: Chain parent

#### JS
# Embedded JavaScript snippets.
class exports.JS extends Node
  (@code, @literal, @comment) ~>

  terminator: ''
  isCallable: -> not @comment

  compile: -> if @literal then entab @code, it.indent else @code

#### Util
# A wrapper node for utility functions.
class exports.Util extends Node
  (@verb) ~>

  @::{show} = Statement::

  isCallable: YES

  compile: -> utility @verb

  ##### Util.Extends
  # An operator that sets up class-ical inheritance between two constructors,
  # returning the left one.
  @Extends = -> Call.make Util(\extends), @@[0 1]

#### Parser Utils
# Helpers for modifying nodes in [parser](../lib/parser.js).

exports.L = (yylineno, node) -> node import line: yylineno + 1

##### Scope
# Regulates lexical scoping within Coco. As you
# generate code, you create a tree of scopes in the same shape as the nested
# functions. Each scope knows about the function parameters and the variables
# declared within it, and has references to its parent/shared enclosing scopes.
function Scope (@parent, @shared) ->
  @variables = []
  @positions = {}
  void
Scope::<<<
  # Adds a new variable or overrides an existing one.
  add: (name, type) ->
    if @variables[@positions[name]]
    then that import {type}
    else @positions[name] = -1 + @variables.push {name, type}
    name

  # Declares a variable unless declared already.
  declare: (name) ->
    if @shared
      return if @check name
      scope = that
    else
      scope = this
    scope.add name, \var unless scope.type(name) of <[ var arg ]>
    void

  # Ensures that an assignment is made at the top of this scope.
  assign: (name, value) -> @add name, {value}

  # If we need to store an intermediate result, find an available name for a
  # compiler-generated variable. `_var`, `_var2`, and so on...
  temporary: (name) ->
    i = 0
    for ever
      temp = \_ + if name.length > 1
      then name + (if i++ then i else '')
      else (i++ + parseInt name, 36)toString 36
      break if @type(temp) of [\reuse void]
    @add temp, \var
    temp

  # Allows a variable to be reused.
  free: -> @add it, \reuse

  # Checks to see if a variable has already been declared.
  # Walks up the scope if `above` flag is specified.
  check: (name, above) ->
    return found if (found = @positions[name] in @variables) or not above
    !!@parent?.check name, above

  # Gets the type of a variable from name.
  type: -> @variables[@positions[it]]?.type

  # Returns the list of variables declared in this scope.
  vars: (o) ->
    usr = []; tmp = []; asn = []
    for {name, type} of @variables
      if type of <[ var reuse ]>
        (if \_ is name.charAt 0 then tmp else usr)push name
      else if type.value
        asn.push entab name + ' = ' + type.value, o.indent
    return asn.join ', ' if o.globals
    'var ' + that if usr.concat(tmp, asn)join ', '

##### Constants

function YES  -> true
function NO   -> false
function THIS -> this

UTILITIES =
  # Creates an object's prototypal child, ensuring `__proto__`.
  clone: '''
    function(it){
      function fn(){ if (this.__proto__ !== it) this.__proto__ = it }
      return fn.prototype = it, new fn;
    }
  '''
  # Sets up `.prototype` between a pair of constructors
  # as well as `.constructor` and `.superclass` references.
  extends: '''
    function(sub, sup){
      function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
      return (sub.prototype = new ctor).constructor = sub;
    }
  '''

  # Wraps a function to fixate its `this` value.
  bind: '''
    function(me, fn){ return function(){ return fn.apply(me, arguments) } }
  '''

  # Copies properties from right to left.
  import: '''
    function(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
  '''
  importAll: '''
    function(obj, src){ for (var key in src) obj[key] = src[key]; return obj }
  '''

  # Shortcuts to speed up the lookup time for native functions.
  slice    : '[].slice'
  toString : '{}.toString'
  indexOf  : '''
    [].indexOf || function(x){
      for (var i = this.length; i-- && this[i] !== x;); return i;
    }
  '''

# Each level indicates a node's position in the AST.
LEVEL_TOP    = 0  # ...;
LEVEL_PAREN  = 1  # (...)
LEVEL_LIST   = 2  # [...]
LEVEL_COND   = 3  # ... ? x : y
LEVEL_OP     = 4  # !...
LEVEL_CALL   = 5  # ...()

# Operator precedances.
PREC = \? : .1, unary : .9
PREC\&& = PREC\||                                                  = .2
PREC\&  = PREC\^  = PREC\|                                         = .3
PREC\== = PREC\!= = PREC\=== = PREC\!==                            = .4
PREC\<  = PREC\>  = PREC\<=  = PREC\>= = PREC\in = PREC\instanceof = .5
PREC\<< = PREC\>> = PREC\>>>                                       = .6
PREC\+  = PREC\-                                                   = .7
PREC\*  = PREC\/  = PREC\%                                         = .8

# Tabs are two spaces for pretty printing.
TAB = '  '

IDENTIFIER = /^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*$/

##### Helpers

# Declares a utility function at the top level.
function utility -> Scope.root.assign \__ + it, UTILITIES[it]

function lastNonComment (nodes) ->
  break unless node.comment for node, i of nodes by -1
  [i >= 0 and node, i]

function entab (code, tab) -> code.replace /\n/g \\n + tab
