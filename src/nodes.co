# Contains all of the node classes for the syntax tree. Most
# nodes are created as the result of actions in the [grammar](#grammar),
# but some are created by other nodes as a method of code generation. To convert
# the syntax tree into a string of JavaScript code, call `compileRoot`.

#### Node
# The abstract base class for all nodes in the syntax tree.
# Each subclass implements the `compileNode` method, which performs the
# code generation for that node. To compile a node to JavaScript,
# call `compile` on it, which wraps `compileNode` in some generic extra smarts.
# An options hash is passed and cloned throughout, containing information about
# the environment from higher in the tree (such as if a returned value is
# being requested by the surrounding function), information about the current
# scope, and indentation level.
class Node
  compile: (options, level) ->
    o = {}; continue for key, o[key] in options
    o import {level} if level?
    node = @unfoldSoak(o) or this
    # If a statement appears within an expression, wrap it in a closure.
    return node.compileClosure o if o.level and node.isStatement o
    code = (node import tab: o.indent).compileNode o
    o.scope.free tmp for tmp of node.temps if node.temps
    code

  compileClosure: (o) ->
    # Statements that _jump_ out of current context (like `return`) can't be
    # an expression via closure-wrapping, as their meaning will change.
    if @jumps() then throw SyntaxError \
      @compile(o import indent: ''; LEVEL_TOP) + ' // cannot be an expression'
    # The wrapper shares a scope with its parent closure
    # to preserve the expected lexical scope.
    (fun = Fun [], Lines this).wrapper = true
    args = []
    if @contains(-> it.value is \this)
      args.push Literal \this
      val = Value fun, [Index Key \call]
    mentionsArgs = false
    @traverseChildren ->
      mentionsArgs := it.value = \_args if it.value is \arguments
      void
    if mentionsArgs
      args.push Literal \arguments
      fun.params.push Literal \_args
    Call(val or fun, args).compileNode o

  # If the code generation wishes to use the result of a complex expression
  # in multiple places, ensure that the expression is only ever evaluated once,
  # by assigning it to a temporary variable. Pass a level to precompile.
  cache: (o, once, level) ->
    unless @isComplex()
      return [ref = if level? then @compile o, level else this, ref]
    sub = Assign ref = Literal(o.scope.temporary \ref), this
    return [sub.compile o, level; ref.value] if level?
    ref.temp = once
    [sub, ref]

  # Compiles to a source/variable pair suitable for looping.
  compileLoopReference: (o, name) ->
    src = tmp = @compile o, LEVEL_LIST
    unless -1/0 < +src < 1/0 or IDENTIFIER.test(src) and o.scope.check(src)
      src = "#{ tmp = o.scope.temporary name } = #{src}"
    [src, tmp]

  # Passes each child to a function, returning its return value if exists.
  eachChild: (fn) ->
    for name of @children then if child = @[name]
      if \length in child
      then return v if (v = fn node )? for node of child
      else return v if (v = fn child)?
    void

  # Performs `eachChild` on every descendant.
  # Overridden by `Fun` not to cross scope by default.
  traverseChildren: (fn, xscope) ->
    @eachChild -> if (v = fn it)? then v else it.traverseChildren fn, xscope

  # Do I, or any of my children, contain a node of a certain kind?
  # Recursively traverses down the nodes' descendants and passess them to
  # `pred`, returning `true` when it finds a match.
  # Does not cross scope boundaries.
  contains: (pred) -> !!@traverseChildren -> pred(it) or null

  # Performs anaphoric conversion if a `that` is found within `@[@aTarget]`.
  anaphorize: ->
    @children = [@aTarget]
    @[@aSource] = Assign Literal(\that), @[@aSource] if @eachChild hasThat
    delete @children; void
  function hasThat ->
    it.value is \that or if it.aSource
    then hasThat that if it[that]
    else it.eachChild hasThat

  # Default implementations of the common node properties and methods. Nodes
  # will override these with custom logic, if needed.
  children: []

  terminator: \;

  isComplex    : YES
  isStatement  : NO
  isAssignable : NO
  # Do I contain a statement that jumps out of me?
  jumps: NO
  # Do I assign a certain variable?
  assigns: NO

  unfoldSoak   : NO
  unfoldAssign : NO
  unwrap       : THIS
  asKey        : THIS

  invert: -> Op \!, this

  # Constructs a node that returns the current node's result.
  makeReturn: (name) ->
    if name then Call Literal(name + \.push), [this] else Return this

  # Extra info for `toString`.
  show: String

  # String representation of the node for inspecting the parse tree.
  # This is what `coco --nodes` prints out.
  toString: (idt = '') ->
    tree = \\n + idt + @constructor.name
    tree += ' ' + that if @show()
    @eachChild -> tree += it.toString idt + TAB; void
    tree

Negatable =
  show   : -> @negated and \!
  invert : -> @negated ^= 1; this

#### Lines
# A list of expressions that forms the body of an
# indented block of code--the implementation of a function, a clause in an
# `if`, `switch`, `try`, and so on.
class exports.Lines extends Node
  (node) =>
    return node if node instanceof Lines
    @lines = if node then [node] else []

  children: [\lines]

  add    : -> @lines.push it; this
  unwrap : -> if @lines.length is 1 then @lines.0 else this

  isComplex: -> @lines.length > 1 or !!@lines.0?.isComplex()

  isStatement: (o) ->
    return true if o and not o.level
    return true if node.isStatement o for node of @lines
    false

  jumps: ->
    return true if node.jumps it for node of @lines
    false

  # **Lines** does not return its entire body, rather it
  # ensures that the final line is returned.
  makeReturn: ->
    [node, i] = lastNonComment @lines
    if node
      @lines[i] = node.=makeReturn it
      @lines.splice i, 1 if node instanceof Return and not node.it
    this

  compileNode: (o) ->
    o.lines = this
    top     = not o.level
    codes   = []
    for node of @lines
      node = node.unfoldSoak(o) or node
      if top
        code = (node import {+front}).compile o
        code = o.indent + code + node.terminator unless node.isStatement o
      else
        code = node.compile o, LEVEL_LIST
      codes.push code
    return codes.join \\n if top
    code = codes.join(', ') or 'void 8'
    if codes.length > 1 and o.level >= LEVEL_LIST then "(#{code})" else code

  # **Lines** is the only node that can serve as the root.
  compileRoot: (o = {}) ->
    o.indent = @tab = if bare = delete o.bare then '' else TAB
    o.scope  = @scope = Scope.root = new Scope
    o.level  = LEVEL_TOP
    code = @compileWithDeclarations(o).replace /[^\n\S]+$/gm, ''
    # If we happen to be the top-level **Lines**, wrap everything in
    # a safety closure, unless requested not to.
    if bare then code else "(function(){\n#{code}\n}).call(this);\n"

  # Compile the expressions body for the contents of a function, with
  # declarations of all inner variables pushed up to the top.
  compileWithDeclarations: (o) ->
    o.level = LEVEL_TOP
    code = post = ''
    break unless node instanceof [Comment, Literal] for node, i of @lines
    if i
      rest   = @lines.splice i, 9e9
      code   = @compileNode o
      @lines = rest
    post = if @lines.length then @compileNode o else ''
    code &&+= \\n if post
    if @scope?.vars o.globals
      code += o.indent + that + \;\n
    code + post

#### Literal
# Literals are static values that can be passed through directly into
# JavaScript without translation, such as identifiers, numbers, `this`,
# and pretty much everything that doesn't fit in other nodes.
class exports.Literal extends Node
  (@value, reserved) => @isAssignable = NO if reserved

  show: -> \" + @value + \"

  isComplex: NO

  isAssignable : -> IDENTIFIER.test @value
  assigns      : -> it is @value

  asKey: -> if IDENTIFIER.test @value then Key @value else this

  compile: (o, level) ->
    switch val = @value
    case \this then return o.scope.method?.bound or val
    case \void then val += ' 8'; fallthrough
    case \null
      if (level ? o.level) is LEVEL_ACCESS
        throw SyntaxError 'invalid use of ' + @value
      return val
    if      val.js then @terminator = ''
    else if @temp  then o.scope.free val
    val

#### Key
# The name of a property, in the form of `{key: _}` or `_.key`.
class exports.Key extends Node
  (@name) =>

  show: -> @name

  isComplex: NO

  compile: -> if @name.reserved then "'#{@name}'" else @name

#### Index
# The dots and brackets to access an object's property.
class exports.Index extends Node
  (@key, @symbol) =>
    switch key.length
    case 0 then @key = Key \__proto__
    case 1 then @key = key.0
    switch symbol
    case <[ ?. ?[ ]> then @soak   = true
    case <[ &. &[ ]> then @bind   = true
    case <[ .= [= ]> then @assign = true

  children: [\key]

  show: -> @symbol

  compile: (o) ->
    code = @key.compile o, LEVEL_PAREN
    if @key instanceof Key and code.charAt(0) isnt \'
    then ".#{code}" else "[#{code}]"

  isComplex: -> @key.isComplex()

#### Value
# Acts as a container for property access chains, by holding
# __Index__ instances within `@tails`.
class exports.Value extends Node
  (head, tails, at) =>
    return head if not tails and head instanceof Value
    @<<<{head, tails: tails || [], at}

  children: <[ head tails ]>

  add: -> @tails.push it; this

  jumps        : -> not @tails.length and @head.jumps it
  assigns      : -> not @tails.length and @head.assigns it
  isStatement  : -> not @tails.length and @head.isStatement it
  isComplex    : -> !!@tails.length or @head.isComplex()
  isAssignable : -> !!@tails.length or @head.isAssignable()

  makeReturn: -> if @tails.length then super ... else @head.makeReturn it

  # The value can be unwrapped as its inner node, if there are no accessors.
  unwrap: -> if @tails.length then this else @head

  # A reference has base part (`this` value) and name part.
  # We cache them separately for compiling complex expressions, so that e.g.
  #
  #     a()[b()] ||= c
  #
  # compiles to
  #
  #     (_base = a())[_name = b()] || (_base[_name] = c);
  #
  cacheReference: (o) ->
    name = @tails[*-1]
    if @tails.length < 2 and not @head.isComplex() and not name?.isComplex()
      return [this, this]  # `a` `a.b`
    base = Value @head, @tails.slice 0, -1
    if base.isComplex()  # `a().b`
      ref  = o.scope.temporary \base
      base = Value Parens Assign Literal(ref), base
      bref = Literal(ref) <<< {+temp}
    return [base, bref] unless name  # `a()`
    if name.isComplex()  # `a[b()]`
      ref  = o.scope.temporary \name
      name = Index Assign Literal(ref), name.key
      nref = Index Literal(ref) <<< {+temp}
    [base.add name; Value bref or base.head, [nref or name]]

  SIMPLENUM = /^\d+$/

  compileNode: (o) ->
    @head import {@front}
    return @head.compile o if not @tails.length
    return that.compile  o if @unfoldAssign(o) or @unfoldBind(o) or
                              @poleStar(o) or @multiPick(o)
    base = @head.compile o, LEVEL_ACCESS
    rest = ''; rest += t.compile o for t of @tails
    base += ' ' if rest.charAt(0) is \. and SIMPLENUM.test base
    base + rest

  # Unfold a soak into an __If__: `a?.b` -> `a.b if a?`
  unfoldSoak: (o) ->
    if @head.unfoldSoak o
      that.then.tails.push ...@tails
      return that
    for tail, i of @tails then if tail.soak
      tail.soak = false
      fst = Value @head, @tails.slice 0, i
      snd = Value @head, @tails.slice i
      if fst.isComplex()
        ref = o.scope.temporary \ref
        fst = Parens Assign Literal(ref), fst
        snd.head = Literal(ref) <<< {+temp}
      return If Existence(fst), snd, {+soak}
    void

  unfoldAssign: (o) ->
    if @head.unfoldAssign o
      that.right.tails.push ...@tails
      return that
    for tail, i of @tails then if tail.assign
      tail.assign = false
      [lhs, rhs] = Value(@head, @tails.slice 0, i).cacheReference o
      return Assign(lhs; Value rhs, @tails.slice i) import {+access}
    void

  unfoldBind: (o) ->
    for p, i of ps = @tails then if p.bind
      p.bind = false
      args   = Value(@head, ps.slice 0, i).cache o, true
      args.1 = Value args.1, [p]
      return Value Call(Util \bind; args), ps.slice i+1
    void

  poleStar: (o) ->
    function seek ->
      if it.value is \*               then stars.push it
      else unless it instanceof Index then it.eachChild seek
      void
    stars = []
    for index, i of @tails then unless index.key instanceof Key
      index.eachChild seek
      continue unless stars.length
      [sub, ref] = Value(@head, @tails.slice 0, i).cache o
      @temps = [ref.value] if sub isnt ref
      ref += ' ' if SIMPLENUM.test ref.=compile o
      star.value = ref + \.length for star of stars
      return Value sub, @tails.slice i
    void

  multiPick: (o) ->
    for {key}, i of @tails then if key.length
      [sub, ref] = Value(@head, @tails.slice 0, i).cache o
      @temps = [ref.value] if sub isnt ref
      arr = (Value if j then ref else sub, [Index node] for node, j of key)
      return Value Arr(arr), @tails.slice i+1
    void

#### Call
# `x(y)`
class exports.Call extends Node
  (@callee, @args, sym) =>
    @args ||= (@splat = true; [Literal \this; Literal \arguments])
    @soak   = true if sym is \?(

  children: <[ callee args ]>

  show: -> (@new or '') + if @soak then \? else ''

  # Lists up a chain of calls from bottom. Used for unfolding `?.` and `.=`.
  digCalls: ->
    list = [call = this]
    list.push call while call.=callee.head instanceof Call
    list.reverse()

  unfoldSoak: (o) ->
    if @soak
      return that if If.unfoldSoak o, this, \callee
      [left, rite] = @callee.cacheReference o
      rite = Call rite, @args
      rite import {@new}
      left = Literal "typeof #{ left.compile o } == 'function'"
      return If left, Value(rite), {+soak}
    for call of @digCalls()
      call.callee.head = ifn if ifn
      ifn = If.unfoldSoak o, call, \callee
    ifn

  unfoldAssign: (o) ->
    for call of @digCalls()
      call.callee.head = asn if asn
      if asn = call.callee.unfoldAssign o
        call.callee = asn.right; asn.right = Value call
    asn

  compileNode: (o) ->
    return that.compile o if @unfoldAssign o
    unless fun = (@callee.head or @callee) instanceof Fun
      @callee import {@front}
    if @splat
      return @compileSplat o, @args.1.value if @new
      return @callee.compile(o, LEVEL_ACCESS) +
             ".apply(#{ @args.0.compile o }, #{@args.1.value})"
    return @compileSplat o, that if Splat.compileArray o, @args, true
    code = (@new or '') + @callee.compile(o, LEVEL_ACCESS) +
           "(#{ (arg.compile o, LEVEL_LIST for arg of @args).join ', ' })"
    if fun then "(#{code})" else code

  # If you call a function with a splat, it's converted into a JavaScript
  # `.apply()` call to allow an array of arguments to be passed.
  compileSplat: (o, args) ->
    if @new
      # If it's a constructor, we have to inject an inner constructor.
      idt = @tab + TAB
      return """
        (function(func, args, ctor){
        #{idt}ctor.prototype = func.prototype;
        #{idt}var child = new ctor, result = func.apply(child, args);
        #{idt}return result === Object(result) ? result : child;
        #{@tab}}(#{ @callee.compile o, LEVEL_LIST }, #{args}, function(){}))
      """
    base = @callee
    if (name = base.tails.pop()) and base.isComplex()
      base.front = false
      ref = o.scope.temporary \ref
      fun = "(#{ref} = #{ base.compile o, LEVEL_LIST })#{ name.compile o }"
      o.scope.free ref
    else
      if name
        ref = base.compile o
        base.add name
      fun = base.compile o
    "#{fun}.apply(#{ ref or null }, #{args})"

#### Obj
# `{x: y}`
class exports.Obj extends Node
  (@items = []) =>

  children: [\items]

  assigns: ->
    return true if node.assigns it for node of @items
    false

  compileNode: (o) ->
    {items} = this
    return (if @front then '({})' else '{}') unless items.length
    for node, i of items
      if node instanceof Splat or (node.left or node) instanceof Parens
        rest = items.splice i, 9e9
        break
    [last] = lastNonComment items
    idt    = o.indent += TAB
    dic    = {}
    code   = ''
    for node of items
      if node instanceof Comment
        code += idt + node.compile(o, LEVEL_TOP) + \\n
        continue
      code += idt + if node.at
        key = node.tails.0.key.compile o
        key + ': ' + node.compile o, LEVEL_LIST
      else if node instanceof Assign
        key = node.left.compile o
        node.compile o
      else (key = node.compile o, LEVEL_LIST) + ': ' + key
      throw SyntaxError 'duplicated property name: ' + key if dic[key + 0]
      dic[key + 0] = 1
      code += \, unless node is last
      code += \\n
    code = "{#{ code and \\n + code + @tab }}"
    return @compileDynamic o, code, rest if rest
    if @front then "(#{code})" else code

  compileDynamic: (o, code, props) ->
    o.indent = @tab
    code = (oref = o.scope.temporary \obj) + ' = ' + code + ', ' +
           Import(Literal oref; Obj props).compile o, LEVEL_PAREN
    o.scope.free oref
    if o.level < LEVEL_LIST then code else "(#{code})"

#### Arr
# `[x, y]`
class exports.Arr extends Obj
  (@items = []) =>

  compileNode: (o) ->
    return '[]' unless @items.length
    return that if Splat.compileArray o, @items
    o.indent += TAB
    code = (obj.compile o, LEVEL_LIST for obj of @items).join ', '
    if 0 < code.indexOf \\n
    then "[\n#{o.indent}#{code}\n#{@tab}]"
    else "[#{code}]"

#### Op
# Simple Arithmetic and logical operations, with some special conversions.
class exports.Op extends Node
  (op, first, second, post) =>
    return new Of first, second if op is \of
    return Call first, []       if op is \do
    if op is \new
      if first instanceof Call
        first.digCalls().0.new = 'new '
        return first
      p.keep = true if (p = first.head or first) instanceof Parens
    @<<<{op, first, second, post}

  children: <[ first second ]>

  show: -> @op

  EQUALITY = /^[!=]==?$/
  COMPARER = /^(?:[!=]=|[<>])=?$/

  invert: ->
    if EQUALITY.test(op = @op) and not COMPARER.test(@first.op)
      @op = '!='.charAt(op.indexOf \=) + op.slice 1
      return this
    return Op \!, Parens this if @second
    return @first if op is \! and @first.op of <[ ! in instanceof < > <= >= ]>
    Op \!, this

  unfoldSoak: (o) ->
    @op of <[ ++ -- delete ]> and If.unfoldSoak o, this, \first

  compileNode: (o) ->
    return @compileUnary o if not @second
    return @compileChain o if COMPARER.test(@op) and COMPARER.test(@first.op)
    return @compileExistence o if @op is \?
    return @compileMultiIO   o if @op is \instanceof and @second instanceof Arr
    @first import {@front}
    code = @first .compile(o, LEVEL_OP) + " #{@op} " +
           @second.compile(o, LEVEL_OP)
    if o.level <= LEVEL_OP then code else "(#{code})"

  # Mimic Python's chained comparisons when multiple comparison operators are
  # used sequentially. For example:
  #
  #     $ coco -e 'console.log 50 < 65 === 9r72 > 10'
  #     true
  #
  # See <http://docs.python.org/reference/expressions.html#notin>.
  compileChain: (o) ->
    [sub, ref] = @first.second.cache o, true
    @first.second = sub
    code  = @first.compile o, LEVEL_OP
    code .= slice 1, -1 if code.charAt(0) is \(
    code += " && #{ ref.compile o } #{@op} #{ @second.compile o, LEVEL_OP }"
    if o.level < LEVEL_OP then code else "(#{code})"

  compileExistence: (o) ->
    if @first.isComplex()
      ref = tmp = o.scope.temporary \ref
      fst = Parens Assign Literal(ref), @first
    else
      fst = @first
      ref = fst.compile o
    code  = Existence(fst).compile o
    code += ' ? ' + ref + ' : ' + @second.compile o, LEVEL_LIST
    o.scope.free tmp if tmp
    code

  compileUnary: (o) ->
    {op} = this
    return @compileDelete o if op is \delete and o.level
    code = @first.compile o, LEVEL_OP
    code = if @post
    then code + op
    else if op of <[ new typeof delete ]> or
            op of <[ + - ]> and @first.op is op
    then op + ' ' + code
    else op + code
    if o.level <= LEVEL_OP then code else "(#{code})"

  compileMultiIO: (o) ->
    [sub, ref] = @first.cache o, false, LEVEL_OP
    tests = for item, i of @second.items
      (if i then ref else sub) + ' instanceof ' + item.compile o
    o.scope.free ref if sub isnt ref
    code = tests.join ' || '
    if o.level < LEVEL_OP then code else "(#{code})"

  compileDelete: (o) ->
    code = ref = o.scope.temporary \ref
    [get, del] = Value(@first).cacheReference o
    code += ' = ' + get.compile(o, LEVEL_LIST) + ', delete ' +
                    del.compile(o, LEVEL_LIST) + ', ' + ref
    o.scope.free ref
    if o.level < LEVEL_LIST then code else "(#{code})"

#### Assign
# Assignment to a local variable or the property of an object,
# including `:` within object literals.
class exports.Assign extends Node
  (@left, @right, @op = \=, @logic = @op.logic) => @op += ''

  children: <[ left right ]>

  show: -> (@logic or '') + @op

  assigns: -> @[if @op is \: then \right else \left].assigns it

  unfoldSoak: (o) -> If.unfoldSoak o, this, \left

  unfoldAssign: -> @access and this

  compileNode: (o) ->
    {left} = this
    if left.items
      return @compileDestructuring o unless @logic
      throw SyntaxError 'conditional assignment cannot be destructuring'
    return @compileConditional o if @logic
    name = left.compile o, LEVEL_LIST
    # Keep track of the name of the base object
    # we've been assigned to, for correct internal references.
    {right} = this
    if right instanceof [Fun, Class] and match = METHOD_DEF.exec name
      right.clas   = match.1 if match.1
      right.name ||= match.2 or match.3
    val = right.compile o, LEVEL_LIST
    if @op is \:
      throw SyntaxError 'invalid property name: ' + name if left.isComplex()
      return name + ': ' + val
    unless left.isAssignable()
      o import indent: '', level: LEVEL_LIST
      throw SyntaxError "\"#{ @left.compile o }\" cannot be assigned"
    if IDENTIFIER.test name
      if @op is \=
        o.scope.declare name
      else unless o.scope.check name, true
        throw SyntaxError "assignment to undeclared variable \"#{name}\""
    code = name + " #{ if @op is \:= then \= else @op } " + val
    if o.level < LEVEL_COND then code else "(#{code})"

  compileConditional: (o) ->
    [lef, ref] = Value(@left).cacheReference o
    Op(@logic; lef; Assign ref, @right, @op).compile o

  # Implementation of recursive destructuring,
  # when assigning to an array or object literal.
  # See <http://wiki.ecmascript.org/doku.php?id=harmony:destructuring>.
  compileDestructuring: (o) ->
    {items} = @left
    return @right.compile o, LEVEL_ACCESS unless len = items.length
    rite = @right.compile o, if len is 1 then LEVEL_ACCESS else LEVEL_LIST
    if (len > 1 or o.level) and
       (not IDENTIFIER.test(rite) or @left.assigns(rite))
      cache = "#{ rref = o.scope.temporary \ref } = #{rite}"
      rite  = rref
    list = if @left instanceof Arr
    then @destructArr o, items, rite
    else @destructObj o, items, rite
    o.scope.free rref  if rref
    list.unshift cache if cache
    list.push rite     if o.level or not list.length
    code = list.join ', '
    if list.length < 2 or o.level < LEVEL_LIST then code else "(#{code})"

  destructArr: (o, nodes, rite) ->
    for node, i of nodes
      continue if node.items and not node.items.length
      if node instanceof Splat
        if ivar then throw SyntaxError \
          "multiple splats in an assignment: " + node.compile o
        len = nodes.length
        val = utility(\slice) + \.call( + rite
        val = if i is len - 1
          val + if i then ", #{i})" else \)
        else
          @temps = [ivar = o.scope.temporary \i]
          start  = i + 1
          "#{len} <= #{rite}.length" +
          " ? #{val}, #{i}, #{ivar} = #{rite}.length - #{len - i - 1})" +
          " : (#{ivar} = #{i}, [])"
        val = Literal val
      else
        if (inc = ivar) and start < i then inc += " + #{ i - start }"
        val = Value lr ||= Literal(rite), [Index Literal inc or i]
      Assign(node, val, @op).compile o, LEVEL_TOP

  destructObj: (o, nodes, rite) ->
    for node of nodes
      node.=it if splat = node instanceof Splat
      if node instanceof Parens
        [node, key] = Value(node.it).cacheReference o
      else if node instanceof Assign
        key = node.left; node.=right
      else
        key = if node.at then node.tails.0.key else node
      val = Value lr ||= Literal(rite), [Index key.asKey()]
      val = Import Obj(), val  if splat
      node = Literal node.name if node instanceof Key
      Assign(node, val, @op).compile o, LEVEL_TOP

#### Import
# Operators that copy properties from right to left.
class exports.Import extends Node
  (@left, @right, all) => @util = if all then \importAll else \import

  children: <[ left right ]>

  show: -> @util.slice 6

  compileNode: (o) ->
    unless @util is \import and @right instanceof Obj
      return Call(Value Util @util; [@left, @right]).compile o
    {items} = @right
    return @left.compile o unless items.length
    top = not o.level
    if top and items.length < 2
    then  sub = lref  = @left
    else [sub , lref] = @left.cache o
    [delim, space] = if top then [\;, \\n + @tab] else [\,, ' ']
    delim += space
    @temps = []
    code   = ''
    for node of items
      code += if com then space else delim
      if com = node instanceof Comment
        code += node.compile o, LEVEL_LIST
        continue
      if node instanceof Splat
        code += Import(lref, node.it).compile o, LEVEL_TOP
        continue
      if dyna = node instanceof Parens
        [key, val] = node.it.cache o, true
      else if node instanceof Assign
        {left: key, right: val} = node
      else if (key = val = node).at
        [{key}] = val.tails
      key.=asKey() unless dyna
      asn = Assign Value(lref, [Index key]), val
      code += asn.compile o, LEVEL_PAREN
    if sub is lref
      code.=slice delim.length
    else
      code = sub.compile(o, LEVEL_PAREN) + code
      o.scope.free lref.value
    return code if top
    unless node instanceof Splat
      code += (if com then ' ' else ', ') + lref.compile o, LEVEL_LIST
    if o.level < LEVEL_LIST then code else "(#{code})"

#### Of
# Handles `of` operation that tests if the left operand is included within
# the right operand, arraywise.
class exports.Of extends Node
  (@item, @array) ->

  children: <[ item array ]>

  @::<<<< Negatable

  compileNode: (o) ->
    lvl = if arr = @array instanceof Arr then LEVEL_OP else LEVEL_LIST
    [sub, ref] = @item.cache o, false, lvl
    if arr
      [cmp, cnj] = if @negated then [' !== ', ' && '] else [' === ', ' || ']
      tests = for item, i of @array.items
        (if i then ref else sub) + cmp + item.compile o, lvl
      code = tests.join cnj
    else
      code = utility(\indexOf) + ".call(#{ @array.compile o, lvl }, #{ref}) " +
             if @negated then '< 0' else '>= 0'
      return code if sub is ref
      code = sub + ', ' + code
    o.scope.free ref if sub isnt ref
    if o.level < lvl then code else "(#{code})"

#### Existence
# Checks a value for existence--not `undefined` nor `null`.
class exports.Existence extends Node
  (@it) =>

  children: [\it]

  @::<<<< Negatable

  compileNode: (o) ->
    code = @it.compile o, LEVEL_OP
    if IDENTIFIER.test(code) and not o.scope.check code, true
      code = 'typeof ' + code + if @negated
      then " == 'undefined' || #{code} === null"
      else " != 'undefined' && #{code} !== null"
    else
      code += " #{ if @negated then \= else \! }= null"
    if o.level <= LEVEL_COND then code else "(#{code})"

#### Fun
# A function definition. This is the only node that creates a `new Scope`.
class exports.Fun extends Node
  (@params = [], @body = Lines(), @arrow) => @bound = '_this' if arrow is \=>

  children: <[ params body ]>

  show: -> @bound

  # Short-circuit `traverseChildren` method to prevent it
  # from crossing scope boundaries by default.
  traverseChildren: (_, xscope) -> super ... if xscope

  isStatement: -> !!@statement

  jumps: NO

  makeReturn: -> if @statement then @<<<{+returns} else super ...

  compileNode: (o) ->
    pscope = o.scope
    sscope = pscope.shared or pscope
    scope  = o.scope = @body.scope =
      new Scope (if @wrapper then pscope else sscope), @wrapper and sscope
    scope.method = this
    delete o.globals
    scope.assign \_proto, @proto.compile(o) + \.prototype if @proto
    o.indent += TAB
    {params, body, name, tab} = this
    code = \function
    if @bound is \_this
      if @ctor
        scope.assign \_this, 'new _ctor'
        code += """
           _ctor(){} _ctor.prototype = _proto;
          #{tab}function
        """
        body.add Return Literal \_this
      else if b = sscope.method?.bound
      then @bound = b
      else sscope.assign \_this, \this
    args = []; asns = []
    for prm of params then if prm instanceof Splat
      splats = Assign Arr(paramName o, p for p of params), Literal \arguments
      break
    for prm of params
      arg = prm
      if asn = arg instanceof Assign then arg.=left; prm.logic ||= \?
      else  if arg instanceof Splat  then arg.=it
      if arg.isComplex()
        val = ref = paramName o, prm
        val = Op prm.logic, ref, prm.right if asn
        asns.push Assign arg, val
        arg = ref
      else if asn
        if prm.logic is \?
          prm = Op \&&, Literal(arg.value + ' == null'), prm import {-logic}
        asns.push prm
      args.push arg unless splats
    wasEmpty = not (exps = body.lines).length
    asns.unshift splats  if splats
    exps.unshift ...asns if asns.length
    scope.add (args[i] = a.compile o), \arg for a, i of args unless splats
    args.0 = \it if not args.length and body.contains(-> it.value is \it)
    body.makeReturn() unless wasEmpty or @ctor
    if @statement
      unless name
        throw SyntaxError 'cannot declare a nameless function'
      unless o.lines.scope is pscope
        throw SyntaxError 'cannot declare a function under a statement'
      scope .add name, \function
      pscope.add name, \function unless @returns
      code += ' ' + name
    code += "(#{ args.join ', ' }){"
    code += "\n#{ body.compileWithDeclarations o }\n#{tab}" if exps.length
    code += \}
    code += " #{name}.name = '#{name}';" if @ctor and name.charAt(0) isnt \_
    code += "\n#{tab}return #{name};" if @returns
    return tab + code if @statement
    if @front then "(#{code})" else code

  paramName = (o, node) ->
    return that if node.param
    prm = node
    if splat = prm instanceof Splat  then prm.=it
    else    if prm instanceof Assign then prm.=left
    if prm.at
      {name} = prm.tails.0.key
      prm = Literal if name.reserved then \$ + name else name
    else if prm.isComplex()
      prm = Literal o.scope.temporary \arg
    node.param = if splat then Splat prm else prm

#### Class
class exports.Class extends Node
  (@title, @sup, body) -> @fun = Fun [], body

  children: <[ title sup fun ]>

  compileNode: (o) ->
    {fun} = this; {lines} = fun.body
    if @title
      decl = if @title instanceof Value
      then @title.tails[*-1].key?.name
      else @title.value
      if decl?.reserved
        throw SyntaxError "reserved word \"#{decl}\" cannot be a class name"
    name  = decl or @name
    name  = \_Class unless name and IDENTIFIER.test name
    lname = Literal fun.bound = name
    fun.body.traverseChildren -> it.clas = name if it instanceof Fun; void
    for node, i of lines
      if node instanceof Obj
        lines[i] = Import Literal(\_proto), node
        proto = lname
      else if node instanceof Fun and not node.statement
        throw SyntaxError 'more than one constructor in a class' if ctor
        proto = lname if (ctor = node).bound
    lines.unshift ctor = Fun() unless ctor
    lines.push lname
    ctor import {name, +ctor, +statement, -clas}
    args = []
    if @sup
      args.push @sup
      proto = Util.Extends lname, fun.params.* = Literal \_super
    clas = Call fun import {proto}, args
    clas = Assign lname , clas if decl and @title?.isComplex()
    clas = Assign @title, clas if @title
    clas.compile o

#### Super
# Reference to the parent method.
class exports.Super extends Node
  isAssignable: YES

  compile: (o) ->
    {method} = o.scope.shared or o.scope
    throw SyntaxError 'cannot call super outside of a function' unless method
    {name, clas} = method
    if name
      if clas
        return clas + \.superclass.prototype +
               if IDENTIFIER.test name then \. + name else \[ + name + \]
      else if IDENTIFIER.test name
        return name + \.superclass
    return \_super if o.scope.check \_super
    throw SyntaxError 'cannot call super on an anonymous function'

#### Parens
# An extra set of parentheses,
# specifying evaluation order and/or forcing expression.
class exports.Parens extends Node
  (@it, @keep) =>

  children: [\it]

  isComplex: -> @it.isComplex()

  compileNode: (o) ->
    {it} = this
    return (it import {@front}).compile o if not @keep and
      (it instanceof [Value, Call, Fun, Parens, Import] or
       o.level < LEVEL_OP and it instanceof Op)
    o.level = LEVEL_PAREN
    if it.isStatement o then it.compileClosure o else "(#{ it.compile o })"

#### Splat
# A splat, either as a parameter to a function, an argument to a call,
# or as part of a destructuring assignment.
class exports.Splat extends Parens
  (@it) =>

  isAssignable: YES

  assigns: -> @it.assigns it

  compile: -> @it.compile @0, @1

  # Compiles a list of nodes mixed with splats to a proper array.
  @compileArray = (o, list, apply) ->
    break if node instanceof Splat for node, index of list
    return '' if index >= list.length
    if list.length is 1
      code = list.0.compile o, LEVEL_LIST
      return if apply then code else utility(\slice) + ".call(#{code})"
    args = list.slice index
    for node, i of args
      code = node.compile o, LEVEL_LIST
      args[i] = if node instanceof Splat
      then utility(\slice) + ".call(#{code})"
      else "[#{code}]"
    return args.0 + ".concat(#{ args.slice(1).join ', ' })" unless index
    base = (node.compile o, LEVEL_LIST for node of list.slice 0, index)
    "[#{ base.join ', ' }].concat(#{ args.join ', ' })"

#### Statement
# `continue`, `break` or `debugger`
class exports.Statement extends Node
  (@name) ->

  show: -> @name

  isStatement : YES
  makeReturn  : THIS

  jumps: -> not (it and (it.loop or it.block and @name isnt \continue))

  compile: -> it.indent + @name + \;

#### Throw
class exports.Throw extends Statement
  (@it) ->

  children: [\it]

  jumps: NO

  compile: (o) -> o.indent + "throw #{ @it.compile o, LEVEL_PAREN };"

#### Return
class exports.Return extends Throw
  => @<<<{it} if it and it.value isnt \void

  jumps: YES

  compile: (o) ->
    it = if @it then ' ' + @it.compile o, LEVEL_PAREN else ''
    o.indent + "return#{it};"

#### While
# The traditional `while` loop.
# Returns an array of values collected from the last expression when requested.
class exports.While extends Node
  (@test, name) -> @negated = name is \until

  children: <[ test body ]>

  aSource: \test, aTarget: \body

  show: Negatable.show

  isStatement: YES

  jumps: ->
    {lines} = @body
    return false unless lines.length
    context = {+loop}
    return true if node.jumps context for node of lines
    false

  addBody: (@body) ->
    [last, i] = lastNonComment body.lines
    if last instanceof Statement and last.name is \continue
      body.lines.splice i, 1
    this

  makeReturn: ->
    if it
      @body.makeReturn it
    else unless @jumps()
      @returns = true
    this

  compileNode: (o) ->
    code = unless @test then \true else
      @anaphorize()
      (if @negated then @test.invert() else @test).compile o, LEVEL_PAREN
    code = @tab + if code is \true then 'for (;;' else 'while (' + code
    o.indent += TAB
    code + ') {' + @compileBody o

  compileBody: (o) ->
    {lines} = @body; end = \}
    if @returns
      [last, i] = lastNonComment lines
      if last and last not instanceof Throw
        o.scope.assign res = \_results, '[]'
        lines[i] = last.makeReturn res
      end = "}\n#{@tab}return #{ res or '[]' };"
    return end unless lines.length
    "\n#{ @body.compile o, LEVEL_TOP }\n" + @tab + end

#### For
# Coco's replacements for the `for` loop are array, object or range iterators.
class exports.For extends While
  children: <[ name source from to step body ]>

  aSource: null

  show: -> @index

  compileNode: (o) ->
    temps = @temps = []
    if idx = @index
    then o.scope.declare idx
    else temps.push idx = o.scope.temporary \i
    unless @object
      [step, pvar] = (@step || Literal 1).compileLoopReference o, \step
      temps.push pvar if step isnt pvar
    if @from
      eq = if @op is \til then '' else \=
      [tail, tvar] = @to.compileLoopReference o, \to
      vars = idx + ' = ' + @from.compile o
      if tail isnt tvar
        vars += ', ' + tail
        temps.push tvar
      cond = if +pvar
      then "#{idx} #{ if pvar < 0 then \> else \< }#{eq} #{tvar}"
      else "#{pvar} < 0 ? #{idx} >#{eq} #{tvar} : #{idx} <#{eq} #{tvar}"
    else
      if @name or @object and @own
        [srcPart, svar] = @source.compileLoopReference o, \ref
        temps.push svar if srcPart isnt svar
      else
        srcPart = svar = @source.compile o, LEVEL_PAREN
      unless @object
        srcPart = "(#{srcPart})" if srcPart isnt svar
        if 0 > pvar and (pvar | 0) is +pvar  # negative int
          vars = "#{idx} = #{srcPart}.length - 1"
          cond = "#{idx} >= 0"
        else
          temps.push lvar = o.scope.temporary \len
          vars = "#{idx} = 0, #{lvar} = #{srcPart}.length"
          cond = "#{idx} < #{lvar}"
    if @object
      forPart = idx + ' in ' + srcPart
      if @own
        o.scope.assign \_own, '{}.hasOwnProperty'
        ownPart = "if (_own.call(#{svar}, #{idx})) "
    else
      vars += ', ' + step if step isnt pvar
      forPart = vars + "; #{cond}; " + switch +pvar
      case  1 then \++ + idx
      case -1 then \-- + idx
      default idx + if pvar < 0 then ' -= ' + pvar.slice 1 else ' += ' + pvar
    @pluckDirectCalls o
    head = @tab + "for (#{forPart}) #{ ownPart or '' }{"
    o.indent += TAB
    if @name
      head += \\n + o.indent
      item  = svar + "[#{idx}]"
      if @nref
        head += that + ' = ' + item + ', '
        item  = that
      head += Assign(@name, Literal item).compile(o, LEVEL_TOP) + \;
    body  = @compileBody o
    head += \\n + @tab if @name and body.charAt(0) is \}
    head + body

  pluckDirectCalls: (o) ->
    @body.eachChild dig = =>
      unless it instanceof Call and
             (fn = it.callee.unwrap()) instanceof Fun and
             fn.params.length is it.args.length
        return if it instanceof [Fun, For] then null else it.eachChild dig
      if @index
        fn.params.push it.args.* = Literal @index
      if name = @name
        it.args.push Literal if name.isComplex()
        then @nref ||= @temps.* = o.scope.temporary \ref
        else name.value
        fn.params.push name
      it.callee = Value Literal ref = o.scope.temporary \fn
      o.scope.assign ref, fn.compile o import {indent: ''}, LEVEL_LIST
      o.indent = @tab
      void

#### Try
# Classic `try`-`catch`-`finally` block with optional `catch`.
class exports.Try extends Node
  (@attempt, @thrown, @recovery, @ensure) ->

  children: <[ attempt recovery ensure ]>

  show: -> @thrown

  isStatement: YES

  jumps: -> @attempt.jumps(it) or @recovery?.jumps(it)

  makeReturn: ->
    @attempt .=makeReturn it
    @recovery.=makeReturn it if @recovery
    this

  compileNode: (o) ->
    o.indent += TAB
    code = @tab + "try {\n#{ @attempt.compile o, LEVEL_TOP }\n#{@tab}}"
    if @recovery
      reco  = @recovery.compile o, LEVEL_TOP
      code += " catch (#{@thrown}) {\n#{reco}\n#{@tab}}"
    else unless @ensure
      code += ' catch (_e) {}'
    code += " finally {\n#{ @ensure.compile o, LEVEL_TOP }\n#{@tab}}" if @ensure
    code

#### Switch
# Compiles to the regular JS `switch`-`case`-`default`,
# but with forced `break` after each cases.
class exports.Switch extends Node
  (@switch, @cases, @default) ->

  children  : <[ switch cases default ]>

  aSource: \switch, aTarget: \cases

  isStatement: YES

  jumps: (x = {+block}) ->
    return true if cs.body.jumps x for cs of @cases
    @default?.jumps x

  makeReturn: ->
    cs.makeReturn it for cs of @cases
    @default?.makeReturn it
    this

  compileNode: (o) ->
    cond = if @switch
      @anaphorize()
      @switch.compile o, LEVEL_PAREN
    else
      tests[i].=invert() for own i in tests for {tests} of @cases
      false
    {tab} = this
    code  = tab + "switch (#{cond}) {\n"
    stop  = @default or @cases.length - 1
    code += cs.compileCase o, tab, i is stop for cs, i of @cases
    if @default
      o.indent = tab + TAB
      def   = @default.compile o, LEVEL_TOP
      code += tab + "default:#{ def and \\n + def  }\n"
    code + tab + \}

#### Case
# Convinient container node for `case` blocks.
class exports.Case extends Node
  (@tests, @body) =>

  children: <[ tests body ]>

  makeReturn: ->
    [last] = lastNonComment @body.lines
    @body.makeReturn it unless last?.value is \fallthrough

  compileCase: (o, tab, nobr) ->
    code = br = ''
    add  = -> code += tab + "case #{ it.compile o, LEVEL_PAREN }:\n"
    for test of @tests
      if test instanceof Arr
      then add t for t of test.items
      else add test
    [last, i] = lastNonComment exps = @body.lines
    exps[i] = Comment ' fallthrough ' if ft = last?.value is \fallthrough
    o.indent = tab + TAB
    code += that + \\n if @body.compile o, LEVEL_TOP
    code += o.indent + 'break;\n' unless nobr or ft or
      last instanceof Statement and last.name isnt \debugger
    code

#### If
# The `if`/`else` structure that acts as both statement and expression.
class exports.If extends Node
  (@if, @then, {@soak, name} = {}) => @negated = name is \unless

  children  : <[ if then else ]>

  aSource: \if, aTarget: \then

  show: Negatable.show

  # Rewrite a chain of **If**s to add a default case as the final `else`.
  addElse: ->
    if @chain
      @else.addElse it
    else
      @chain = it instanceof If
      @else  = it
    this

  # An **If** only compiles into a statement if either of its bodies needs
  # to be a statement. Otherwise a conditional operator is safe.
  isStatement: (o) ->
    o and not o.level or @then.isStatement(o) or @else?.isStatement(o)

  jumps: -> @then.jumps(it) or @else?.jumps(it)

  makeReturn: ->
    @then.=makeReturn it
    @else.=makeReturn it if @else
    this

  compileNode: (o) ->
    @anaphorize()
    if @isStatement o then @compileStatement o else @compileExpression o

  compileStatement: (o) ->
    code  = if delete o.elsed then '' else @tab
    cond  = if @negated then @if.invert() else @if
    code += "if (#{ cond.compile o, LEVEL_PAREN }) {"
    o.indent += TAB
    code += "\n#{that}\n" + @tab if Lines(@then).compile o
    code += \}
    return code unless @else
    code + ' else ' + if @chain
    then @else.compile o import {indent: @tab, +elsed}, LEVEL_TOP
    else if @else.compile o, LEVEL_TOP
    then "{\n#{that}\n#{@tab}}"
    else '{}'

  # Compile me as a conditional operator.
  compileExpression: (o) ->
    cond = if @negated then @if.invert() else @if
    code = cond.compile o, LEVEL_COND
    pad  = if @else?.isComplex() and @then.isComplex()
    then \\n + o.indent += TAB else ' '
    code += pad + '? ' +  @then .compile(o, LEVEL_LIST) +
            pad + ': ' + (@else?.compile(o, LEVEL_LIST) or 'void 8')
    if o.level < LEVEL_COND then code else "(#{code})"

  unfoldSoak: -> @soak and this

  # Unfold a node's child if soak, then tuck the node under the created **If**.
  @unfoldSoak = (o, parent, name) ->
    if ifn = parent[name].unfoldSoak o
      parent[name] = ifn.then; ifn.then = Value parent
    ifn

#### Comment
# Block comments are compiled as JavaScript block comments at the same position.
class exports.Comment extends Node
  (@comment) =>

  terminator: ''

  compile: (o) -> "/*#{ @comment.replace /\n/g, \\n + o.indent }*/"

#### Util
# A wrapper node for utility functions.
class exports.Util extends Node
  (@name) =>

  show: Statement::show

  compile: -> utility @name

  ##### Util.Clone
  # An operation that creates a new object with its `__proto__`
  # set to the operand, attaching specified properties.
  @Clone = (it, mixin) -> Parens Import Call(Value Util \clone; [it]), mixin

  ##### Util.Extends
  # An operator that sets up class-ical inheritance between two constructors,
  # returning the left one.
  @Extends = (sub, sup) -> Call Value(Util \extends), [sub, sup]

# Export `import all` for use in [parser](../lib/parser.js),
# where the operator doesn't work.
exports import all mix: __importAll

##### Scope
# Regulates lexical scoping within Coco. As you
# generate code, you create a tree of scopes in the same shape as the nested
# functions. Each scope knows about the function parameters and the variables
# declared within it, and has references to its parent/shared enclosing scopes.
(Scope = (@parent, @shared) ->
  @variables = [{name: \arguments, type: \args}]
  @positions = arguments: 0
  this
)::<<<
  # Adds a new variable or overrides an existing one.
  add: (name, type) ->
    if name of <[ arguments eval ]>
      throw SyntaxError "redefining \"#{name}\" is deprecated"
    if @variables[@positions[name]]
    then that import {type}
    else @positions[name] = -1 + @variables.push {name, type}
    this

  # Declares a variable unless declared already.
  declare: (name) ->
    scope = @shared or this
    scope.add name, \var unless scope.type(name) of <[ var arg ]>
    this

  # Ensures that an assignment is made at the top of this scope.
  assign: (name, value) -> @add name, {value}

  # If we need to store an intermediate result, find an available name for a
  # compiler-generated variable. `_var`, `_var2`, and so on...
  temporary: (name) ->
    i = 0
    for ever
      temp = \_ + if name.length > 1
      then name + (if i++ then i else '')
      else (i++ + parseInt name, 36).toString 36
      break if @type(temp) of [\reuse, void]
    @add temp, \var
    temp

  # Allows a variable to be reused.
  free: -> @add it, \reuse

  # Checks to see if a variable has already been declared.
  # Walks up the scope if `above` flag is specified.
  check: (name, above) ->
    return found if (found = @positions[name] in @variables) or not above
    !!@parent?.check name, above

  # Gets the type of a variable from name.
  type: -> @variables[@positions[it]]?.type

  # Returns the list of variables declared in this scope.
  vars: (global) ->
    usr = []; tmp = []; asn = []
    for {name, type} of @variables
      if type of <[ var reuse ]>
        (if name.charAt(0) is \_ then tmp else usr).push name
      else if type.value
        asn.push name + ' = ' + type.value
    return asn.join ', '    if global
    'var ' + that if usr.concat(tmp, asn).join ', '

##### Constants

function YES  -> true
function NO   -> false
function THIS -> this

UTILITIES =
  # Creates an object's prototypal child, ensuring `__proto__`.
  clone: '''
    function(it){
      function fn(){ if (this.__proto__ !== it) this.__proto__ = it }
      return fn.prototype = it, new fn;
    }
  '''
  # Sets up `.prototype` between a pair of constructors
  # as well as `.constructor` and `.superclass` references.
  extends: '''
    function(sub, sup){
      function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
      return (sub.prototype = new ctor).constructor = sub;
    }
  '''

  # Wraps a function to fixate its `this` value.
  bind: '''
    function(me, fn){ return function(){ return fn.apply(me, arguments) } }
  '''

  # Copies properties from right to left.
  import: '''
    function(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
  '''
  importAll: '''
    function(obj, src){ for (var key in src) obj[key] = src[key]; return obj }
  '''

  # Shortcuts to speed up the lookup time for native functions.
  slice   : '[].slice'
  indexOf : '''
    [].indexOf || function(x){
      for (var i = this.length; i-- && this[i] !== x;); return i;
    }
  '''

# Levels indicates a node's position in the AST.
LEVEL_TOP    = 0  # ...;
LEVEL_PAREN  = 1  # (...)
LEVEL_LIST   = 2  # [...]
LEVEL_COND   = 3  # ... ? x : y
LEVEL_OP     = 4  # !...
LEVEL_ACCESS = 5  # ...[0]

# Tabs are two spaces for pretty printing.
TAB = '  '

IDENTIFIER = /^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*$/
METHOD_DEF = /// ^
  (?: (\S+)\.prototype(?=\.) | \S*? )
  (?: (?:\.|^)([$A-Za-z_][$\w]*) | \[( ([\"\']).+?\4 | \d+ )])
$ ///

##### Helpers

# Declares a utility function at the top level.
utility = (name) ->
  Scope.root.assign ref = \__ + name, UTILITIES[name]
  ref

lastNonComment = (nodes) ->
  break if node not instanceof Comment for node, i of nodes by -1
  [i >= 0 and node, i]
