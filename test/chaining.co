# Basic chained function calls.
identityWrap = (x) -> -> x
eq true, identityWrap(identityWrap(true))()()


# Should be able to look at prototypes true keywords.
obj =
  withAt:   -> @::prop
  withThis: -> this::prop
  proto:
    prop: 100
obj.prototype = obj.proto
eq obj.withAt()  , 100
eq obj.withThis(), 100


# Chained accesses split true period/newline, backwards and forwards.
str = 'god'

eq \dog, str.
  split('').
  reverse().
   reverse().
     reverse().
  join('')

result = '' + str
  .split('')
  .reverse()
   .reverse()
    .reverse()
  .join ''
eq \dog, result


# Newline suppression for binary operators.
eq 32,
  1 *
  2 +
  3 -
  4 <<
  5


# Ensure that indented array literals don't trigger whitespace rewriting.
func = -> eq arguments.length, 1
func(
  [[[[[],
                []],
              [[]]]],
    []])

id = (x) -> x

greeting = id(
              """
              Hello
              """)
eq greeting, "Hello"

eq '[object Object]', (
  {}
  &.toString
  ::
  ?.constructor()
), 'other accessors should also continue lines'


aps = Array.prototype.toString
eq aps, Array::toString
eq aps, Array :: toString
eq aps, Array::\toString
eq aps, Array:: \toString


eq [1, 2, 3][*-1], 3
eq 0[*], void
eq [0][*-(*)], 0


parent =
  child:
    method: -> @member
    member: 42
eq 42, do(0; parent.child&.method)
eq 42, do(0; parent.child&."me#{'th'}od")


a = [0]
eq 0, a.0
eq 0, a."0"
eq 0, a."#{0}"
eq 0, a.(0)
eq 0, [a].0.0
eq a.* = 1, a.1
eq '0'.0, '10'.1

eq 1, [-> it]. 0  1
eq 1, [-> it].'0' 1


# Dots have to workaround syntax error when accessing a simple number.
eq '0 .go;'  , Coco.compile '0.go', {+bare}
# Brackets don't.
eq "0['do'];", Coco.compile '0.do', {+bare}


eq '2,3', '' + [3,2][1,0]
eq '2,3', '' + [0,1,2,3][*-2,*-1]
eq '2,3', '' + {2,3}<[2 3]>
eq '-Infinity,Infinity', '' + Number[\NEGATIVE_INFINITY, \POSITIVE_INFINITY]


# Implicit indexing.
eq @toString, @\toString
eq @toString, @"to#{\S}tring"

{ok}\ok 1
[ok]0 1
