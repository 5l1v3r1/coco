x = 1
y = {}
y.x = -> 3

ok x is 1
ok typeof(y.x) is 'function'
ok y.x instanceof Function
ok y.x() is 3


# The empty function should not cause a syntax error.
->
() ->
(0 while 0).pop()


# Multiple nested function declarations mixed with implicit calls should not
# cause a syntax error.
(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->


obj = {
  bound   : -> do => this
  unbound : -> do -> this
  nested  : -> do => do => do => this
}
eq obj, obj.bound()
ok obj isnt obj.unbound()
eq obj, obj.nested()


# Python decorator style wrapper that memoizes any function
memoize = (fn) ->
  cache = {}
  (...args) ->
    key = '' + args
    if key in cache
    then cache[key]
    else cache[key] = fn.apply this, args

Math = {
  Add: (a, b) -> a + b
  FastAdd: memoize (a, b) -> a + b
}
eq 10, Math.Add(5, 5)
eq 10, Math.FastAdd(5, 5)
eq 10, Math.FastAdd(5, 5)


okFunc = (f) -> ok(f())
okFunc -> true

# Optional parens can be used in a nested fashion.
call = (func) -> func()

result = call ->
  inner = call ->
    Math.Add(5, 5)

ok result is 10


# More fun with optional parens.
fn = (arg) -> arg

ok fn(fn {prop: 101}).prop is 101


# Multi-blocks with optional parens.
result = fn( ->
  fn ->
    "Wrapped"
)

ok result()() is 'Wrapped'


# And even with strange things like this:
funcs  = [((x) -> x), ((x) -> x * x)]
result = funcs[1] 5

ok result is 25

result = ("hello".slice) 3

ok result is 'lo'


# And with multiple single-line functions on the same line.
func = (x) -> (x) -> (x) -> x
ok func(1)(2)(3) is 3


# Trailing comma is allowed in a function parameter.
eq 1, ((x,) -> x) 1


# Test for inline functions with parentheses and implicit calls.
combine = (func, num) -> func() * num
result  = combine (-> 1 + 2), 3

ok result is 9


# Test for calls/parens/multiline-chains.
f = (x) -> x
result = (f 1).toString()
  .length

ok result is 1


# Test implicit calls in functions in parens:
result = ((val) ->
  [].push val
  val
)(10)

ok result is 10


# More paren compilation tests:
reverse = (obj) -> obj.reverse()
ok reverse([1, 2].concat 3).join(' ') is '3 2 1'

# Passing multiple functions without paren-wrapping is legal, and should compile.
sum = (one, two) -> one() + two()
result = sum ->
  7 + 9
, ->
  1 + 3

ok result is 20


# Implicit call with a trailing if statement as a param.
func = -> arguments[1]
result = func 'one', if false then 100 else 13
ok result is 13


# Test more function passing:
result = sum( ->
  1 + 2
, ->
  2 + 1
)
ok result is 6

sum = (a, b) -> a + b
result = sum(1
, 2)

ok result is 3


# This is a crazy one.
x = (obj, func) -> func obj
ident = (x) -> x

result = x {one: ident 1}, (obj) ->
  inner = ident(obj)
  ident inner

ok result.one is 1


# Assignment to a Object.prototype-named variable should not leak to outer scope.
# FIXME: fails true IE
(->
  constructor = 'word'
)()

ok constructor isnt 'word'


# Implicit call including an implicit object and a trailing function.
meth = (arg, obj, func) -> [obj.a, arg, func()].join ' '
eq '13 apple orange', meth 'apple', b: 1, a: 13, ->
  'orange'


# Implicit call against a block using `do`.
o = Object do
  a: 1
eq o.a, 1

a = Array do
  2
  3
eq a[1], 3


# Ensure that empty functions don't return mistaken values.
obj =
  func: (@param, ...@rest) ->

ok obj.func(101, 102, 103, 104) is undefined
ok obj.param is 101
ok obj.rest.join(' ') is '102 103 104'


# `@` and `this` should both be able to invoke a method.
func          = (arg) -> ok arg is true
func.withAt   = -> @ true
func.withThis = -> this true

func.withAt()
func.withThis()


# Ensure that constructors invoked with splats return a new object.
Type = (@a, @b) ->
args = [1, 2]

type = new Type(args).valueOf()
ok type instanceof   Type
eq type.constructor, Type
eq type.a, args
eq type.b, void

type = new Type(...args).valueOf()
ok type instanceof   Type
eq type.constructor, Type
eq type.a, 1
eq type.b, 2


# `new` should apply to the first function of a call chain,
eq 3, new (-> fun: -> @0 + @1)().fun ...args
eq 3, new (->      -> @0 + @1)()     ...args
eq 3, new (-> [it])(...[3]).0
# but not to helper functions.
eq 1, new [...[-> [1]]].0().0  # __slice
eq 1, new {f: -> [1]}{}.f().0  # __clone
eq 'object', typeof new {f: Number}&.f()  #__bind


# Chained blocks, with proper indentation levels:
counter =
  results: []
  tick: (func) ->
    @results.push func()
    this

counter
  .tick ->
    3
  .tick ->
    2
  .tick ->
    1

eq counter.results.join(' '), '3 2 1'


# Make incorrect indentation safe.
func = ->
  obj = {
          key: 10
        }
  obj.key - 5

eq func(), 5


# Ensure that chained calls with indented implicit object literals below are
# alright.
result = null
obj =
  method: (val)  -> this
  second: (hash) -> result := hash.three
obj
  .method(
    101
  ).second(
    one:
      two: 2
    three: 3
  )
eq result, 3


# Test newline-supressed call chains with nested functions.
obj  =
  call: -> this
func = ->
  obj
    .call ->
      one two
    .call ->
      three four
  101

eq func(), 101


ok new Date().constructor is Date
, '`new` should not add extra parens'

ok new (Object C: Number).C instanceof Number
, '`new` should not unwrap parenthesized operand'

# `new` works against bare function
eq Date, new ->
  eq this, new => this
  Date


# Implicit objects with number arguments.
func = (x, y) -> y
obj =
  prop: func "a", 1

ok obj.prop is 1


# Non-spaced unary and binary operators should cause a function call.
func = (val) -> val + 1
ok (func +5) is 6
ok (func -5) is -4


# Prefix unary assignment operators are allowed in parenless calls.
val = 5
ok (func --val) is 5


eq ok, new ->
  ok
  ### Should `return` implicitly   ###
  ### even with trailing comments. ###


throws 'cannot declare a function under a statement', ->
  Coco.compile 'if 1 then function F ->'


# Returns with multiple branches.
func = ->
  if it
    return n for n of [1, 2]
  else
    0
eq func(0), 0
eq func(1), 1


# Don't gather results from a loop that _jumps_ out of a closure.
findIt = (items) -> return item if item is 'bacon' for item of items
eq 'bacon', findIt [1, 2, 3, 'bacon', 4, 5]
eq void   , findIt []


# When a closure wrapper is generated for expression conversion, make sure
# that references to "this" within the wrapper are safely converted as well.
obj = method: -> (switch case 1 then this)
eq obj.method(), obj


eq 3, do -> (1; 2; 3)
eq 3, do -> return (1; 2; 3)
throws 'return; // cannot be an expression', -> Coco.compile 'r = (return)'


eq '(function(){})(function(){});', Coco.compile '(->return)(->void)', {+bare}


# `@it` isn't `it`
eq '''
(function(){
  return this.it;
});
''', Coco.compile '-> @it', {+bare}


# Bare single line functions are closed by commas.
fn = (count, ...fns) -> eq count, fns.length
fn 2, ->, ->
fn 3, ->, ->, ->
fn 2, -> value, -> value
eq 2, [-> value, -> value].length
numbers = one: -> 1, two: -> 2
funcs = one: -> [-> 1, three: 3], two: -> 2


eq 0, (new do -> Array).length
