# `it`
I = (x) -> x
eq I, I I

I = -> it
eq I, I I I

eq \0, (-> (key for key in it).0) {0}


# Bare calls.
eq I (), I( )


# The empty function should not cause a syntax error.
->
(0 while 0).pop()


# Multiple nested function declarations mixed with implicit calls should not
# cause a syntax error.
(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->


obj = {
  bound   : -> do => this
  unbound : -> do -> this
  nested  : -> do => do => do => this
}
eq obj, obj.bound()
ok obj is not obj.unbound()
eq obj, obj.nested()


# Python decorator style wrapper that memoizes any function.
memoize = (fn) ->
  cache = {}
  (...args) ->
    key = '' + args
    if key in cache
    then cache[key]
    else cache[key] = fn.apply this, args

fastAdd = memoize (a, b) -> a + b

eq 10, fastAdd(5, 5)
eq 10, fastAdd(5, 5)

okFunc = (f) -> ok(f())
okFunc -> true


# Multi-blocks with optional parens.
result = I( ->
  I ->
    "Wrapped"
)
eq result()(), 'Wrapped'


funcs  = [(x) -> x, (x) -> x * x]
eq 25, funcs[0] funcs.1 5


eq 'lo', ("hello".slice) 3


# Nested single-line functions.
func = (x) -> (x) -> (x) -> x
eq func(1)(2)(3), 3


# Trailing comma/semicolon in a function parameter.
eq 1, ((f,) -> f()) (,) -> 1
eq 2, ((f;) -> f()) (;) -> 2


# Implicit calls in functions in parens.
eq 10, ((val) ->
  [].push val
  val
)(10)


# Passing multiple multiline functions without paren-wrapping.
sum = (one, two) -> one() + two()
eq 6, sum(->
  1 + 2
, ->
  2 + 1
)
eq 20, sum ->
  7 + 9
, ->
  ### spacer ###
  1 + 3


# Implicit calls against trailing conditional branches.
eq 1, if false then 0 else 1
eq 0, # `switch` currently needs indentation here
  switch 0 case 0 then 0 default 1


# Implicit calls using leading commas.
eq 1
,  1
eq \
  2
, 2


# Assignment to an inner variable that shares a name with
# an `Object.prototype` member should not leak.
(-> constructor = 'word')()
ok constructor is not 'word'


# Implicit call including an implicit object and a trailing function.
meth = (arg, obj, func) -> '' + [obj.a, arg, func()]
eq '13,apple,orange', meth 'apple', b: 1, a: 13, ->
  'orange'


# Implicit call against a block using `do`.
o = Object do
  a: 1
eq o.a, 1

a = Array do
  2
  3
eq a[1], 3


# Ensure that empty functions don't return mistaken values.
o = func: (@param, ...@rest) ->

eq void , o.func(101, 102, 103, 104)
eq 101  , o.param
eq '102,103,104', '' + o.rest


(->
  this it, it
  @    it, it
).call ok, '`this` should be able to call implicitly'


# Ensure that constructors invoked with splats return a new object.
Type = (@a, @b) ->
args = [1, 2]

type = new Type(args).valueOf()
ok type instanceof   Type
eq type.constructor, Type
eq type.a, args
eq type.b, void

type = new Type(...args).valueOf()
ok type instanceof   Type
eq type.constructor, Type
eq type.a, 1
eq type.b, 2


# `new` should apply to the first function of a call chain,
eq 3, new (-> fun: -> @0 + @1)().fun ...args
eq 3, new (->      -> @0 + @1)()     ...args
eq 3, new (-> [it])(...[3]).0
# but not to helper functions.
eq 1, new [...[-> [1]]].0().0  # __slice
eq 1, new {f: -> [1]}{}.f().0  # __clone
eq 'object', typeof new {f: Number}&.f()  # __bind


# Chained blocks, with proper indentation levels:
counter =
  results: []
  tick: (func) ->
    @results.push func()
    this

counter
  .tick ->
    3
  .tick ->
    2
  .tick ->
    1

eq counter.results.join(' '), '3 2 1'


# Make incorrect indentation safe.
func = ->
  obj = {
          key: 10
        }
  obj.key - 5

eq func(), 5


# Chained calls with indented implicit object literals.
result = null
obj =
  method: (val)  -> this
  second: (hash) -> result := hash.three
obj
  .method(
    101
  ).second(
    one:
      two: 2
    three: 3
  )
eq result, 3


# Newline-supressed call chains with nested functions.
obj  =
  call: -> this
func = ->
  obj
    .call ->
      one two
    .call ->
      three four
  101

eq func(), 101


ok new Date().constructor is Date
, '`new` should not add extra parens'

ok new (Object C: Number).C instanceof Number
, '`new` should not unwrap parenthesized operand'

# `new` works against bare function
eq Date, new ->
  eq this, new => this
  Date


# Implicit calls against non-spaced unary plus/minus.
eq +5, +5
eq -5, -5


# Implicit calls against precrements.
n = 0
eq ++n, 1
eq --n, 0


eq ok, new ->
  ok
  ### Should `return` implicitly   ###
  ### even with trailing comments. ###


throws 'cannot declare a function under a statement', ->
  Coco.compile 'if 1 then function F ->'


# Returns with multiple branches.
func = ->
  if it
    return n for n of [1, 2]
  else
    0
eq func(0), 0
eq func(1), 1


# Don't gather results from a loop that _jumps_ out of a closure.
findIt = (items) -> return item if item is 'bacon' for item of items
eq 'bacon', findIt [1, 2, 3, 'bacon', 4, 5]
eq void   , findIt []


# When a closure wrapper is generated for expression conversion, make sure
# that references to "this" within the wrapper are safely converted as well.
obj = method: -> (switch case 1 then this)
eq obj.method(), obj


eq 3, do -> (1; 2; 3)
eq 3, do -> return (1; 2; 3)
throws 'return; // cannot be an expression', -> Coco.compile 'r = (return)'


eq '(function(){})(function(){});', Coco.compile '(->return)(->void)', {+bare}


# `@it` isn't `it`
eq '''
(function(){
  return this.it;
});
''', Coco.compile '-> @it', {+bare}


# Bare single line functions are closed by commas.
fn = (count, ...fns) -> eq count, fns.length
fn 2, ->, ->
fn 3, ->, ->, ->
fn 2, -> value, -> value
eq 2, [-> value, -> value].length
numbers = one: -> 1, two: -> 2
funcs = one: -> [-> 1, three: 3], two: -> 2


eq 0, (new do -> Array).length


x = y = 10; x1 = y1 = 20
area = (x, y, x1, y1) ->
  (x - x1) * (x - y1)

eq area(x, y, x1, y1), 100
eq(area(
  x
  y
  x1, y1
), 100)


sumOfArgs = ->
  sum = 0
  sum += val for val of arguments
  sum

eq 15, sumOfArgs(1, 2, 3, 4, 5)


((@arg) ->).call context = {}, 1
eq 1, context.arg

((...splat, @arg) ->).call context, 1, 2, 3
eq 3, context.arg

((...@arg) ->).call context, 1, 2, 3
eq '1,2,3', '' + context.arg


eq 1, new (class then (@do) -> eq @do, $do)(1).do


# Destructuring.
((...[{a: [b], c}]) ->
  eq b, 123
  eq c, 456
) {a: [123], c: 456}


# Default values.
obj = f: (q = 123, @p = 456) -> q
eq obj.f(), 123
eq obj.p  , 456

withSplats = (a = 2, ...b, c = 3, d ? 5) -> a * (b.length + 1) * c * d
eq 30, withSplats()
eq 15, withSplats 1
eq  5, withSplats 1, 1
eq  1, withSplats 1, 1, 1
eq  2, withSplats 1, 1, 1, 1

f = (a || 2, b && 5) -> a + b
eq 7, f 0, 1
eq 1, f 1, 0
eq 6, f 1, 1
eq 2, f 0, 0

do (a = I(1)) -> eq a, 1


(->
  eq @0, 0
  eq @1, 1
  eq @2, @@[2]
  eq @999, void
) 0, 1, 2


eq arguments,
  switch case 1
    eq arguments, (arguments for i from 1 to 1)[0]
    arguments


throws 'duplicate formal argument: a', -> Coco.compile '(a, a) ->'


ok (@arguments, @eval) ->


# Call takes precedence over function parameter.
eq 0, I(-> it()) -> 0
